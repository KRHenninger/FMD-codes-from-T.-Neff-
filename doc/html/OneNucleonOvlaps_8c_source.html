<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FMD: fmd/OneNucleonOvlaps.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>fmd/OneNucleonOvlaps.c</h1>  </div>
</div>
<div class="contents">
<a href="OneNucleonOvlaps_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;complex.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="Gaussian_8h.html">Gaussian.h</a>&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="SlaterDet_8h.html">SlaterDet.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="CenterofMass_8h.html">CenterofMass.h</a>&quot;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="OneNucleonOvlaps_8h.html">OneNucleonOvlaps.h</a>&quot;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="cmath_8h.html">numerics/cmath.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="cmat_8h.html">numerics/cmat.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="gaussquad_8h.html">numerics/gaussquad.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="sphericalharmonics_8h.html">numerics/sphericalharmonics.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="clebsch_8h.html">numerics/clebsch.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="lapack_8h.html">numerics/lapack.h</a>&quot;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="utils_8h.html">misc/utils.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="physics_8h.html">misc/physics.h</a>&quot;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="OneNucleonOvlaps_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">00035</a> <span class="preprocessor">#define SQR(x)  ((x)*(x))</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00037"></a>00037 
<a name="l00038"></a><a class="code" href="OneNucleonOvlaps_8c.html#a669098e4f7d42cdaef90238953d85733">00038</a> <span class="keywordtype">char</span>* <a class="code" href="OneNucleonOvlaps_8c.html#a669098e4f7d42cdaef90238953d85733">speclabel</a>[NSPEC] = { <span class="stringliteral">&quot;S12&quot;</span>, <span class="stringliteral">&quot;P12&quot;</span>, <span class="stringliteral">&quot;P32&quot;</span>, <span class="stringliteral">&quot;D32&quot;</span>, <span class="stringliteral">&quot;D52&quot;</span> };
<a name="l00039"></a><a class="code" href="OneNucleonOvlaps_8c.html#a581366e9c4e1a7524e2c72cb9a307ca5">00039</a> <span class="keywordtype">int</span>   <a class="code" href="OneNucleonOvlaps_8c.html#a581366e9c4e1a7524e2c72cb9a307ca5">specj</a>[NSPEC]     = { 1, 1, 3, 3, 5 };
<a name="l00040"></a><a class="code" href="OneNucleonOvlaps_8c.html#a90e7669d65b1e73e0fb181efe76074bd">00040</a> <span class="keywordtype">int</span>   <a class="code" href="OneNucleonOvlaps_8c.html#a90e7669d65b1e73e0fb181efe76074bd">specl</a>[NSPEC]     = { 0, 2, 2, 4, 4 };
<a name="l00041"></a><a class="code" href="OneNucleonOvlaps_8c.html#a13396ab49d1309c7c94166be31333904">00041</a> <span class="keywordtype">int</span>   <a class="code" href="OneNucleonOvlaps_8c.html#a13396ab49d1309c7c94166be31333904">io</a>[NSPEC]        = { 0, 2, 4, 8, 12 };
<a name="l00042"></a><a class="code" href="OneNucleonOvlaps_8c.html#a0d11ff77b25d124a8da3e15837b1e4b8">00042</a> <span class="keywordtype">int</span>   <a class="code" href="OneNucleonOvlaps_8c.html#a0d11ff77b25d124a8da3e15837b1e4b8">dimo</a>[NSPEC]      = { 2, 2, 4, 4, 6 };
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="comment">// The following Many-Body Operators have to initialized with</span>
<a name="l00046"></a>00046 <span class="comment">// int dim and FormfactorPara par before use</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="comment">// Array of Multipole Formfactor Operators</span>
<a name="l00049"></a><a class="code" href="OneNucleonOvlaps_8h.html#a14a3f5a98f800054572b1b091f81c311">00049</a> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a> <a class="code" href="OneNucleonOvlaps_8c.html#ac6405f3f461eb760c1d9754485f2796e">OpOneNucleonOvlap</a>[NSPEC];
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="OneNucleonOvlaps_8h.html#a5e5ae9b011549095d5187d513702ec5d">00052</a> <a class="code" href="structManyBodyOperators.html" title="Collection of ManyBody Operators.">ManyBodyOperators</a> <a class="code" href="OneNucleonOvlaps_8c.html#a5e5ae9b011549095d5187d513702ec5d">OpOneNucleonOvlaps</a> = {
<a name="l00053"></a>00053   <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> : NSPEC,
<a name="l00054"></a>00054   Op : OpOneNucleonOvlap,
<a name="l00055"></a>00055   me : <a class="code" href="OneNucleonOvlaps_8c.html#a42967fd3325f926c97831d03dd54a6b4">calcOneNucleonOvlapsod</a>
<a name="l00056"></a>00056 };
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 
<a name="l00060"></a><a class="code" href="OneNucleonOvlaps_8h.html#a1d81975fc00ddd64d268364c0f48941d">00060</a> <span class="keywordtype">void</span> <a class="code" href="OneNucleonOvlaps_8c.html#a1d81975fc00ddd64d268364c0f48941d">initOpOneNucleonOvlaps</a>(<a class="code" href="structOneNucleonOvlapsPara.html">OneNucleonOvlapsPara</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a>)
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062   <span class="keywordtype">char</span>* name = malloc(60);
<a name="l00063"></a>00063   sprintf(name, <span class="stringliteral">&quot;OneNucleonOvlaps-%05.2f-%d-%d-%d%s&quot;</span>,
<a name="l00064"></a>00064           par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a4d8ef3bb676dc775742a4cc9748288e7">qmax</a>, par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a82775128fc0a957ce02701e9e7ec471e">npoints</a>, par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a2d02d16c65727571705d14464bb6000f">nalpha</a>, par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#aaaa4b55ab58bc37550b6d273b2687ac0">ncosb</a>, par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a4bf08246692e2a321bb4dbb7679f24df">recoil</a> ? <span class="stringliteral">&quot;-recoil&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00065"></a>00065 
<a name="l00066"></a>00066   OpOneNucleonOvlaps.<a class="code" href="structManyBodyOperators.html#a331636b79824e209f31a9bfcac5bc026">name</a> = name;
<a name="l00067"></a>00067   OpOneNucleonOvlaps.<a class="code" href="structManyBodyOperators.html#aa1b09f1ea3ecfedd76ca27f7954ce65b" title="has to be the same for all Operators">dim</a> = par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a82775128fc0a957ce02701e9e7ec471e">npoints</a>;
<a name="l00068"></a>00068   OpOneNucleonOvlaps.<a class="code" href="structManyBodyOperators.html#a94494657638d56cc4a332f00aefcd1e4">size</a> = par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a82775128fc0a957ce02701e9e7ec471e">npoints</a>;
<a name="l00069"></a>00069   OpOneNucleonOvlaps.<a class="code" href="structManyBodyOperators.html#a63b81b5a508a075fd10b76ebd219094f" title="the same for all operators">par</a> = par;
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <span class="keywordtype">int</span> i;
<a name="l00072"></a>00072   <span class="keywordflow">for</span> (i=0; i&lt;NSPEC; i++) {
<a name="l00073"></a>00073     <span class="keywordtype">char</span>* name = malloc(60);
<a name="l00074"></a>00074     sprintf(name, <span class="stringliteral">&quot;OneNucleonOvlap%s-%05.2f-%d-%d-%d%s&quot;</span>,
<a name="l00075"></a>00075             <a class="code" href="OneNucleonOvlaps_8c.html#a669098e4f7d42cdaef90238953d85733">speclabel</a>[i],
<a name="l00076"></a>00076             par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a4d8ef3bb676dc775742a4cc9748288e7">qmax</a>, par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a82775128fc0a957ce02701e9e7ec471e">npoints</a>, par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a2d02d16c65727571705d14464bb6000f">nalpha</a>, par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#aaaa4b55ab58bc37550b6d273b2687ac0">ncosb</a>, par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a4bf08246692e2a321bb4dbb7679f24df">recoil</a> ? <span class="stringliteral">&quot;-recoil&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00077"></a>00077     OpOneNucleonOvlap[i].<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a> = name;
<a name="l00078"></a>00078     OpOneNucleonOvlap[i].<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a> = <a class="code" href="OneNucleonOvlaps_8c.html#a581366e9c4e1a7524e2c72cb9a307ca5">specj</a>[i];
<a name="l00079"></a>00079     OpOneNucleonOvlap[i].<a class="code" href="structManyBodyOperator.html#a78ec7c9f2238907255cf499427676907" title="parity of operator, 0 positve, 1 negative">pi</a> = <a class="code" href="OneNucleonOvlaps_8c.html#a90e7669d65b1e73e0fb181efe76074bd">specl</a>[i] % 4 ? 1 : 0;
<a name="l00080"></a>00080     OpOneNucleonOvlap[i].<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a> = par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a82775128fc0a957ce02701e9e7ec471e">npoints</a>;
<a name="l00081"></a>00081     OpOneNucleonOvlap[i].<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a> = par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a82775128fc0a957ce02701e9e7ec471e">npoints</a>;
<a name="l00082"></a>00082     OpOneNucleonOvlap[i].<a class="code" href="structManyBodyOperator.html#a05268b1b149040fd992263f2e22de7ec">par</a> = par;
<a name="l00083"></a>00083     OpOneNucleonOvlap[i].<a class="code" href="structManyBodyOperator.html#aba2e7e550190ee2ec6e75c23c55fee2d">me</a> = NULL;
<a name="l00084"></a>00084   }
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="comment">// static SlaterDet and overlap matrices</span>
<a name="l00089"></a>00089 <span class="keyword">static</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a> *QAp;
<a name="l00090"></a>00090 <span class="keyword">static</span> complex <span class="keywordtype">double</span> *<a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, *nlu;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="comment">// overlap between Gaussians</span>
<a name="l00094"></a>00094 <span class="keyword">static</span> complex <span class="keywordtype">double</span> calcGaussianOvlap(<span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G1, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G2)
<a name="l00095"></a>00095 {
<a name="l00096"></a>00096   <span class="keywordflow">if</span> (G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a> != G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)
<a name="l00097"></a>00097     <span class="keywordflow">return</span> 0.0;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099   <span class="keywordtype">int</span> T;
<a name="l00100"></a>00100   complex <span class="keywordtype">double</span> lambda, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a20f4c4490bc8ecbdd1ffcb79acce6035" title="finestructure constant">alpha</a>, pi[3], pi2, S, R;
<a name="l00101"></a>00101     
<a name="l00102"></a>00102   lambda = 1.0/(conj(G1-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)+G2-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>);
<a name="l00103"></a>00103   alpha = conj(G1-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)*G2-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>*lambda;
<a name="l00104"></a>00104   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;3; i++)       
<a name="l00105"></a>00105     pi[i] = lambda*I*(conj(G1-&gt;<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[i]) - G2-&gt;<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[i]);
<a name="l00106"></a>00106   pi2 = cvec3sqr(pi);
<a name="l00107"></a>00107   
<a name="l00108"></a>00108   T = 1;
<a name="l00109"></a>00109   S = conj(G1-&gt;<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[0])*G2-&gt;<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[0] + conj(G1-&gt;<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[1])*G2-&gt;<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[1];
<a name="l00110"></a>00110   R = cpow32(2*M_PI*alpha)*cexp(0.5*pi2/lambda);
<a name="l00111"></a>00111   <span class="keywordflow">return</span> (T*S*R);
<a name="l00112"></a>00112 }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="comment">// calculate overlap matrix between QA and QB</span>
<a name="l00116"></a>00116 <span class="keyword">static</span> <span class="keywordtype">void</span> calcOvlapsAB(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* QA, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* QB, complex <span class="keywordtype">double</span>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#afa106e3c58721409e0e2c7ae6980cf25">N</a>)
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118   assert(QA-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>+1 == QB-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>);
<a name="l00119"></a>00119   
<a name="l00120"></a>00120   <span class="keywordtype">int</span> A=QB-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>;
<a name="l00121"></a>00121   <span class="keywordtype">int</span>* idxA=QA-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* idxB=QB-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; 
<a name="l00122"></a>00122   <span class="keywordtype">int</span>* ngA=QA-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>; <span class="keywordtype">int</span>* ngB=QB-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00123"></a>00123   <a class="code" href="structGaussian.html">Gaussian</a>* GA=QA-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>; <a class="code" href="structGaussian.html">Gaussian</a>* GB=QB-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>,ki,li;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   <span class="comment">// overlap matrix between QB and QA</span>
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00130"></a>00130     <span class="keywordflow">for</span> (k=0; k&lt;A-1; k++) {
<a name="l00131"></a>00131       N[k+l*A] = 0.0;
<a name="l00132"></a>00132       <span class="keywordflow">if</span> (GA[idxA[k]].xi == GB[idxB[l]].xi) { 
<a name="l00133"></a>00133         <span class="keywordflow">for</span> (li=0; li&lt;ngB[l]; li++)
<a name="l00134"></a>00134           <span class="keywordflow">for</span> (ki=0; ki&lt;ngA[k]; ki++) {
<a name="l00135"></a>00135             N[k+l*A] += calcGaussianOvlap(&amp;GA[idxA[k]+ki], &amp;GB[idxB[l]+li]); 
<a name="l00136"></a>00136           }
<a name="l00137"></a>00137       }
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="comment">// calculate overlap matrix for QA+nucleon with QB</span>
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keyword">static</span> <span class="keywordtype">void</span> calcSpecOvlaps(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* QA,
<a name="l00145"></a>00145                     <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2vappiso_8c.html#a8d84be5ae01eee28a4a7932c6e568d27">iso</a>, <span class="keywordtype">double</span> <a class="code" href="MinimizerDONLP2_8c.html#a116d67c73cdfa395275c96c0151ddcd4">q</a>[3],
<a name="l00146"></a>00146                     <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* QB,
<a name="l00147"></a>00147                     complex <span class="keywordtype">double</span>* N, complex <span class="keywordtype">double</span>* Nlu,
<a name="l00148"></a>00148                     complex <span class="keywordtype">double</span> spec[2])
<a name="l00149"></a>00149 {
<a name="l00150"></a>00150   assert(QA-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>+1 == QB-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>);
<a name="l00151"></a>00151   
<a name="l00152"></a>00152   <span class="keywordtype">int</span> A=QB-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>;
<a name="l00153"></a>00153   <span class="keywordtype">int</span> ngaussB=QB-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; 
<a name="l00154"></a>00154   <span class="keywordtype">int</span>* idxB=QB-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* ngB=QB-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00155"></a>00155   <a class="code" href="structGaussian.html">Gaussian</a>* GB=QB-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <span class="keywordtype">int</span> l,li;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159   <span class="keywordtype">double</span> q2 = vec3sqr(q);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="keywordtype">int</span> ipiv[A];
<a name="l00162"></a>00162   <span class="keywordtype">int</span> info;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164   <span class="comment">// overlap matrix elements of QB with QA should have been calculated already</span>
<a name="l00165"></a>00165 
<a name="l00166"></a>00166   <span class="comment">// overlap matrix elements with plane wave</span>
<a name="l00167"></a>00167   <span class="comment">// isospin overlap zero or one by definition</span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169   <span class="comment">// spatial overlap is independent from spin: calculate only once</span>
<a name="l00170"></a>00170   complex <span class="keywordtype">double</span> nR[ngaussB];
<a name="l00171"></a>00171   <a class="code" href="structGaussian.html">Gaussian</a>* g;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="keywordflow">for</span> (li=0; li&lt;ngaussB; li++) {
<a name="l00174"></a>00174     g = &amp;GB[li];
<a name="l00175"></a>00175     <span class="keywordflow">if</span> (iso != g-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)
<a name="l00176"></a>00176       nR[li] = 0.0;
<a name="l00177"></a>00177     <span class="keywordflow">else</span>
<a name="l00178"></a>00178       nR[li] = cpow32(g-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)* cexp(-0.5*g-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>*q2 - I*(q[0]*g-&gt;<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[0]+q[1]*g-&gt;<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[1]+q[2]*g-&gt;<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[2]));
<a name="l00179"></a>00179   }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   <span class="comment">// be careful: chi[0] is the spin up, chi[1] the spin-down component</span>
<a name="l00182"></a>00182   <span class="comment">// but destroying a spin-up is a spin-down operator</span>
<a name="l00183"></a>00183   <span class="comment">// tensor operator matrix elements go from 0: -m ... m</span>
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <span class="comment">// spin-up plane wave in bra</span>
<a name="l00186"></a>00186   <span class="keywordflow">for</span> (l=0; l&lt;A; l++) {
<a name="l00187"></a>00187     N[(A-1)+l*A] = 0.0;
<a name="l00188"></a>00188     <span class="keywordflow">for</span> (li=0; li&lt;ngB[l]; li++) {
<a name="l00189"></a>00189       N[(A-1)+l*A] += GB[idxB[l]+li].chi[0]* nR[idxB[l]+li];
<a name="l00190"></a>00190     }
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <a class="code" href="cmat_8c.html#a25c4069e471b679af8dfdf807f30cd5a" title="copy matrix A into B">copycmat</a>(A, N, Nlu);
<a name="l00194"></a>00194   <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#ae87f81c04c9dcd293299f610428d3cb3" title="compute an LU factorization of a general M-by-N matrix A">zgetrf</a>)(&amp;A, &amp;A, Nlu, &amp;A, ipiv, &amp;info);
<a name="l00195"></a>00195   <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#a45cd458d60d896788dc5024019d30828">zdet</a>)(Nlu, &amp;A, &amp;A, ipiv, &amp;spec[1]);
<a name="l00196"></a>00196   
<a name="l00197"></a>00197   <span class="comment">// spin-down plane wave in bra</span>
<a name="l00198"></a>00198   <span class="keywordflow">for</span> (l=0; l&lt;A; l++) {
<a name="l00199"></a>00199     N[(A-1)+l*A] = 0.0;
<a name="l00200"></a>00200     <span class="keywordflow">for</span> (li=0; li&lt;ngB[l]; li++) {
<a name="l00201"></a>00201       N[(A-1)+l*A] += GB[idxB[l]+li].chi[1]* nR[idxB[l]+li];
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203   }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205   <a class="code" href="cmat_8c.html#a25c4069e471b679af8dfdf807f30cd5a" title="copy matrix A into B">copycmat</a>(A, N, Nlu);
<a name="l00206"></a>00206   <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#ae87f81c04c9dcd293299f610428d3cb3" title="compute an LU factorization of a general M-by-N matrix A">zgetrf</a>)(&amp;A, &amp;A, Nlu, &amp;A, ipiv, &amp;info);
<a name="l00207"></a>00207   <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#a45cd458d60d896788dc5024019d30828">zdet</a>)(Nlu, &amp;A, &amp;A, ipiv, &amp;spec[0]);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="comment">// hermitian adjoint of destruction operator is tricky</span>
<a name="l00213"></a>00213 <span class="comment">// tilde{a}_j,m = (-1)^(j+m) a_j,-m</span>
<a name="l00214"></a>00214 
<a name="l00215"></a><a class="code" href="OneNucleonOvlaps_8h.html#a6bf7448e9dcb9145c8e1c7621f301933">00215</a> <span class="keywordtype">void</span> <a class="code" href="OneNucleonOvlaps_8c.html#a42967fd3325f926c97831d03dd54a6b4">calcOneNucleonOvlapsod</a>(<a class="code" href="structOneNucleonOvlapsPara.html">OneNucleonOvlapsPara</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a>,
<a name="l00216"></a>00216                             <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* QA, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* QB,
<a name="l00217"></a>00217                             <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* dummyX,
<a name="l00218"></a>00218                             complex <span class="keywordtype">double</span>* specamplitude)
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220   <span class="keywordtype">double</span> qmax = par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a4d8ef3bb676dc775742a4cc9748288e7">qmax</a>;
<a name="l00221"></a>00221   <span class="keywordtype">int</span> ialpha, nalpha = par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a2d02d16c65727571705d14464bb6000f">nalpha</a>;
<a name="l00222"></a>00222   <span class="keywordtype">int</span> icosb, ncosb = par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#aaaa4b55ab58bc37550b6d273b2687ac0">ncosb</a>;
<a name="l00223"></a>00223   <span class="keywordtype">int</span> npoints = par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a82775128fc0a957ce02701e9e7ec471e">npoints</a>;
<a name="l00224"></a>00224   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>, ml, ms, o, i;
<a name="l00225"></a>00225   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, l;
<a name="l00226"></a>00226   <span class="keywordtype">double</span> alpha, beta, weight;
<a name="l00227"></a>00227   <span class="keywordtype">double</span> q, k[3];
<a name="l00228"></a>00228   complex <span class="keywordtype">double</span> sa[2];
<a name="l00229"></a>00229   <span class="keywordtype">int</span> gaussoverlapsdone = 0;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   <span class="comment">// initialize workspace if necessary</span>
<a name="l00232"></a>00232   <span class="keywordflow">if</span> (!QAp) {
<a name="l00233"></a>00233     QAp = malloc(<span class="keyword">sizeof</span>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>));
<a name="l00234"></a>00234     <a class="code" href="SlaterDet_8c.html#a16db6f53cfee239b7d506c86bc372686">initSlaterDet</a>(QA, QAp);
<a name="l00235"></a>00235     
<a name="l00236"></a>00236     <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(QB-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>)*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00237"></a>00237     nlu = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(QB-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>)*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00238"></a>00238   }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240   <a class="code" href="SlaterDet_8c.html#acd974ea424b0829a55ada79fc69abd90">copySlaterDet</a>(QA, QAp);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242   <span class="comment">// add single nucleon with momentum q</span>
<a name="l00243"></a>00243   <span class="comment">// proton or neutron ?</span>
<a name="l00244"></a>00244   <span class="keywordtype">int</span> iso = (QA-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> == QB-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a>) ? -1 : +1;
<a name="l00245"></a>00245   <span class="keywordtype">double</span> massA = QA-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a>*<a class="code" href="physics_8c.html#a8eb62e76681c15cad3ccab9c10160c14" title="proton mass [fm^-1]">mproton</a>+QA-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>*<a class="code" href="physics_8c.html#a2da201ca1cde1f55795ebdf8f65c524d" title="neutron mass [fm^-1]">mneutron</a>;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="keywordflow">for</span> (o=0; o&lt;NSPEC; o++)
<a name="l00248"></a>00248     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="OneNucleonOvlaps_8c.html#a0d11ff77b25d124a8da3e15837b1e4b8">dimo</a>[o]*npoints; i++)
<a name="l00249"></a>00249       specamplitude[i+<a class="code" href="OneNucleonOvlaps_8c.html#a13396ab49d1309c7c94166be31333904">io</a>[o]*npoints] = 0.0;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="keywordtype">double</span> alphal[nalpha], walphal[nalpha];
<a name="l00252"></a>00252   <span class="keywordtype">double</span> cosbl[ncosb], wcosbl[ncosb];
<a name="l00253"></a>00253   
<a name="l00254"></a>00254   <a class="code" href="gaussquad_8c.html#a4c0554e8a66b1be46ead18ca02290a2d">ShiftedPeriodicTrapezoidalPoints</a>(nalpha, 0, 2*M_PI, 0.0, alphal, walphal);
<a name="l00255"></a>00255   <a class="code" href="gaussquad_8c.html#aef4fbaefecb9e1201af41ba17d6f8845" title="weight function 1">GaussLegendrePoints</a>(ncosb, -1, 1, cosbl, wcosbl); 
<a name="l00256"></a>00256 
<a name="l00257"></a>00257   <span class="keywordflow">for</span> (i=0; i&lt;npoints; i++) {
<a name="l00258"></a>00258     q = qmax* i/(npoints-1);
<a name="l00259"></a>00259     <span class="keywordflow">for</span> (ialpha=0; ialpha&lt;nalpha; ialpha++)
<a name="l00260"></a>00260       <span class="keywordflow">for</span> (icosb=0; icosb&lt;ncosb; icosb++) {
<a name="l00261"></a>00261         alpha = alphal[ialpha];
<a name="l00262"></a>00262         beta = acos(cosbl[icosb]);
<a name="l00263"></a>00263         weight = walphal[ialpha]*wcosbl[icosb];
<a name="l00264"></a>00264  
<a name="l00265"></a>00265         k[0] = q*cos(alpha)*sin(beta); 
<a name="l00266"></a>00266         k[1] = q*sin(alpha)*sin(beta);
<a name="l00267"></a>00267         k[2] = q*cos(beta);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         <span class="keywordflow">if</span> (par-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a4bf08246692e2a321bb4dbb7679f24df">recoil</a>) {
<a name="l00270"></a>00270           <span class="comment">// boost QA by -k</span>
<a name="l00271"></a>00271           <span class="keywordtype">double</span> VcmA[3] = {-k[0]/massA, -k[1]/massA, -k[2]/massA};
<a name="l00272"></a>00272           <a class="code" href="SlaterDet_8c.html#acd974ea424b0829a55ada79fc69abd90">copySlaterDet</a>(QA, QAp);
<a name="l00273"></a>00273           <a class="code" href="SlaterDet_8c.html#ad154093b24c00e82ac9129d87cd2e049" title="boost Slater determinant with speed v">boostSlaterDet</a>(QAp, VcmA);
<a name="l00274"></a>00274           gaussoverlapsdone = 0;
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         <span class="keywordflow">if</span> (!gaussoverlapsdone) {
<a name="l00278"></a>00278           calcOvlapsAB(QAp, QB, <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>);
<a name="l00279"></a>00279           gaussoverlapsdone = 1;
<a name="l00280"></a>00280         }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282         calcSpecOvlaps(QAp, iso, k, QB, <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, nlu, sa);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284         <span class="keywordflow">for</span> (ms=-1; ms&lt;=1; ms=ms+2) {
<a name="l00285"></a>00285           <span class="keywordflow">for</span> (o=0; o&lt;NSPEC; o++) {
<a name="l00286"></a>00286             j = <a class="code" href="OneNucleonOvlaps_8c.html#a581366e9c4e1a7524e2c72cb9a307ca5">specj</a>[o]; l = <a class="code" href="OneNucleonOvlaps_8c.html#a90e7669d65b1e73e0fb181efe76074bd">specl</a>[o];
<a name="l00287"></a>00287             <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2) {
<a name="l00288"></a>00288               ml = m-ms;
<a name="l00289"></a>00289               <span class="keywordflow">if</span> (-l&lt;=ml &amp;&amp; ml&lt;=l) {
<a name="l00290"></a>00290                 specamplitude[(-m+j)/2 + i*<a class="code" href="OneNucleonOvlaps_8c.html#a0d11ff77b25d124a8da3e15837b1e4b8">dimo</a>[o] + <a class="code" href="OneNucleonOvlaps_8c.html#a13396ab49d1309c7c94166be31333904">io</a>[o]*npoints] += weight* 
<a name="l00291"></a>00291                   ((j-m)%4 ? -1 : +1)* 
<a name="l00292"></a>00292                   <a class="code" href="clebsch_8c.html#a7b75250723cf843449ee508426c81537">clebsch</a>(l, 1, j, ml, ms, m)* sa[(ms+1)/2]* 
<a name="l00293"></a>00293                   conj(<a class="code" href="sphericalharmonics_8c.html#a4517398bd7d1af1c7b318fab1d18dde0">Y</a>(l,ml,beta,alpha));
<a name="l00294"></a>00294               }
<a name="l00295"></a>00295             }
<a name="l00296"></a>00296           }
<a name="l00297"></a>00297         }
<a name="l00298"></a>00298     }   
<a name="l00299"></a>00299   }
<a name="l00300"></a>00300 }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="comment">// output routine</span>
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 
<a name="l00307"></a><a class="code" href="OneNucleonOvlaps_8h.html#a2728acaa1a11ca7a88592aa838cf4a81">00307</a> <span class="keywordtype">void</span> <a class="code" href="OneNucleonOvlaps_8c.html#a2728acaa1a11ca7a88592aa838cf4a81">writeOneNucleonOvlaps</a>(FILE* fp,
<a name="l00308"></a>00308                            <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00309"></a>00309                            <span class="keyword">const</span> <a class="code" href="structOneNucleonOvlapsPara.html">OneNucleonOvlapsPara</a>* p,
<a name="l00310"></a>00310                            <span class="keywordtype">int</span> jfin, <span class="keywordtype">int</span> pfin, <span class="keywordtype">int</span> afin,
<a name="l00311"></a>00311                            <span class="keywordtype">int</span> jini, <span class="keywordtype">int</span> pini, <span class="keywordtype">int</span> aini,
<a name="l00312"></a>00312                            <span class="keywordtype">void</span>* specamplitudeme,
<a name="l00313"></a>00313                            <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Efin,
<a name="l00314"></a>00314                            <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Eini)
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00317"></a>00317   <span class="keywordtype">int</span> ipjfin = idxpij(jmax,pfin,jfin);
<a name="l00318"></a>00318   <span class="keywordtype">int</span> ipjini = idxpij(jmax,pini,jini);
<a name="l00319"></a>00319   <span class="keywordtype">int</span> npoints = p-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a82775128fc0a957ce02701e9e7ec471e">npoints</a>;
<a name="l00320"></a>00320   <span class="keywordtype">double</span> qmax = p-&gt;<a class="code" href="structOneNucleonOvlapsPara.html#a4d8ef3bb676dc775742a4cc9748288e7">qmax</a>;
<a name="l00321"></a>00321   <span class="keywordtype">int</span> idxfin = Efin-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipjfin][afin];
<a name="l00322"></a>00322   <span class="keywordtype">int</span> idxini = Eini-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipjini][aini];
<a name="l00323"></a>00323   <span class="keywordtype">double</span> normfin = Efin-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipjfin][idxfin];
<a name="l00324"></a>00324   <span class="keywordtype">double</span> normini = Eini-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipjini][idxini];
<a name="l00325"></a>00325   complex double (****specampme)[npoints] = specamplitudeme;
<a name="l00326"></a>00326   complex <span class="keywordtype">double</span> *sa = specampme[ipjfin][ipjini][idxfin][idxini];
<a name="l00327"></a>00327   <span class="keywordtype">int</span> i;
<a name="l00328"></a>00328   <span class="keywordtype">double</span> q;
<a name="l00329"></a>00329   complex <span class="keywordtype">double</span> ml;
<a name="l00330"></a>00330   
<a name="l00331"></a>00331   <span class="comment">// calculate spectroscopic factor</span>
<a name="l00332"></a>00332   <span class="keywordtype">double</span> dq = qmax/(npoints-1);
<a name="l00333"></a>00333   <span class="keywordtype">double</span> S = 0.0;
<a name="l00334"></a>00334   <span class="keywordflow">for</span> (i=0; i&lt;npoints; i++) {
<a name="l00335"></a>00335     q = i*dq;
<a name="l00336"></a>00336     S += dq*<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(q)* (jfin+1.0)/(jini+1.0)*<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(cabs(sa[i]))/(normfin*normini);
<a name="l00337"></a>00337   }
<a name="l00338"></a>00338   fprintf(stderr, <span class="stringliteral">&quot;Spectroscopic factor: %6.3f\n&quot;</span>, S);
<a name="l00339"></a>00339 
<a name="l00340"></a>00340   <span class="comment">// write spectroscopic amplitudes</span>
<a name="l00341"></a>00341   <span class="keywordflow">for</span> (i=0; i&lt;npoints; i++) {
<a name="l00342"></a>00342     q = i*dq;
<a name="l00343"></a>00343     
<a name="l00344"></a>00344     <span class="comment">// we include factor 1/sqrt(2*Jini+1) into definiton</span>
<a name="l00345"></a>00345     <span class="comment">// of spectroscopic amplitude</span>
<a name="l00346"></a>00346 
<a name="l00347"></a>00347     ml = sqrt((jfin+1.0)/(jini+1.0))* sa[i]/sqrt(normfin*normini);
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     fprintf(fp, <span class="stringliteral">&quot;%6.3f\t%13.5g\t%13.5g\n&quot;</span>, q, creal(ml), cimag(ml));
<a name="l00350"></a>00350   }
<a name="l00351"></a>00351 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 4 2012 14:05:34 for FMD by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
