<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FMD: fmd/TwoBodyDensity.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>fmd/TwoBodyDensity.c</h1>  </div>
</div>
<div class="contents">
<a href="TwoBodyDensity_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;complex.h&gt;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;<a class="code" href="Gaussian_8h.html">Gaussian.h</a>&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;<a class="code" href="SlaterDet_8h.html">SlaterDet.h</a>&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;<a class="code" href="TwoBodyDensity_8h.html">TwoBodyDensity.h</a>&quot;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="cmath_8h.html">numerics/cmath.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="sphericalbessel_8h.html">numerics/sphericalbessel.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="legendrep_8h.html">numerics/legendrep.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="clebsch_8h.html">numerics/clebsch.h</a>&quot;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="physics_8h.html">misc/physics.h</a>&quot;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 
<a name="l00028"></a><a class="code" href="TwoBodyDensity_8c.html#aacc3ee1a7f283f8ef65cea31f4436a95">00028</a> <span class="preprocessor">#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a><a class="code" href="TwoBodyDensity_8c.html#a22f4e97ed7ca9e188dc4e074a1b2e5a7">00030</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="TwoBodyDensity_8c.html#a22f4e97ed7ca9e188dc4e074a1b2e5a7">sqr</a>(<span class="keywordtype">double</span> <a class="code" href="donlp2_8h.html#a693a5a39c68cf597f5264260a0f2e380">x</a>) { <span class="keywordflow">return</span> x*x; }
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">// (S,T)=(0,0),(0,1),(1,0),(1,1)</span>
<a name="l00033"></a>00033 <span class="comment">// summed over MS and MT</span>
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="TwoBodyDensity_8h.html#afd576fdbb2b0dc5b5b5265214dd91478">00035</a> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a> <a class="code" href="TwoBodyDensity_8c.html#afd576fdbb2b0dc5b5b5265214dd91478">OpPairs</a> = {
<a name="l00036"></a>00036  name : <span class="stringliteral">&quot;Pairs&quot;</span>,
<a name="l00037"></a>00037  rank : 0,
<a name="l00038"></a>00038  pi : 0,
<a name="l00039"></a>00039  <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a> : 4,
<a name="l00040"></a>00040  size : 4,
<a name="l00041"></a>00041  <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a> : NULL,
<a name="l00042"></a>00042  me : <a class="code" href="TwoBodyDensity_8c.html#a8b69809dffc224716ce5c4f84c73763f">calcPairsod</a>
<a name="l00043"></a>00043 };
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">// (S,T)=(0,0),(0,1),(1,0),(1,1)</span>
<a name="l00047"></a>00047 <span class="comment">// summed over MS and MT</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="comment">// we might also be interested in pp,nn channels</span>
<a name="l00050"></a>00050 
<a name="l00051"></a><a class="code" href="TwoBodyDensity_8h.html#ad9d133a7f74e84c2e0d064b4a97fb166">00051</a> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a> <a class="code" href="TwoBodyDensity_8c.html#ad9d133a7f74e84c2e0d064b4a97fb166">OpTwoBodyDensityR</a> = {
<a name="l00052"></a>00052   name : NULL,
<a name="l00053"></a>00053   rank : 0,
<a name="l00054"></a>00054   pi : 0,
<a name="l00055"></a>00055   <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a> : 0,
<a name="l00056"></a>00056   size : 0,
<a name="l00057"></a>00057   <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a> : NULL,
<a name="l00058"></a>00058   me : <a class="code" href="TwoBodyDensity_8c.html#a283088360b53bc96310aba7f3a13cb0d">calcTBDensRod</a>
<a name="l00059"></a>00059 };
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="TwoBodyDensity_8h.html#a9b59ff2a0e2d440a910d3b93e389313e">00061</a> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a> <a class="code" href="TwoBodyDensity_8c.html#a9b59ff2a0e2d440a910d3b93e389313e">OpTwoBodyDensityQ</a> = {
<a name="l00062"></a>00062   name : NULL,
<a name="l00063"></a>00063   rank : 0,
<a name="l00064"></a>00064   pi : 0,
<a name="l00065"></a>00065   <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a> : 0,
<a name="l00066"></a>00066   size : 0,
<a name="l00067"></a>00067   <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a> : NULL,
<a name="l00068"></a>00068   me : <a class="code" href="TwoBodyDensity_8c.html#af503e20cc06e6f282df7a09936823009">calcTBDensQod</a>
<a name="l00069"></a>00069 };
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="comment">// two-body densities in different L channels</span>
<a name="l00072"></a>00072 <span class="comment">// total density for each S,T channel and individual contributions up to Lmax</span>
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="TwoBodyDensity_8h.html#a11c418ddac8619f73adefc9f611cae6b">00074</a> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a> <a class="code" href="TwoBodyDensity_8c.html#a11c418ddac8619f73adefc9f611cae6b">OpTwoBodyDensityRL</a> = {
<a name="l00075"></a>00075   name : NULL,
<a name="l00076"></a>00076   rank : 0,
<a name="l00077"></a>00077   pi : 0,
<a name="l00078"></a>00078   <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a> : 0,
<a name="l00079"></a>00079   size : 0,
<a name="l00080"></a>00080   <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a> : NULL,
<a name="l00081"></a>00081   me : <a class="code" href="TwoBodyDensity_8c.html#a7528d0a1e9cae4eb7e0965f3c8012641">calcTBDensRLod</a>
<a name="l00082"></a>00082 };
<a name="l00083"></a>00083 
<a name="l00084"></a><a class="code" href="TwoBodyDensity_8h.html#a2bd6a3f97049004ff4362c89130a4a91">00084</a> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a> <a class="code" href="TwoBodyDensity_8c.html#a2bd6a3f97049004ff4362c89130a4a91">OpTwoBodyDensityQL</a> = {
<a name="l00085"></a>00085   name : NULL,
<a name="l00086"></a>00086   rank : 0,
<a name="l00087"></a>00087   pi : 0,
<a name="l00088"></a>00088   <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a> : 0,
<a name="l00089"></a>00089   size : 0,
<a name="l00090"></a>00090   <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a> : NULL,
<a name="l00091"></a>00091   me : <a class="code" href="TwoBodyDensity_8c.html#aa7b5e3da6d000b76a4b57b56ca221369">calcTBDensQLod</a>
<a name="l00092"></a>00092 };
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 
<a name="l00095"></a><a class="code" href="TwoBodyDensity_8h.html#adf093ee63c8b222d7a80b20b90e4c3e8">00095</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#adf093ee63c8b222d7a80b20b90e4c3e8">initOpTwoBodyDensityR</a>(<a class="code" href="structTBDensRPara.html">TBDensRPara</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a>)
<a name="l00096"></a>00096 {
<a name="l00097"></a>00097   <span class="keywordtype">char</span>* name = malloc(60);
<a name="l00098"></a>00098   sprintf(name, <span class="stringliteral">&quot;TwoBodyDensityR-%05.2f-%d&quot;</span>, 
<a name="l00099"></a>00099           par-&gt;<a class="code" href="structTBDensRPara.html#adbf86c3fbdf12333426645958f9b093c">rmax</a>, par-&gt;<a class="code" href="structTBDensRPara.html#ab4db1b883c5654364f62a8339adc5296">npoints</a>);
<a name="l00100"></a>00100   OpTwoBodyDensityR.<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a> = name;
<a name="l00101"></a>00101   OpTwoBodyDensityR.<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a> = 4*par-&gt;<a class="code" href="structTBDensRPara.html#ab4db1b883c5654364f62a8339adc5296">npoints</a>;
<a name="l00102"></a>00102   OpTwoBodyDensityR.<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a> = 4*par-&gt;<a class="code" href="structTBDensRPara.html#ab4db1b883c5654364f62a8339adc5296">npoints</a>;
<a name="l00103"></a>00103   OpTwoBodyDensityR.<a class="code" href="structManyBodyOperator.html#a05268b1b149040fd992263f2e22de7ec">par</a> = par;
<a name="l00104"></a>00104 }  
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 
<a name="l00107"></a><a class="code" href="TwoBodyDensity_8h.html#a57099171b52f99a88b0815e8ff2212ad">00107</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#a57099171b52f99a88b0815e8ff2212ad">initOpTwoBodyDensityQ</a>(<a class="code" href="structTBDensQPara.html">TBDensQPara</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a>)
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109   <span class="keywordtype">char</span>* name = malloc(60);
<a name="l00110"></a>00110   sprintf(name, <span class="stringliteral">&quot;TwoBodyDensityQ-%05.2f-%d&quot;</span>, par-&gt;<a class="code" href="structTBDensQPara.html#a491a5a6133ad45a4560f0857e197b37b">qmax</a>, par-&gt;<a class="code" href="structTBDensQPara.html#ac89b3597a5c0adb7021e95e374678502">npoints</a>);
<a name="l00111"></a>00111   OpTwoBodyDensityQ.<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a> = name;
<a name="l00112"></a>00112   OpTwoBodyDensityQ.<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a> = 4*par-&gt;<a class="code" href="structTBDensQPara.html#ac89b3597a5c0adb7021e95e374678502">npoints</a>;
<a name="l00113"></a>00113   OpTwoBodyDensityQ.<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a> = 4*par-&gt;<a class="code" href="structTBDensQPara.html#ac89b3597a5c0adb7021e95e374678502">npoints</a>;
<a name="l00114"></a>00114   OpTwoBodyDensityQ.<a class="code" href="structManyBodyOperator.html#a05268b1b149040fd992263f2e22de7ec">par</a> = par;
<a name="l00115"></a>00115 }  
<a name="l00116"></a>00116   
<a name="l00117"></a>00117 
<a name="l00118"></a><a class="code" href="TwoBodyDensity_8h.html#a5775ccafdb5d8cf9d3c9546a9e54f58b">00118</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#a5775ccafdb5d8cf9d3c9546a9e54f58b">initOpTwoBodyDensityRL</a>(<a class="code" href="structTBDensRLPara.html">TBDensRLPara</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a>)
<a name="l00119"></a>00119 {
<a name="l00120"></a>00120   <span class="keywordtype">char</span>* name = malloc(60);
<a name="l00121"></a>00121   sprintf(name, <span class="stringliteral">&quot;TwoBodyDensityRL-%d-%d-%05.2f-%d&quot;</span>, 
<a name="l00122"></a>00122           par-&gt;<a class="code" href="structTBDensRLPara.html#a6ad216782130a0d46b727289b50ee860">lmax</a>, par-&gt;<a class="code" href="structTBDensRLPara.html#a01c8498024d2506c8d67bc181adb4ecf">lambdamax</a>, par-&gt;<a class="code" href="structTBDensRLPara.html#ab517a044fc7ba2df43df153e7b2e1ff7">rmax</a>, par-&gt;<a class="code" href="structTBDensRLPara.html#abec1102b0c109f46ca243edd20bc5dd3">npoints</a>);
<a name="l00123"></a>00123   OpTwoBodyDensityRL.<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a> = name;
<a name="l00124"></a>00124   OpTwoBodyDensityRL.<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a> = (2*par-&gt;<a class="code" href="structTBDensRLPara.html#a6ad216782130a0d46b727289b50ee860">lmax</a>+6)*par-&gt;<a class="code" href="structTBDensRLPara.html#abec1102b0c109f46ca243edd20bc5dd3">npoints</a>;
<a name="l00125"></a>00125   OpTwoBodyDensityRL.<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a> = (2*par-&gt;<a class="code" href="structTBDensRLPara.html#a6ad216782130a0d46b727289b50ee860">lmax</a>+6)*par-&gt;<a class="code" href="structTBDensRLPara.html#abec1102b0c109f46ca243edd20bc5dd3">npoints</a>;
<a name="l00126"></a>00126   OpTwoBodyDensityRL.<a class="code" href="structManyBodyOperator.html#a05268b1b149040fd992263f2e22de7ec">par</a> = par;
<a name="l00127"></a>00127 }  
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 
<a name="l00130"></a><a class="code" href="TwoBodyDensity_8h.html#abab7b4db1771568a7935cf6d51f5dbd2">00130</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#abab7b4db1771568a7935cf6d51f5dbd2">initOpTwoBodyDensityQL</a>(<a class="code" href="structTBDensQLPara.html">TBDensQLPara</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a>)
<a name="l00131"></a>00131 {
<a name="l00132"></a>00132   <span class="keywordtype">char</span>* name = malloc(60);
<a name="l00133"></a>00133   sprintf(name, <span class="stringliteral">&quot;TwoBodyDensityQL-%d-%d-%05.2f-%d&quot;</span>, 
<a name="l00134"></a>00134           par-&gt;<a class="code" href="structTBDensQLPara.html#aaae4a3cc890015e6371f445dc5503325">lmax</a>, par-&gt;<a class="code" href="structTBDensQLPara.html#a2db67d2e19e6d737fc387c3fb1ad98a6">lambdamax</a>, par-&gt;<a class="code" href="structTBDensQLPara.html#a5ba3edae0e24cea318b7f762a3b91ebc">qmax</a>, par-&gt;<a class="code" href="structTBDensQLPara.html#aa87408498a7059e4ce88f1e7628da010">npoints</a>);
<a name="l00135"></a>00135   OpTwoBodyDensityQL.<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a> = name;
<a name="l00136"></a>00136   OpTwoBodyDensityQL.<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a> = (2*par-&gt;<a class="code" href="structTBDensQLPara.html#aaae4a3cc890015e6371f445dc5503325">lmax</a>+6)*par-&gt;<a class="code" href="structTBDensQLPara.html#aa87408498a7059e4ce88f1e7628da010">npoints</a>;
<a name="l00137"></a>00137   OpTwoBodyDensityQL.<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a> = (2*par-&gt;<a class="code" href="structTBDensQLPara.html#aaae4a3cc890015e6371f445dc5503325">lmax</a>+6)*par-&gt;<a class="code" href="structTBDensQLPara.html#aa87408498a7059e4ce88f1e7628da010">npoints</a>;
<a name="l00138"></a>00138   OpTwoBodyDensityQL.<a class="code" href="structManyBodyOperator.html#a05268b1b149040fd992263f2e22de7ec">par</a> = par;
<a name="l00139"></a>00139 }  
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keywordtype">void</span> tb_pairs(<span class="keywordtype">void</span>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ab2c55582dfa6bab91946cc148b3578cd">par</a>,
<a name="l00143"></a>00143                      <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G1, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G2, 
<a name="l00144"></a>00144                      <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G3, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G4, 
<a name="l00145"></a>00145                      <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X13, <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X24, 
<a name="l00146"></a>00146                      complex <span class="keywordtype">double</span> pairs[4])
<a name="l00147"></a>00147 {       
<a name="l00148"></a>00148   <span class="keywordtype">int</span> TT, tautau;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150   TT = X13-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a> * X24-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>;
<a name="l00151"></a>00151   tautau = ((1-G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)*(1-G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>))/4+
<a name="l00152"></a>00152     (G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>+G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)/2; 
<a name="l00153"></a>00153 
<a name="l00154"></a>00154   <span class="keywordflow">if</span> (!TT &amp;&amp; !tautau) <span class="keywordflow">return</span>;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   complex <span class="keywordtype">double</span> SS, sigsig;
<a name="l00157"></a>00157   complex <span class="keywordtype">double</span> RR;
<a name="l00158"></a>00158   
<a name="l00159"></a>00159   SS = X13-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a> * X24-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a>; 
<a name="l00160"></a>00160   sigsig = cvec3mult(X13-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>, X24-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162   RR = X13-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a> * X24-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164   <span class="comment">// S,T=0,0</span>
<a name="l00165"></a>00165   pairs[0] += 0.25*(SS-sigsig)*0.25*(TT-tautau)*RR;
<a name="l00166"></a>00166   <span class="comment">// S,T=0,1</span>
<a name="l00167"></a>00167   pairs[1] += 0.25*(SS-sigsig)*0.25*(3*TT+tautau)*RR;
<a name="l00168"></a>00168   <span class="comment">// S,T=1,0</span>
<a name="l00169"></a>00169   pairs[2] += 0.25*(3*SS+sigsig)*0.25*(TT-tautau)*RR;
<a name="l00170"></a>00170   <span class="comment">// S,T=1,1</span>
<a name="l00171"></a>00171   pairs[3] += 0.25*(3*SS+sigsig)*0.25*(3*TT+tautau)*RR;
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="comment">/*</span>
<a name="l00175"></a>00175 <span class="comment"></span>
<a name="l00176"></a>00176 <span class="comment">// static workspace for angular grid</span>
<a name="l00177"></a>00177 <span class="comment"></span>
<a name="l00178"></a>00178 <span class="comment">static int nalpha = 0;</span>
<a name="l00179"></a>00179 <span class="comment">static int ncosb = 0;</span>
<a name="l00180"></a>00180 <span class="comment">static double* alphal;</span>
<a name="l00181"></a>00181 <span class="comment">static double* walphal;</span>
<a name="l00182"></a>00182 <span class="comment">static double* cosbl;</span>
<a name="l00183"></a>00183 <span class="comment">static double* wcosbl;</span>
<a name="l00184"></a>00184 <span class="comment"></span>
<a name="l00185"></a>00185 <span class="comment">static void initializeangulargrid(int na, int nb)</span>
<a name="l00186"></a>00186 <span class="comment">{</span>
<a name="l00187"></a>00187 <span class="comment">  // already initialized ?</span>
<a name="l00188"></a>00188 <span class="comment">  if (nalpha == na &amp;&amp; ncosb == nb)</span>
<a name="l00189"></a>00189 <span class="comment">    return;</span>
<a name="l00190"></a>00190 <span class="comment"></span>
<a name="l00191"></a>00191 <span class="comment">  nalpha = na;</span>
<a name="l00192"></a>00192 <span class="comment">  ncosb = nb;</span>
<a name="l00193"></a>00193 <span class="comment"></span>
<a name="l00194"></a>00194 <span class="comment">  alphal = malloc(nalpha*sizeof(double));</span>
<a name="l00195"></a>00195 <span class="comment">  walphal = malloc(nalpha*sizeof(double));</span>
<a name="l00196"></a>00196 <span class="comment">  cosbl = malloc(ncosb*sizeof(double));</span>
<a name="l00197"></a>00197 <span class="comment">  wcosbl = malloc(ncosb*sizeof(double));</span>
<a name="l00198"></a>00198 <span class="comment"></span>
<a name="l00199"></a>00199 <span class="comment">  ShiftedPeriodicTrapezoidalPoints(nalpha, 0, 2*M_PI, 0.0, alphal, walphal);</span>
<a name="l00200"></a>00200 <span class="comment">  GaussLegendrePoints(ncosb, -1, 1, cosbl, wcosbl);</span>
<a name="l00201"></a>00201 <span class="comment">}</span>
<a name="l00202"></a>00202 <span class="comment"></span>
<a name="l00203"></a>00203 <span class="comment"></span>
<a name="l00204"></a>00204 <span class="comment">static void tb_densr(TBDensRPara* par,</span>
<a name="l00205"></a>00205 <span class="comment">                     const Gaussian* G1, const Gaussian* G2, </span>
<a name="l00206"></a>00206 <span class="comment">                     const Gaussian* G3, const Gaussian* G4, </span>
<a name="l00207"></a>00207 <span class="comment">                     const GaussianAux* X13, const GaussianAux* X24, </span>
<a name="l00208"></a>00208 <span class="comment">                     complex double* densr)</span>
<a name="l00209"></a>00209 <span class="comment">{</span>
<a name="l00210"></a>00210 <span class="comment">  int npoints = par-&gt;npoints;</span>
<a name="l00211"></a>00211 <span class="comment">  double rmax= par-&gt;rmax;</span>
<a name="l00212"></a>00212 <span class="comment"></span>
<a name="l00213"></a>00213 <span class="comment">  int TT, tautau;</span>
<a name="l00214"></a>00214 <span class="comment"></span>
<a name="l00215"></a>00215 <span class="comment">  TT = X13-&gt;T * X24-&gt;T;</span>
<a name="l00216"></a>00216 <span class="comment">  tautau = ((1-G1-&gt;xi*G3-&gt;xi)*(1-G2-&gt;xi*G4-&gt;xi))/4+</span>
<a name="l00217"></a>00217 <span class="comment">    (G1-&gt;xi*G4-&gt;xi+G2-&gt;xi*G3-&gt;xi)/2; </span>
<a name="l00218"></a>00218 <span class="comment"></span>
<a name="l00219"></a>00219 <span class="comment">  if (!TT &amp;&amp; !tautau) return;</span>
<a name="l00220"></a>00220 <span class="comment"></span>
<a name="l00221"></a>00221 <span class="comment">  complex double SS, sigsig;</span>
<a name="l00222"></a>00222 <span class="comment">  complex double RR;</span>
<a name="l00223"></a>00223 <span class="comment">  </span>
<a name="l00224"></a>00224 <span class="comment">  SS = X13-&gt;S * X24-&gt;S; </span>
<a name="l00225"></a>00225 <span class="comment">  sigsig = cvec3mult(X13-&gt;sig, X24-&gt;sig);</span>
<a name="l00226"></a>00226 <span class="comment"></span>
<a name="l00227"></a>00227 <span class="comment">  RR = X13-&gt;R * X24-&gt;R;</span>
<a name="l00228"></a>00228 <span class="comment"></span>
<a name="l00229"></a>00229 <span class="comment">  complex double alphar, rho[3];</span>
<a name="l00230"></a>00230 <span class="comment">  int i;</span>
<a name="l00231"></a>00231 <span class="comment"></span>
<a name="l00232"></a>00232 <span class="comment">  alphar = X13-&gt;alpha + X24-&gt;alpha;</span>
<a name="l00233"></a>00233 <span class="comment">  for (i=0; i&lt;3; i++)</span>
<a name="l00234"></a>00234 <span class="comment">    rho[i] = X13-&gt;rho[i]-X24-&gt;rho[i];</span>
<a name="l00235"></a>00235 <span class="comment"></span>
<a name="l00236"></a>00236 <span class="comment">  initializeangulargrid(par-&gt;nalpha, par-&gt;ncosb);</span>
<a name="l00237"></a>00237 <span class="comment">  </span>
<a name="l00238"></a>00238 <span class="comment">  int ir, ialpha, icosb;</span>
<a name="l00239"></a>00239 <span class="comment">  double r, alpha, beta, x[3], weight;</span>
<a name="l00240"></a>00240 <span class="comment">  complex double xmrho[3], xmrho2, dens;</span>
<a name="l00241"></a>00241 <span class="comment"></span>
<a name="l00242"></a>00242 <span class="comment">  for (ir=0; ir&lt;npoints; ir++) {</span>
<a name="l00243"></a>00243 <span class="comment">    r = rmax* ir/(npoints-1);</span>
<a name="l00244"></a>00244 <span class="comment"></span>
<a name="l00245"></a>00245 <span class="comment">    for (ialpha=0; ialpha&lt;nalpha; ialpha++)</span>
<a name="l00246"></a>00246 <span class="comment">      for (icosb=0; icosb&lt;ncosb; icosb++) {</span>
<a name="l00247"></a>00247 <span class="comment">        alpha = alphal[ialpha];</span>
<a name="l00248"></a>00248 <span class="comment">        beta = acos(cosbl[icosb]);</span>
<a name="l00249"></a>00249 <span class="comment">        weight = walphal[ialpha]*wcosbl[icosb];</span>
<a name="l00250"></a>00250 <span class="comment"></span>
<a name="l00251"></a>00251 <span class="comment">        x[0] = r*cos(alpha)*sin(beta);</span>
<a name="l00252"></a>00252 <span class="comment">        x[1] = r*sin(alpha)*sin(beta);</span>
<a name="l00253"></a>00253 <span class="comment">        x[2] = r*cos(beta);</span>
<a name="l00254"></a>00254 <span class="comment"></span>
<a name="l00255"></a>00255 <span class="comment">        for (i=0; i&lt;3; i++)</span>
<a name="l00256"></a>00256 <span class="comment">          xmrho[i] = x[i] - rho[i];</span>
<a name="l00257"></a>00257 <span class="comment">        xmrho2 = cvec3sqr(xmrho);</span>
<a name="l00258"></a>00258 <span class="comment">        </span>
<a name="l00259"></a>00259 <span class="comment">        dens = RR/cpow(2*M_PI*alphar, 1.5)*cexp(-0.5*xmrho2/alphar)* weight;</span>
<a name="l00260"></a>00260 <span class="comment"></span>
<a name="l00261"></a>00261 <span class="comment">        // S,T=0,0</span>
<a name="l00262"></a>00262 <span class="comment">        densr[ir          ] += 0.25*(SS-sigsig)*0.25*(TT-tautau)*dens;</span>
<a name="l00263"></a>00263 <span class="comment">        // S,T=0,1</span>
<a name="l00264"></a>00264 <span class="comment">        densr[ir+1*npoints] += 0.25*(SS-sigsig)*0.25*(3*TT+tautau)*dens;</span>
<a name="l00265"></a>00265 <span class="comment">        // S,T=1,0</span>
<a name="l00266"></a>00266 <span class="comment">        densr[ir+2*npoints] += 0.25*(3*SS+sigsig)*0.25*(TT-tautau)*dens;</span>
<a name="l00267"></a>00267 <span class="comment">        // S,T=1,1</span>
<a name="l00268"></a>00268 <span class="comment">        densr[ir+3*npoints] += 0.25*(3*SS+sigsig)*0.25*(3*TT+tautau)*dens;</span>
<a name="l00269"></a>00269 <span class="comment">      }</span>
<a name="l00270"></a>00270 <span class="comment">  }</span>
<a name="l00271"></a>00271 <span class="comment">}</span>
<a name="l00272"></a>00272 <span class="comment"></span>
<a name="l00273"></a>00273 <span class="comment">*/</span>
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="comment">// analytic integration over angles</span>
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keyword">static</span> <span class="keywordtype">void</span> tb_densr(<a class="code" href="structTBDensRPara.html">TBDensRPara</a>* par,
<a name="l00278"></a>00278                      <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G1, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G2, 
<a name="l00279"></a>00279                      <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G3, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G4, 
<a name="l00280"></a>00280                      <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X13, <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X24, 
<a name="l00281"></a>00281                      complex <span class="keywordtype">double</span>* densr)
<a name="l00282"></a>00282 {
<a name="l00283"></a>00283   <span class="keywordtype">double</span> rmax = par-&gt;<a class="code" href="structTBDensRPara.html#adbf86c3fbdf12333426645958f9b093c">rmax</a>;
<a name="l00284"></a>00284   <span class="keywordtype">int</span> npoints = par-&gt;<a class="code" href="structTBDensRPara.html#ab4db1b883c5654364f62a8339adc5296">npoints</a>;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286   <span class="keywordtype">int</span> TT, tautau;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   TT = X13-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a> * X24-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>;
<a name="l00289"></a>00289   tautau = ((1-G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)*(1-G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>))/4+
<a name="l00290"></a>00290     (G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>+G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)/2; 
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   <span class="keywordflow">if</span> (!TT &amp;&amp; !tautau) <span class="keywordflow">return</span>;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294   complex <span class="keywordtype">double</span> SS, sigsig;
<a name="l00295"></a>00295   complex <span class="keywordtype">double</span> RR;
<a name="l00296"></a>00296   
<a name="l00297"></a>00297   SS = X13-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a> * X24-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a>; 
<a name="l00298"></a>00298   sigsig = cvec3mult(X13-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>, X24-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   RR = X13-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a> * X24-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a>;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302   complex <span class="keywordtype">double</span> alphar, <a class="code" href="ProjectedDensityMatrixHO_8c.html#a103956ea26133e0b04f20e47636c5f03">rho</a>[3], rho2, beta[3], beta2;
<a name="l00303"></a>00303   <span class="keywordtype">int</span> i;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305   alphar = X13-&gt;<a class="code" href="structGaussianAux.html#aeeb4c08409e304f19b787c4d4f0c630f">alpha</a> + X24-&gt;<a class="code" href="structGaussianAux.html#aeeb4c08409e304f19b787c4d4f0c630f">alpha</a>;
<a name="l00306"></a>00306   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00307"></a>00307     rho[i] = X13-&gt;<a class="code" href="structGaussianAux.html#a998591f853ddf3ec650f36db350f342f">rho</a>[i]-X24-&gt;<a class="code" href="structGaussianAux.html#a998591f853ddf3ec650f36db350f342f">rho</a>[i];
<a name="l00308"></a>00308   rho2 = cvec3sqr(rho);
<a name="l00309"></a>00309   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00310"></a>00310     beta[i] = rho[i]/alphar;
<a name="l00311"></a>00311   beta2 = cvec3sqr(beta);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   complex <span class="keywordtype">double</span> dens;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315   <span class="keywordtype">int</span> ir;
<a name="l00316"></a>00316   <span class="keywordtype">double</span> r;
<a name="l00317"></a>00317   <span class="keywordflow">for</span> (ir=0; ir&lt;npoints; ir++) {
<a name="l00318"></a>00318     r = rmax* ir/(npoints-1);
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     dens = RR/cpow(2*M_PI*alphar, 1.5)*cexp(-0.5/alphar*(r*r+rho2))* 
<a name="l00321"></a>00321       4*M_PI*<a class="code" href="sphericalbessel_8c.html#a1c8d81c02554684528fa43eccef50815">cbesseli0</a>(r*csqrt(beta2));
<a name="l00322"></a>00322 
<a name="l00323"></a>00323     <span class="comment">// S,T=0,0</span>
<a name="l00324"></a>00324     densr[ir          ] += 0.25*(SS-sigsig)*0.25*(TT-tautau)*dens;
<a name="l00325"></a>00325     <span class="comment">// S,T=0,1</span>
<a name="l00326"></a>00326     densr[ir+1*npoints] += 0.25*(SS-sigsig)*0.25*(3*TT+tautau)*dens;
<a name="l00327"></a>00327     <span class="comment">// S,T=1,0</span>
<a name="l00328"></a>00328     densr[ir+2*npoints] += 0.25*(3*SS+sigsig)*0.25*(TT-tautau)*dens;
<a name="l00329"></a>00329     <span class="comment">// S,T=1,1</span>
<a name="l00330"></a>00330     densr[ir+3*npoints] += 0.25*(3*SS+sigsig)*0.25*(3*TT+tautau)*dens;
<a name="l00331"></a>00331   }
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="keyword">static</span> <span class="keywordtype">void</span> tb_densq(<a class="code" href="structTBDensQPara.html">TBDensQPara</a>* par,
<a name="l00336"></a>00336                      <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G1, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G2, 
<a name="l00337"></a>00337                      <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G3, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G4, 
<a name="l00338"></a>00338                      <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X13, <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X24, 
<a name="l00339"></a>00339                      complex <span class="keywordtype">double</span>* densq)
<a name="l00340"></a>00340 {
<a name="l00341"></a>00341   <span class="keywordtype">int</span> npoints = par-&gt;<a class="code" href="structTBDensQPara.html#ac89b3597a5c0adb7021e95e374678502">npoints</a>;
<a name="l00342"></a>00342   <span class="keywordtype">double</span> qmax= par-&gt;<a class="code" href="structTBDensQPara.html#a491a5a6133ad45a4560f0857e197b37b">qmax</a>;
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="keywordtype">int</span> TT, tautau;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   TT = X13-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a> * X24-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>;
<a name="l00347"></a>00347   tautau = ((1-G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)*(1-G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>))/4+
<a name="l00348"></a>00348     (G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>+G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)/2; 
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   <span class="keywordflow">if</span> (!TT &amp;&amp; !tautau) <span class="keywordflow">return</span>;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352   complex <span class="keywordtype">double</span> SS, sigsig;
<a name="l00353"></a>00353   complex <span class="keywordtype">double</span> RR;
<a name="l00354"></a>00354   
<a name="l00355"></a>00355   SS = X13-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a> * X24-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a>; 
<a name="l00356"></a>00356   sigsig = cvec3mult(X13-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>, X24-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>);
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   RR = X13-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a> * X24-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a>;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   complex <span class="keywordtype">double</span> alphaq, pi[3], pi2, beta[3], beta2;
<a name="l00361"></a>00361   <span class="keywordtype">int</span> i;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363   alphaq = 4.0/(X13-&gt;<a class="code" href="structGaussianAux.html#aa73f971f4dcc77e87260c2a176455d38">lambda</a> + X24-&gt;<a class="code" href="structGaussianAux.html#aa73f971f4dcc77e87260c2a176455d38">lambda</a>);
<a name="l00364"></a>00364   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00365"></a>00365     pi[i] = 0.5*(X13-&gt;<a class="code" href="structGaussianAux.html#a585529d0d060c8920c90103acf9bb2c8">pi</a>[i] - X24-&gt;<a class="code" href="structGaussianAux.html#a585529d0d060c8920c90103acf9bb2c8">pi</a>[i]);
<a name="l00366"></a>00366   pi2 = cvec3sqr(pi);
<a name="l00367"></a>00367   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00368"></a>00368     beta[i] = alphaq*pi[i];
<a name="l00369"></a>00369   beta2 = cvec3sqr(beta);
<a name="l00370"></a>00370     
<a name="l00371"></a>00371   complex <span class="keywordtype">double</span> dens;
<a name="l00372"></a>00372   
<a name="l00373"></a>00373   <span class="keywordtype">int</span> iq;
<a name="l00374"></a>00374   <span class="keywordtype">double</span> <a class="code" href="MinimizerDONLP2_8c.html#a116d67c73cdfa395275c96c0151ddcd4">q</a>;
<a name="l00375"></a>00375   <span class="keywordflow">for</span> (iq=0; iq&lt;npoints; iq++) {
<a name="l00376"></a>00376     q = qmax* iq/(npoints-1);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     dens = RR*cpow(alphaq/(2*M_PI), 1.5)*cexp(-0.5*alphaq*(q*q+pi2))*
<a name="l00379"></a>00379       4*M_PI*<a class="code" href="sphericalbessel_8c.html#a1c8d81c02554684528fa43eccef50815">cbesseli0</a>(q*csqrt(beta2));
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     <span class="comment">// S,T=0,0</span>
<a name="l00382"></a>00382     densq[iq          ] += 0.25*(SS-sigsig)*0.25*(TT-tautau)*dens;
<a name="l00383"></a>00383     <span class="comment">// S,T=0,1</span>
<a name="l00384"></a>00384     densq[iq+1*npoints] += 0.25*(SS-sigsig)*0.25*(3*TT+tautau)*dens;
<a name="l00385"></a>00385     <span class="comment">// S,T=1,0</span>
<a name="l00386"></a>00386     densq[iq+2*npoints] += 0.25*(3*SS+sigsig)*0.25*(TT-tautau)*dens;
<a name="l00387"></a>00387     <span class="comment">// S,T=1,1</span>
<a name="l00388"></a>00388     densq[iq+3*npoints] += 0.25*(3*SS+sigsig)*0.25*(3*TT+tautau)*dens;
<a name="l00389"></a>00389   }
<a name="l00390"></a>00390 }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 <span class="comment">// static workspace for clebsch gordans</span>
<a name="l00394"></a>00394 <span class="comment">// cg2[lmax+1][lambdamax+1][lmax+lambdamax+1]</span>
<a name="l00395"></a>00395 
<a name="l00396"></a><a class="code" href="TwoBodyDensity_8c.html#a775877117ba6cdce0bd3ca1e20f5bb05">00396</a> <span class="keywordtype">double</span>* <a class="code" href="TwoBodyDensity_8c.html#a775877117ba6cdce0bd3ca1e20f5bb05">cg2tab</a> = NULL;
<a name="l00397"></a>00397 
<a name="l00398"></a><a class="code" href="TwoBodyDensity_8c.html#afcde0a7620dd5fd9c0cbfbf8d4033b45">00398</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#afcde0a7620dd5fd9c0cbfbf8d4033b45">initcg2</a>(<span class="keywordtype">int</span> lmax, <span class="keywordtype">int</span> lambdamax)
<a name="l00399"></a>00399 {
<a name="l00400"></a>00400   <span class="keywordflow">if</span> (cg2tab) <span class="keywordflow">return</span>;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   cg2tab = malloc((lmax+1)*(lambdamax+1)*(lmax+lambdamax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00403"></a>00403   double (*cg2)[lambdamax+1][lmax+lambdamax+1] = cg2tab;
<a name="l00404"></a>00404   
<a name="l00405"></a>00405   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, lambda, lp;
<a name="l00406"></a>00406   <span class="keywordflow">for</span> (l=0; l&lt;=lmax; l++)
<a name="l00407"></a>00407     <span class="keywordflow">for</span> (lambda=0; lambda&lt;=lambdamax; lambda++)
<a name="l00408"></a>00408       <span class="keywordflow">for</span> (lp=abs(l-lambda); lp&lt;=l+lambda; lp++)
<a name="l00409"></a>00409         cg2[l][lambda][lp] = <a class="code" href="TwoBodyDensity_8c.html#a22f4e97ed7ca9e188dc4e074a1b2e5a7">sqr</a>(<a class="code" href="clebsch_8c.html#a7b75250723cf843449ee508426c81537">clebsch</a>(2*l,2*lp,2*lambda,0,0,0));
<a name="l00410"></a>00410 }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412             
<a name="l00413"></a>00413 <span class="comment">// bug for lambdamax &gt; 0: number of pairs is too large !?</span>
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 <span class="keyword">static</span> <span class="keywordtype">void</span> tb_densrl(<a class="code" href="structTBDensRLPara.html">TBDensRLPara</a>* par,
<a name="l00416"></a>00416                       <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G1, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G2, 
<a name="l00417"></a>00417                       <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G3, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G4, 
<a name="l00418"></a>00418                       <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X13, <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X24, 
<a name="l00419"></a>00419                       complex <span class="keywordtype">double</span>* densrl)
<a name="l00420"></a>00420 {
<a name="l00421"></a>00421   <span class="keywordtype">double</span> rmax= par-&gt;<a class="code" href="structTBDensRLPara.html#ab517a044fc7ba2df43df153e7b2e1ff7">rmax</a>;
<a name="l00422"></a>00422   <span class="keywordtype">int</span> npoints = par-&gt;<a class="code" href="structTBDensRLPara.html#abec1102b0c109f46ca243edd20bc5dd3">npoints</a>;
<a name="l00423"></a>00423   <span class="keywordtype">int</span> lmax = par-&gt;<a class="code" href="structTBDensRLPara.html#a6ad216782130a0d46b727289b50ee860">lmax</a>;
<a name="l00424"></a>00424   <span class="keywordtype">int</span> lambdamax = par-&gt;<a class="code" href="structTBDensRLPara.html#a01c8498024d2506c8d67bc181adb4ecf">lambdamax</a>;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426   <a class="code" href="TwoBodyDensity_8c.html#afcde0a7620dd5fd9c0cbfbf8d4033b45">initcg2</a>(lmax, lambdamax);
<a name="l00427"></a>00427   double (*cg2)[lambdamax+1][lmax+lambdamax+1] = cg2tab;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="keywordtype">int</span> TT, tautau;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431   TT = X13-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a> * X24-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>;
<a name="l00432"></a>00432   tautau = ((1-G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)*(1-G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>))/4+
<a name="l00433"></a>00433     (G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>+G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)/2; 
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   <span class="keywordflow">if</span> (!TT &amp;&amp; !tautau) <span class="keywordflow">return</span>;
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   <span class="keywordtype">double</span> PiT0, PiT1;
<a name="l00438"></a>00438   PiT0 = 0.25*(TT-tautau);
<a name="l00439"></a>00439   PiT1 = 0.25*(3*TT+tautau);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   complex <span class="keywordtype">double</span> SS, sigsig;
<a name="l00442"></a>00442   complex <span class="keywordtype">double</span> PiS0, PiS1;
<a name="l00443"></a>00443   SS = X13-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a> * X24-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a>; 
<a name="l00444"></a>00444   sigsig = cvec3mult(X13-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>, X24-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>);
<a name="l00445"></a>00445   PiS0 = 0.25*(SS-sigsig); 
<a name="l00446"></a>00446   PiS1 = 0.25*(3*SS+sigsig);
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   complex <span class="keywordtype">double</span> RR;
<a name="l00449"></a>00449   RR = X13-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a> * X24-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a>;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451   complex <span class="keywordtype">double</span> alphar, rho[3], rho2, pi[3];
<a name="l00452"></a>00452   <span class="keywordtype">int</span> i;
<a name="l00453"></a>00453 
<a name="l00454"></a>00454   alphar = 1.0/(X13-&gt;<a class="code" href="structGaussianAux.html#aeeb4c08409e304f19b787c4d4f0c630f">alpha</a> + X24-&gt;<a class="code" href="structGaussianAux.html#aeeb4c08409e304f19b787c4d4f0c630f">alpha</a>);
<a name="l00455"></a>00455   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00456"></a>00456     rho[i] = X13-&gt;<a class="code" href="structGaussianAux.html#a998591f853ddf3ec650f36db350f342f">rho</a>[i]-X24-&gt;<a class="code" href="structGaussianAux.html#a998591f853ddf3ec650f36db350f342f">rho</a>[i];
<a name="l00457"></a>00457   rho2 = cvec3sqr(rho);
<a name="l00458"></a>00458   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00459"></a>00459     pi[i] = 0.5*(X13-&gt;<a class="code" href="structGaussianAux.html#a585529d0d060c8920c90103acf9bb2c8">pi</a>[i]-X24-&gt;<a class="code" href="structGaussianAux.html#a585529d0d060c8920c90103acf9bb2c8">pi</a>[i]);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   complex <span class="keywordtype">double</span> betav[3], beta;
<a name="l00462"></a>00462   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00463"></a>00463     betav[i] = alphar*rho[i];
<a name="l00464"></a>00464   beta = csqrt(cvec3sqr(betav));
<a name="l00465"></a>00465 
<a name="l00466"></a>00466   complex <span class="keywordtype">double</span> lambda14, lambda23; 
<a name="l00467"></a>00467   lambda14 = 1.0/(conj(G1-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)+G4-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>);
<a name="l00468"></a>00468   lambda23 = 1.0/(conj(G2-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)+G3-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   complex <span class="keywordtype">double</span> Arp, App;
<a name="l00471"></a>00471   Arp = (conj(G1-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)-G4-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)*lambda14+(conj(G2-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)-G3-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)*lambda23;
<a name="l00472"></a>00472   App = 2.0*(conj(G1-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)*G4-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>*lambda14+conj(G2-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)*G3-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>*lambda23);
<a name="l00473"></a>00473   
<a name="l00474"></a>00474   complex <span class="keywordtype">double</span> Axy;
<a name="l00475"></a>00475   complex <span class="keywordtype">double</span> betaxv[3], betayv[3], betax, betay, betaxy;
<a name="l00476"></a>00476   Axy = -0.25*alphar+0.5/App;
<a name="l00477"></a>00477   <span class="keywordflow">for</span> (i=0; i&lt;3; i++) {
<a name="l00478"></a>00478     betaxv[i] = (0.5*alphar-0.5*Arp/App)*rho[i] - I*pi[i] ;
<a name="l00479"></a>00479     betayv[i] = (0.5*alphar+0.5*Arp/App)*rho[i] + I*pi[i] ;
<a name="l00480"></a>00480   }
<a name="l00481"></a>00481   betax = csqrt(cvec3sqr(betaxv));
<a name="l00482"></a>00482   betay = csqrt(cvec3sqr(betayv));
<a name="l00483"></a>00483   <span class="comment">// if length of vectors is zero set cosine to 1</span>
<a name="l00484"></a>00484   <span class="keywordflow">if</span> (cabs(betax) &lt; 1.E-8 || cabs(betay) &lt; 1.E-8) {
<a name="l00485"></a>00485     betaxy = 1.0;
<a name="l00486"></a>00486   } <span class="keywordflow">else</span> {
<a name="l00487"></a>00487     betaxy = cvec3mult(betaxv,betayv)/(betax*betay);
<a name="l00488"></a>00488   }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490   complex <span class="keywordtype">double</span> dens, densl[lmax+1];
<a name="l00491"></a>00491   complex <span class="keywordtype">double</span> ilx[lmax+lambdamax+1], ily[lmax+lambdamax+1], 
<a name="l00492"></a>00492     ilxy[lambdamax+1], Lpxy[lmax+lambdamax+1];
<a name="l00493"></a>00493 
<a name="l00494"></a>00494   <a class="code" href="legendrep_8c.html#a0a8d17e6aa85eef29a42d2863b0eb5e3">clegendreps</a>(lmax+lambdamax, betaxy, Lpxy);
<a name="l00495"></a>00495 
<a name="l00496"></a>00496   <span class="keywordtype">int</span> ir;
<a name="l00497"></a>00497   <span class="keywordtype">double</span> r;
<a name="l00498"></a>00498   complex <span class="keywordtype">double</span> Cr;
<a name="l00499"></a>00499   <span class="keywordflow">for</span> (ir=0; ir&lt;npoints; ir++) {
<a name="l00500"></a>00500     r = rmax* ir/(npoints-1);
<a name="l00501"></a>00501     
<a name="l00502"></a>00502     <span class="comment">// common factor</span>
<a name="l00503"></a>00503     Cr = RR*cpow(alphar/(2*M_PI), 1.5)*cexp(-0.5*alphar*(r*r+rho2));
<a name="l00504"></a>00504 
<a name="l00505"></a>00505     <span class="comment">// total density </span>
<a name="l00506"></a>00506     dens = Cr* 4*M_PI*<a class="code" href="sphericalbessel_8c.html#a1c8d81c02554684528fa43eccef50815">cbesseli0</a>(beta*r);
<a name="l00507"></a>00507 
<a name="l00508"></a>00508     <span class="comment">// densities in individual channels</span>
<a name="l00509"></a>00509     <a class="code" href="sphericalbessel_8c.html#a13c7167cf71810ac00cdf26c7e3076ce">cbesselis</a>(lmax+lambdamax, betax*r, ilx);
<a name="l00510"></a>00510     <a class="code" href="sphericalbessel_8c.html#a13c7167cf71810ac00cdf26c7e3076ce">cbesselis</a>(lmax+lambdamax, betay*r, ily);
<a name="l00511"></a>00511     <a class="code" href="sphericalbessel_8c.html#a13c7167cf71810ac00cdf26c7e3076ce">cbesselis</a>(lambdamax, Axy*<a class="code" href="TwoBodyDensity_8c.html#a22f4e97ed7ca9e188dc4e074a1b2e5a7">sqr</a>(r), ilxy);
<a name="l00512"></a>00512 
<a name="l00513"></a>00513     <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, lambda, lp;
<a name="l00514"></a>00514     <span class="keywordflow">for</span> (l=0; l&lt;=lmax; l++) {
<a name="l00515"></a>00515       densl[l] = 0.0;
<a name="l00516"></a>00516       <span class="keywordflow">for</span> (lambda=0; lambda&lt;=lambdamax; lambda++)
<a name="l00517"></a>00517         <span class="keywordflow">for</span> (lp=abs(l-lambda); lp&lt;=l+lambda; lp++)
<a name="l00518"></a>00518           densl[l] += Cr* 4*M_PI* (2*l+1)*(2*lp+1)*
<a name="l00519"></a>00519             ilx[lp]*ily[lp]*Lpxy[lp]*
<a name="l00520"></a>00520             ilxy[lambda]*cg2[l][lambda][lp];
<a name="l00521"></a>00521     }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523     densrl[ir          ] += PiS0*PiT0*dens;
<a name="l00524"></a>00524     densrl[ir+1*npoints] += PiS0*PiT1*dens;
<a name="l00525"></a>00525     densrl[ir+2*npoints] += PiS1*PiT0*dens;
<a name="l00526"></a>00526     densrl[ir+3*npoints] += PiS1*PiT1*dens;
<a name="l00527"></a>00527 
<a name="l00528"></a>00528     <span class="keywordtype">int</span> idx=4;
<a name="l00529"></a>00529     <span class="keywordflow">for</span> (l=0; l&lt;=lmax; l++)
<a name="l00530"></a>00530       <span class="keywordflow">if</span> (l%2) { <span class="comment">// odd channels</span>
<a name="l00531"></a>00531         densrl[ir+idx*npoints] += PiS0*PiT0*densl[l]; idx++;
<a name="l00532"></a>00532         densrl[ir+idx*npoints] += PiS1*PiT1*densl[l]; idx++;
<a name="l00533"></a>00533       } <span class="keywordflow">else</span> { <span class="comment">// even channels</span>
<a name="l00534"></a>00534         densrl[ir+idx*npoints] += PiS0*PiT1*densl[l]; idx++;
<a name="l00535"></a>00535         densrl[ir+idx*npoints] += PiS1*PiT0*densl[l]; idx++;
<a name="l00536"></a>00536       }
<a name="l00537"></a>00537   }
<a name="l00538"></a>00538 }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 <span class="keyword">static</span> <span class="keywordtype">void</span> tb_densql(<a class="code" href="structTBDensQLPara.html">TBDensQLPara</a>* par,
<a name="l00542"></a>00542                       <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G1, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G2, 
<a name="l00543"></a>00543                       <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G3, <span class="keyword">const</span> <a class="code" href="structGaussian.html">Gaussian</a>* G4, 
<a name="l00544"></a>00544                       <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X13, <span class="keyword">const</span> <a class="code" href="structGaussianAux.html">GaussianAux</a>* X24, 
<a name="l00545"></a>00545                       complex <span class="keywordtype">double</span>* densql)
<a name="l00546"></a>00546 {
<a name="l00547"></a>00547   <span class="keywordtype">double</span> qmax= par-&gt;<a class="code" href="structTBDensQLPara.html#a5ba3edae0e24cea318b7f762a3b91ebc">qmax</a>;
<a name="l00548"></a>00548   <span class="keywordtype">int</span> npoints = par-&gt;<a class="code" href="structTBDensQLPara.html#aa87408498a7059e4ce88f1e7628da010">npoints</a>;
<a name="l00549"></a>00549   <span class="keywordtype">int</span> lmax = par-&gt;<a class="code" href="structTBDensQLPara.html#aaae4a3cc890015e6371f445dc5503325">lmax</a>;
<a name="l00550"></a>00550   <span class="keywordtype">int</span> lambdamax = par-&gt;<a class="code" href="structTBDensQLPara.html#a2db67d2e19e6d737fc387c3fb1ad98a6">lambdamax</a>;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552   <a class="code" href="TwoBodyDensity_8c.html#afcde0a7620dd5fd9c0cbfbf8d4033b45">initcg2</a>(lmax, lambdamax);
<a name="l00553"></a>00553   double (*cg2)[lambdamax+1][lmax+lambdamax+1] = cg2tab;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555   <span class="keywordtype">int</span> TT, tautau;
<a name="l00556"></a>00556 
<a name="l00557"></a>00557   TT = X13-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a> * X24-&gt;<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>;
<a name="l00558"></a>00558   tautau = ((1-G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)*(1-G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>))/4+
<a name="l00559"></a>00559     (G1-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G4-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>+G2-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>*G3-&gt;<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>)/2; 
<a name="l00560"></a>00560 
<a name="l00561"></a>00561   <span class="keywordflow">if</span> (!TT &amp;&amp; !tautau) <span class="keywordflow">return</span>;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563   <span class="keywordtype">double</span> PiT0, PiT1;
<a name="l00564"></a>00564   PiT0 = 0.25*(TT-tautau);
<a name="l00565"></a>00565   PiT1 = 0.25*(3*TT+tautau);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   complex <span class="keywordtype">double</span> SS, sigsig;
<a name="l00568"></a>00568   complex <span class="keywordtype">double</span> PiS0, PiS1;
<a name="l00569"></a>00569   SS = X13-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a> * X24-&gt;<a class="code" href="structGaussianAux.html#acdf963c30e9af9698fd7b65284837a45">S</a>; 
<a name="l00570"></a>00570   sigsig = cvec3mult(X13-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>, X24-&gt;<a class="code" href="structGaussianAux.html#aa236d8853a000ffeac8fac574d0d708a">sig</a>);
<a name="l00571"></a>00571   PiS0 = 0.25*(SS-sigsig); 
<a name="l00572"></a>00572   PiS1 = 0.25*(3*SS+sigsig);
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   complex <span class="keywordtype">double</span> RR;
<a name="l00575"></a>00575   RR = X13-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a> * X24-&gt;<a class="code" href="structGaussianAux.html#ad31fb243c618c7efa724b2370ffe9da2">R</a>;
<a name="l00576"></a>00576 
<a name="l00577"></a>00577   complex <span class="keywordtype">double</span> alphaq, rho[3], pi[3], pi2;
<a name="l00578"></a>00578   <span class="keywordtype">int</span> i;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580   alphaq = 4.0/(X13-&gt;<a class="code" href="structGaussianAux.html#aa73f971f4dcc77e87260c2a176455d38">lambda</a>+X24-&gt;<a class="code" href="structGaussianAux.html#aa73f971f4dcc77e87260c2a176455d38">lambda</a>);
<a name="l00581"></a>00581   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00582"></a>00582     rho[i] = X13-&gt;<a class="code" href="structGaussianAux.html#a998591f853ddf3ec650f36db350f342f">rho</a>[i]-X24-&gt;<a class="code" href="structGaussianAux.html#a998591f853ddf3ec650f36db350f342f">rho</a>[i];
<a name="l00583"></a>00583   for (i=0; i&lt;3; i++)
<a name="l00584"></a>00584     pi[i] = 0.5*(X13-&gt;<a class="code" href="structGaussianAux.html#a585529d0d060c8920c90103acf9bb2c8">pi</a>[i]-X24-&gt;<a class="code" href="structGaussianAux.html#a585529d0d060c8920c90103acf9bb2c8">pi</a>[i]);
<a name="l00585"></a>00585   pi2 = cvec3sqr(pi);
<a name="l00586"></a>00586 
<a name="l00587"></a>00587   complex <span class="keywordtype">double</span> betav[3], beta;
<a name="l00588"></a>00588   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00589"></a>00589     betav[i] = alphaq*pi[i];
<a name="l00590"></a>00590   beta = csqrt(cvec3sqr(betav));
<a name="l00591"></a>00591 
<a name="l00592"></a>00592   complex <span class="keywordtype">double</span> lambda14, lambda23; 
<a name="l00593"></a>00593   lambda14 = 1.0/(conj(G1-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)+G4-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>);
<a name="l00594"></a>00594   lambda23 = 1.0/(conj(G2-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)+G3-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>);
<a name="l00595"></a>00595 
<a name="l00596"></a>00596   complex <span class="keywordtype">double</span> Arr, Arp;
<a name="l00597"></a>00597   Arr = 0.5*(lambda14+lambda23);
<a name="l00598"></a>00598   Arp = (conj(G1-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)-G4-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)*lambda14+(conj(G2-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)-G3-&gt;<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>)*lambda23;
<a name="l00599"></a>00599   
<a name="l00600"></a>00600   complex <span class="keywordtype">double</span> Axy;
<a name="l00601"></a>00601   complex <span class="keywordtype">double</span> betaxv[3], betayv[3], betax, betay, betaxy;
<a name="l00602"></a>00602   Axy = -0.25*alphaq+0.5/Arr;
<a name="l00603"></a>00603   <span class="keywordflow">for</span> (i=0; i&lt;3; i++) {
<a name="l00604"></a>00604     betaxv[i] = (0.5*alphaq+0.5*Arp/Arr)*pi[i] + I*rho[i] ;
<a name="l00605"></a>00605     betayv[i] = (0.5*alphaq-0.5*Arp/Arr)*pi[i] - I*rho[i] ;
<a name="l00606"></a>00606   }
<a name="l00607"></a>00607   betax = csqrt(cvec3sqr(betaxv));
<a name="l00608"></a>00608   betay = csqrt(cvec3sqr(betayv));
<a name="l00609"></a>00609   <span class="comment">// if length of vectors is zero set cosine to 1</span>
<a name="l00610"></a>00610   <span class="keywordflow">if</span> (cabs(betax) &lt; 1.E-8 || cabs(betay) &lt; 1.E-8) {
<a name="l00611"></a>00611     betaxy = 1.0;
<a name="l00612"></a>00612   } <span class="keywordflow">else</span> {
<a name="l00613"></a>00613     betaxy = cvec3mult(betaxv,betayv)/(betax*betay);
<a name="l00614"></a>00614   }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616   complex <span class="keywordtype">double</span> dens, densl[lmax+1];
<a name="l00617"></a>00617   complex <span class="keywordtype">double</span> ilx[lmax+lambdamax+1], ily[lmax+lambdamax+1], 
<a name="l00618"></a>00618     ilxy[lambdamax+1], Lpxy[lmax+lambdamax+1];
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <a class="code" href="legendrep_8c.html#a0a8d17e6aa85eef29a42d2863b0eb5e3">clegendreps</a>(lmax+lambdamax, betaxy, Lpxy);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622   <span class="keywordtype">int</span> iq;
<a name="l00623"></a>00623   <span class="keywordtype">double</span> q;
<a name="l00624"></a>00624   complex <span class="keywordtype">double</span> Cq;
<a name="l00625"></a>00625   <span class="keywordflow">for</span> (iq=0; iq&lt;npoints; iq++) {
<a name="l00626"></a>00626     q = qmax* iq/(npoints-1);
<a name="l00627"></a>00627     
<a name="l00628"></a>00628     <span class="comment">// common factor</span>
<a name="l00629"></a>00629     Cq = RR*cpow(alphaq/(2*M_PI), 1.5)*cexp(-0.5*alphaq*(q*q+pi2));
<a name="l00630"></a>00630 
<a name="l00631"></a>00631     <span class="comment">// total density </span>
<a name="l00632"></a>00632     dens = Cq* 4*M_PI*<a class="code" href="sphericalbessel_8c.html#a1c8d81c02554684528fa43eccef50815">cbesseli0</a>(beta*q);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <span class="comment">// densities in individual channels</span>
<a name="l00635"></a>00635     <a class="code" href="sphericalbessel_8c.html#a13c7167cf71810ac00cdf26c7e3076ce">cbesselis</a>(lmax+lambdamax, betax*q, ilx);
<a name="l00636"></a>00636     <a class="code" href="sphericalbessel_8c.html#a13c7167cf71810ac00cdf26c7e3076ce">cbesselis</a>(lmax+lambdamax, betay*q, ily);
<a name="l00637"></a>00637     <a class="code" href="sphericalbessel_8c.html#a13c7167cf71810ac00cdf26c7e3076ce">cbesselis</a>(lambdamax, Axy*<a class="code" href="TwoBodyDensity_8c.html#a22f4e97ed7ca9e188dc4e074a1b2e5a7">sqr</a>(q), ilxy);
<a name="l00638"></a>00638    
<a name="l00639"></a>00639     <span class="keywordtype">int</span> l, lambda, lp;
<a name="l00640"></a>00640     <span class="keywordflow">for</span> (l=0; l&lt;=lmax; l++) {
<a name="l00641"></a>00641       densl[l] = 0.0;
<a name="l00642"></a>00642       <span class="keywordflow">for</span> (lambda=0; lambda&lt;=lambdamax; lambda++)
<a name="l00643"></a>00643         <span class="keywordflow">for</span> (lp=abs(l-lambda); lp&lt;=l+lambda; lp++)
<a name="l00644"></a>00644           densl[l] += Cq* 4*M_PI* (2*l+1)*(2*lp+1)*
<a name="l00645"></a>00645             ilx[lp]*ily[lp]*Lpxy[lp]*
<a name="l00646"></a>00646             ilxy[lambda]*cg2[l][lambda][lp];
<a name="l00647"></a>00647     }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     densql[iq          ] += PiS0*PiT0*dens;
<a name="l00650"></a>00650     densql[iq+1*npoints] += PiS0*PiT1*dens;
<a name="l00651"></a>00651     densql[iq+2*npoints] += PiS1*PiT0*dens;
<a name="l00652"></a>00652     densql[iq+3*npoints] += PiS1*PiT1*dens;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654     <span class="keywordtype">int</span> idx=4;
<a name="l00655"></a>00655     <span class="keywordflow">for</span> (l=0; l&lt;=lmax; l++)
<a name="l00656"></a>00656       <span class="keywordflow">if</span> (l%2) { <span class="comment">// odd channels</span>
<a name="l00657"></a>00657         densql[iq+idx*npoints] += PiS0*PiT0*densl[l]; idx++;
<a name="l00658"></a>00658         densql[iq+idx*npoints] += PiS1*PiT1*densl[l]; idx++;
<a name="l00659"></a>00659       } <span class="keywordflow">else</span> { <span class="comment">// even channels</span>
<a name="l00660"></a>00660         densql[iq+idx*npoints] += PiS0*PiT1*densl[l]; idx++;
<a name="l00661"></a>00661         densql[iq+idx*npoints] += PiS1*PiT0*densl[l]; idx++;
<a name="l00662"></a>00662       }
<a name="l00663"></a>00663   }
<a name="l00664"></a>00664 }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666 
<a name="l00667"></a><a class="code" href="TwoBodyDensity_8h.html#a02c4ef8b0b3da04528cc76a006f397df">00667</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#a02c4ef8b0b3da04528cc76a006f397df">calcPairs</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>, <span class="keywordtype">double</span> pairs[4])
<a name="l00668"></a>00668 {
<a name="l00669"></a>00669   <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a> op_tb_pairs = {<a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>: 4, opt: 0, par: NULL, me: tb_pairs};
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <a class="code" href="SlaterDet_8c.html#a975c7ab0a35f0e9888d4d7410d019cf4">calcSlaterDetTBME</a>(Q, X, &amp;op_tb_pairs, pairs);
<a name="l00672"></a>00672 }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 
<a name="l00675"></a><a class="code" href="TwoBodyDensity_8h.html#a8b69809dffc224716ce5c4f84c73763f">00675</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#a8b69809dffc224716ce5c4f84c73763f">calcPairsod</a>(<span class="keywordtype">void</span>* Par,
<a name="l00676"></a>00676                  <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00677"></a>00677                  <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>, complex <span class="keywordtype">double</span> pairs[4])
<a name="l00678"></a>00678 {
<a name="l00679"></a>00679   <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a> op_tb_pairs = {<a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>: 4, opt: 0, par: NULL, me: tb_pairs};
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <a class="code" href="SlaterDet_8c.html#a302d3cb2ba683707773a9a01e6c0f594">calcSlaterDetTBMEod</a>(Q, Qp, X, &amp;op_tb_pairs, pairs);
<a name="l00682"></a>00682 }
<a name="l00683"></a>00683 
<a name="l00684"></a>00684 
<a name="l00685"></a><a class="code" href="TwoBodyDensity_8h.html#a401dcbc4a10c81410909d36d9790be0a">00685</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#a396f4a32a0b49619ad85d06c49b466f9">writeprojectedPairs</a>(FILE* fp, <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, 
<a name="l00686"></a>00686                          <span class="keyword">const</span> complex <span class="keywordtype">double</span> (**pairsexp)[4],
<a name="l00687"></a>00687                          <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E)
<a name="l00688"></a>00688 {
<a name="l00689"></a>00689   <span class="keywordtype">int</span> odd=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00690"></a>00690   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   <span class="keywordtype">int</span> p,<a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>,i;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   <span class="keywordtype">char</span> prefix[8];
<a name="l00695"></a>00695 
<a name="l00696"></a>00696   <span class="keywordtype">int</span>* idx;
<a name="l00697"></a>00697   <span class="keywordtype">int</span> ngood;
<a name="l00698"></a>00698   complex <span class="keywordtype">double</span> *norm, *H;
<a name="l00699"></a>00699   complex double (*pairs)[4];
<a name="l00700"></a>00700   
<a name="l00701"></a>00701 
<a name="l00702"></a>00702   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00703"></a>00703     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00704"></a>00704       
<a name="l00705"></a>00705       ngood = E-&gt;<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[idxpij(jmax,p,j)];
<a name="l00706"></a>00706 
<a name="l00707"></a>00707       <span class="keywordflow">if</span> (ngood) {
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         <span class="keywordflow">if</span>(odd) sprintf(prefix, <span class="stringliteral">&quot;[%d/2%c]&quot;</span>, j, p ? <span class="charliteral">&#39;-&#39;</span> : <span class="charliteral">&#39;+&#39;</span>); 
<a name="l00710"></a>00710         <span class="keywordflow">else</span>    sprintf(prefix, <span class="stringliteral">&quot;[%d%c]&quot;</span>, j/2, p ? <span class="charliteral">&#39;-&#39;</span> : <span class="charliteral">&#39;+&#39;</span>); 
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         idx = E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[idxpij(jmax,p,j)];
<a name="l00713"></a>00713         norm = E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[idxpij(jmax,p,j)];
<a name="l00714"></a>00714         H = E-&gt;<a class="code" href="structEigenstates.html#ade09c5713d0d08f69ed61126f1c8d075" title="energy eigenvalues">v</a>[idxpij(jmax,p,j)];
<a name="l00715"></a>00715  
<a name="l00716"></a>00716         pairs = pairsexp[idxpij(jmax,p,j)];
<a name="l00717"></a>00717 
<a name="l00718"></a>00718         fprintf(fp, <span class="stringliteral">&quot;\n%s N           = &quot;</span>, prefix); 
<a name="l00719"></a>00719         <span class="keywordflow">for</span> (i=0; i&lt;ngood; i++) 
<a name="l00720"></a>00720           fprintf(fp, <span class="stringliteral">&quot;   %8.5f&quot;</span>, creal(norm[idx[i]]));
<a name="l00721"></a>00721         fprintf(fp, <span class="stringliteral">&quot;\n%s H           = &quot;</span>, prefix); 
<a name="l00722"></a>00722         <span class="keywordflow">for</span> (i=0; i&lt;ngood; i++) 
<a name="l00723"></a>00723           fprintf(fp, <span class="stringliteral">&quot;   %8.3f&quot;</span>, <a class="code" href="physics_8c.html#ac84f9a1ea91a60ec41b71eb31f90eb4c" title="hbarc [MeV fm]">hbc</a>*creal(H[idx[i]]));
<a name="l00724"></a>00724         fprintf(fp, <span class="stringliteral">&quot;\n%s (S,T)=(0,0) = &quot;</span>, prefix); 
<a name="l00725"></a>00725         <span class="keywordflow">for</span> (i=0; i&lt;ngood; i++) 
<a name="l00726"></a>00726           fprintf(fp, <span class="stringliteral">&quot;   %8.3f&quot;</span>, creal(pairs[idx[i]][0]/norm[idx[i]]));
<a name="l00727"></a>00727         fprintf(fp, <span class="stringliteral">&quot;\n%s (S,T)=(0,1) = &quot;</span>, prefix); 
<a name="l00728"></a>00728         <span class="keywordflow">for</span> (i=0; i&lt;ngood; i++) 
<a name="l00729"></a>00729           fprintf(fp, <span class="stringliteral">&quot;   %8.3f&quot;</span>, creal(pairs[idx[i]][1]/norm[idx[i]]));
<a name="l00730"></a>00730         fprintf(fp, <span class="stringliteral">&quot;\n%s (S,T)=(1,0) = &quot;</span>, prefix); 
<a name="l00731"></a>00731         <span class="keywordflow">for</span> (i=0; i&lt;ngood; i++) 
<a name="l00732"></a>00732           fprintf(fp, <span class="stringliteral">&quot;   %8.3f&quot;</span>, creal(pairs[idx[i]][2]/norm[idx[i]]));
<a name="l00733"></a>00733         fprintf(fp, <span class="stringliteral">&quot;\n%s (S,T)=(1,1) = &quot;</span>, prefix); 
<a name="l00734"></a>00734         <span class="keywordflow">for</span> (i=0; i&lt;ngood; i++) 
<a name="l00735"></a>00735           fprintf(fp, <span class="stringliteral">&quot;   %8.3f&quot;</span>, creal(pairs[idx[i]][3]/norm[idx[i]]));
<a name="l00736"></a>00736 
<a name="l00737"></a>00737         fprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);        
<a name="l00738"></a>00738       }
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740 }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742 
<a name="l00743"></a><a class="code" href="TwoBodyDensity_8h.html#a283088360b53bc96310aba7f3a13cb0d">00743</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#a283088360b53bc96310aba7f3a13cb0d">calcTBDensRod</a>(<a class="code" href="structTBDensRPara.html">TBDensRPara</a>* par,
<a name="l00744"></a>00744                    <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00745"></a>00745                    <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>, complex <span class="keywordtype">double</span>* densr)
<a name="l00746"></a>00746 {
<a name="l00747"></a>00747   <span class="keywordtype">int</span> npoints=par-&gt;<a class="code" href="structTBDensRPara.html#ab4db1b883c5654364f62a8339adc5296">npoints</a>;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a> op_tb_densr = {<a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>: 4*npoints, opt: 0, par: par, me: tb_densr};
<a name="l00750"></a>00750 
<a name="l00751"></a>00751   <a class="code" href="SlaterDet_8c.html#a302d3cb2ba683707773a9a01e6c0f594">calcSlaterDetTBMEod</a>(Q, Qp, X, &amp;op_tb_densr, densr);
<a name="l00752"></a>00752 }
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 
<a name="l00755"></a><a class="code" href="TwoBodyDensity_8h.html#ad60dfb0eccd5728cc190e47faec9e987">00755</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#ad60dfb0eccd5728cc190e47faec9e987">writeTBDensR</a>(FILE* fp,
<a name="l00756"></a>00756                   <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* P,
<a name="l00757"></a>00757                   <span class="keyword">const</span> <a class="code" href="structTBDensRPara.html">TBDensRPara</a>* p,
<a name="l00758"></a>00758                   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <span class="keywordtype">int</span> pi, <span class="keywordtype">int</span> a,
<a name="l00759"></a>00759                   <span class="keywordtype">void</span>* tbdensme,
<a name="l00760"></a>00760                   <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E)
<a name="l00761"></a>00761 {
<a name="l00762"></a>00762   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00763"></a>00763   <span class="keywordtype">int</span> ipj = idxpij(jmax,pi,j);
<a name="l00764"></a>00764   <span class="keywordtype">int</span> npoints = p-&gt;<a class="code" href="structTBDensRPara.html#ab4db1b883c5654364f62a8339adc5296">npoints</a>;
<a name="l00765"></a>00765   <span class="keywordtype">double</span> rmax = p-&gt;<a class="code" href="structTBDensRPara.html#adbf86c3fbdf12333426645958f9b093c">rmax</a>;
<a name="l00766"></a>00766   <span class="keywordtype">int</span> idx = E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][a];
<a name="l00767"></a>00767   complex <span class="keywordtype">double</span> norm = E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][idx];
<a name="l00768"></a>00768   complex double (**densme)[4*npoints] = tbdensme;
<a name="l00769"></a>00769   complex double (*dens)[npoints] = densme[ipj][idx];
<a name="l00770"></a>00770   <span class="keywordtype">int</span> i;
<a name="l00771"></a>00771   <span class="keywordtype">double</span> r, d00, d01, d10, d11;
<a name="l00772"></a>00772 
<a name="l00773"></a>00773   <span class="keywordflow">for</span> (i=0; i&lt;npoints; i++) {
<a name="l00774"></a>00774     r = rmax*i/(npoints-1);
<a name="l00775"></a>00775     d00 = dens[0][i]/norm;
<a name="l00776"></a>00776     d01 = dens[1][i]/norm;
<a name="l00777"></a>00777     d10 = dens[2][i]/norm;
<a name="l00778"></a>00778     d11 = dens[3][i]/norm;
<a name="l00779"></a>00779 
<a name="l00780"></a>00780     fprintf(fp, <span class="stringliteral">&quot;%6.3f\t%13.8g\t%13.8g\t%13.8g\t%13.8g\n&quot;</span>,
<a name="l00781"></a>00781             r, d00, d01, d10, d11);
<a name="l00782"></a>00782   }
<a name="l00783"></a>00783 }
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 
<a name="l00786"></a><a class="code" href="TwoBodyDensity_8h.html#af503e20cc06e6f282df7a09936823009">00786</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#af503e20cc06e6f282df7a09936823009">calcTBDensQod</a>(<a class="code" href="structTBDensQPara.html">TBDensQPara</a>* par,
<a name="l00787"></a>00787                    <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00788"></a>00788                    <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>, complex <span class="keywordtype">double</span>* densq)
<a name="l00789"></a>00789 {
<a name="l00790"></a>00790   <span class="keywordtype">int</span> npoints=par-&gt;<a class="code" href="structTBDensQPara.html#ac89b3597a5c0adb7021e95e374678502">npoints</a>;
<a name="l00791"></a>00791 
<a name="l00792"></a>00792   <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a> op_tb_densq = {<a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>: 4*npoints, opt: 0, par: par, me: tb_densq};
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   <a class="code" href="SlaterDet_8c.html#a302d3cb2ba683707773a9a01e6c0f594">calcSlaterDetTBMEod</a>(Q, Qp, X, &amp;op_tb_densq, densq);
<a name="l00795"></a>00795 }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 
<a name="l00798"></a><a class="code" href="TwoBodyDensity_8h.html#aa6b87a415cfda3116c8e1c511dfe12dc">00798</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#aa6b87a415cfda3116c8e1c511dfe12dc">writeTBDensQ</a>(FILE* fp,
<a name="l00799"></a>00799                   <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* P,
<a name="l00800"></a>00800                   <span class="keyword">const</span> <a class="code" href="structTBDensQPara.html">TBDensQPara</a>* p,
<a name="l00801"></a>00801                   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <span class="keywordtype">int</span> pi, <span class="keywordtype">int</span> a,
<a name="l00802"></a>00802                   <span class="keywordtype">void</span>* tbdensme,
<a name="l00803"></a>00803                   <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E)
<a name="l00804"></a>00804 {
<a name="l00805"></a>00805   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00806"></a>00806   <span class="keywordtype">int</span> ipj = idxpij(jmax,pi,j);
<a name="l00807"></a>00807   <span class="keywordtype">int</span> npoints = p-&gt;<a class="code" href="structTBDensQPara.html#ac89b3597a5c0adb7021e95e374678502">npoints</a>;
<a name="l00808"></a>00808   <span class="keywordtype">double</span> qmax = p-&gt;<a class="code" href="structTBDensQPara.html#a491a5a6133ad45a4560f0857e197b37b">qmax</a>;
<a name="l00809"></a>00809   <span class="keywordtype">int</span> idx = E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][a];
<a name="l00810"></a>00810   complex <span class="keywordtype">double</span> norm = E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][idx];
<a name="l00811"></a>00811   complex double (**densme)[4*npoints] = tbdensme;
<a name="l00812"></a>00812   complex double (*dens)[npoints] = densme[ipj][idx];
<a name="l00813"></a>00813   <span class="keywordtype">int</span> i;
<a name="l00814"></a>00814   <span class="keywordtype">double</span> q, d00, d01, d10, d11;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="keywordflow">for</span> (i=0; i&lt;npoints; i++) {
<a name="l00817"></a>00817     q = qmax*i/(npoints-1);
<a name="l00818"></a>00818     d00 = dens[0][i]/norm;
<a name="l00819"></a>00819     d01 = dens[1][i]/norm;
<a name="l00820"></a>00820     d10 = dens[2][i]/norm;
<a name="l00821"></a>00821     d11 = dens[3][i]/norm;
<a name="l00822"></a>00822 
<a name="l00823"></a>00823     fprintf(fp, <span class="stringliteral">&quot;%6.3f\t%13.8g\t%13.8g\t%13.8g\t%13.8g\n&quot;</span>,
<a name="l00824"></a>00824             q, d00, d01, d10, d11);
<a name="l00825"></a>00825   }
<a name="l00826"></a>00826 }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 
<a name="l00829"></a><a class="code" href="TwoBodyDensity_8h.html#a7528d0a1e9cae4eb7e0965f3c8012641">00829</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#a7528d0a1e9cae4eb7e0965f3c8012641">calcTBDensRLod</a>(<a class="code" href="structTBDensRLPara.html">TBDensRLPara</a>* par,
<a name="l00830"></a>00830                     <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00831"></a>00831                     <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>, complex <span class="keywordtype">double</span>* densr)
<a name="l00832"></a>00832 {
<a name="l00833"></a>00833   <span class="keywordtype">int</span> npoints=par-&gt;<a class="code" href="structTBDensRLPara.html#abec1102b0c109f46ca243edd20bc5dd3">npoints</a>;
<a name="l00834"></a>00834   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=2*par-&gt;<a class="code" href="structTBDensRLPara.html#a6ad216782130a0d46b727289b50ee860">lmax</a>+6;
<a name="l00835"></a>00835 
<a name="l00836"></a>00836   <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a> op_tb_densrl = {dim: dim*npoints, opt: 0, par: par, me: tb_densrl};
<a name="l00837"></a>00837 
<a name="l00838"></a>00838   <a class="code" href="SlaterDet_8c.html#a302d3cb2ba683707773a9a01e6c0f594">calcSlaterDetTBMEod</a>(Q, Qp, X, &amp;op_tb_densrl, densr);
<a name="l00839"></a>00839 }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841 
<a name="l00842"></a><a class="code" href="TwoBodyDensity_8h.html#a64acca78ba77d2ba87672044b84ed52e">00842</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#a64acca78ba77d2ba87672044b84ed52e">writeTBDensRL</a>(FILE* fp,
<a name="l00843"></a>00843                    <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* P,
<a name="l00844"></a>00844                    <span class="keyword">const</span> <a class="code" href="structTBDensRLPara.html">TBDensRLPara</a>* p,
<a name="l00845"></a>00845                    <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <span class="keywordtype">int</span> pi, <span class="keywordtype">int</span> a,
<a name="l00846"></a>00846                    <span class="keywordtype">void</span>* tbdensme,
<a name="l00847"></a>00847                    <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E)
<a name="l00848"></a>00848 {
<a name="l00849"></a>00849   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00850"></a>00850   <span class="keywordtype">int</span> ipj = idxpij(jmax,pi,j);
<a name="l00851"></a>00851   <span class="keywordtype">int</span> npoints = p-&gt;<a class="code" href="structTBDensRLPara.html#abec1102b0c109f46ca243edd20bc5dd3">npoints</a>;
<a name="l00852"></a>00852   <span class="keywordtype">int</span> lmax = p-&gt;<a class="code" href="structTBDensRLPara.html#a6ad216782130a0d46b727289b50ee860">lmax</a>;
<a name="l00853"></a>00853   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a> = 2*lmax+6;
<a name="l00854"></a>00854   <span class="keywordtype">double</span> rmax = p-&gt;<a class="code" href="structTBDensRLPara.html#ab517a044fc7ba2df43df153e7b2e1ff7">rmax</a>;
<a name="l00855"></a>00855   <span class="keywordtype">int</span> idx = E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][a];
<a name="l00856"></a>00856   complex <span class="keywordtype">double</span> norm = E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][idx];
<a name="l00857"></a>00857   complex double (**densme)[dim*npoints] = tbdensme;
<a name="l00858"></a>00858   complex double (*dens)[npoints] = densme[ipj][idx];
<a name="l00859"></a>00859   <span class="keywordtype">int</span> i, l, d;
<a name="l00860"></a>00860   <span class="keywordtype">double</span> r, dd;
<a name="l00861"></a>00861 
<a name="l00862"></a>00862   <span class="keywordflow">for</span> (i=0; i&lt;npoints; i++) {
<a name="l00863"></a>00863     r = rmax*i/(npoints-1);
<a name="l00864"></a>00864     fprintf(fp, <span class="stringliteral">&quot;  %6.3f&quot;</span>, r);
<a name="l00865"></a>00865     <span class="keywordflow">for</span> (d=0; d&lt;dim; d++) {
<a name="l00866"></a>00866       dd = dens[d][i]/norm;
<a name="l00867"></a>00867       fprintf(fp, <span class="stringliteral">&quot;\t%13.8g&quot;</span>, dd);
<a name="l00868"></a>00868     }
<a name="l00869"></a>00869     fprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00870"></a>00870   }
<a name="l00871"></a>00871 }
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 
<a name="l00874"></a><a class="code" href="TwoBodyDensity_8h.html#aa7b5e3da6d000b76a4b57b56ca221369">00874</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#aa7b5e3da6d000b76a4b57b56ca221369">calcTBDensQLod</a>(<a class="code" href="structTBDensQLPara.html">TBDensQLPara</a>* par,
<a name="l00875"></a>00875                     <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00876"></a>00876                     <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>, complex <span class="keywordtype">double</span>* densq)
<a name="l00877"></a>00877 {
<a name="l00878"></a>00878   <span class="keywordtype">int</span> npoints=par-&gt;<a class="code" href="structTBDensQLPara.html#aa87408498a7059e4ce88f1e7628da010">npoints</a>;
<a name="l00879"></a>00879   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=2*par-&gt;<a class="code" href="structTBDensQLPara.html#aaae4a3cc890015e6371f445dc5503325">lmax</a>+6;
<a name="l00880"></a>00880 
<a name="l00881"></a>00881   <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a> op_tb_densql = {dim: dim*npoints, opt: 0, par: par, me: tb_densql};
<a name="l00882"></a>00882 
<a name="l00883"></a>00883   <a class="code" href="SlaterDet_8c.html#a302d3cb2ba683707773a9a01e6c0f594">calcSlaterDetTBMEod</a>(Q, Qp, X, &amp;op_tb_densql, densq);
<a name="l00884"></a>00884 }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 
<a name="l00887"></a><a class="code" href="TwoBodyDensity_8h.html#a01c56564c338b12a65eb0d6c7136ef66">00887</a> <span class="keywordtype">void</span> <a class="code" href="TwoBodyDensity_8c.html#a01c56564c338b12a65eb0d6c7136ef66">writeTBDensQL</a>(FILE* fp,
<a name="l00888"></a>00888                    <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* P,
<a name="l00889"></a>00889                    <span class="keyword">const</span> <a class="code" href="structTBDensQLPara.html">TBDensQLPara</a>* p,
<a name="l00890"></a>00890                    <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <span class="keywordtype">int</span> pi, <span class="keywordtype">int</span> a,
<a name="l00891"></a>00891                    <span class="keywordtype">void</span>* tbdensme,
<a name="l00892"></a>00892                    <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E)
<a name="l00893"></a>00893 {
<a name="l00894"></a>00894   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00895"></a>00895   <span class="keywordtype">int</span> ipj = idxpij(jmax,pi,j);
<a name="l00896"></a>00896   <span class="keywordtype">int</span> npoints = p-&gt;<a class="code" href="structTBDensQLPara.html#aa87408498a7059e4ce88f1e7628da010">npoints</a>;
<a name="l00897"></a>00897   <span class="keywordtype">int</span> lmax = p-&gt;<a class="code" href="structTBDensQLPara.html#aaae4a3cc890015e6371f445dc5503325">lmax</a>;
<a name="l00898"></a>00898   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a> = 2*lmax+6;
<a name="l00899"></a>00899   <span class="keywordtype">double</span> qmax = p-&gt;<a class="code" href="structTBDensQLPara.html#a5ba3edae0e24cea318b7f762a3b91ebc">qmax</a>;
<a name="l00900"></a>00900   <span class="keywordtype">int</span> idx = E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][a];
<a name="l00901"></a>00901   complex <span class="keywordtype">double</span> norm = E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][idx];
<a name="l00902"></a>00902   complex double (**densme)[dim*npoints] = tbdensme;
<a name="l00903"></a>00903   complex double (*dens)[npoints] = densme[ipj][idx];
<a name="l00904"></a>00904   <span class="keywordtype">int</span> i, l, d;
<a name="l00905"></a>00905   <span class="keywordtype">double</span> q, dd;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   <span class="keywordflow">for</span> (i=0; i&lt;npoints; i++) {
<a name="l00908"></a>00908     q = qmax*i/(npoints-1);
<a name="l00909"></a>00909     fprintf(fp, <span class="stringliteral">&quot;  %6.3f&quot;</span>, q);
<a name="l00910"></a>00910     <span class="keywordflow">for</span> (d=0; d&lt;dim; d++) {
<a name="l00911"></a>00911       dd = dens[d][i]/norm;
<a name="l00912"></a>00912       fprintf(fp, <span class="stringliteral">&quot;\t%13.8g&quot;</span>, dd);
<a name="l00913"></a>00913     }
<a name="l00914"></a>00914     fprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00915"></a>00915   }
<a name="l00916"></a>00916 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 4 2012 14:05:34 for FMD by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
