<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FMD: fmd/Projection.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>fmd/Projection.c</h1>  </div>
</div>
<div class="contents">
<a href="Projection_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;complex.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;zlib.h&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="SlaterDet_8h.html">SlaterDet.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="Observables_8h.html">Observables.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="CenterofMass_8h.html">CenterofMass.h</a>&quot;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="zcw_8h.html">numerics/zcw.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="wignerd_8h.html">numerics/wignerd.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="clebsch_8h.html">numerics/clebsch.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="cmat_8h.html">numerics/cmat.h</a>&quot;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="physics_8h.html">misc/physics.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="utils_8h.html">misc/utils.h</a>&quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="Projection_8h.html">Projection.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="Symmetry_8h.html">Symmetry.h</a>&quot;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00037"></a><a class="code" href="Projection_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">00037</a> <span class="preprocessor">#define SQR(x) ((x)*(x))</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">// pi=0 : positive parity, pi=1 : negative parity</span>
<a name="l00042"></a><a class="code" href="Projection_8h.html#a5dbae736727dbf5f2d43e571751344d1">00042</a> <span class="keywordtype">char</span>* <a class="code" href="Projection_8c.html#a5dbae736727dbf5f2d43e571751344d1">AngmomtoStr</a>(<span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <span class="keywordtype">int</span> pi)
<a name="l00043"></a>00043 {
<a name="l00044"></a>00044   <span class="keywordtype">char</span>* str = malloc(5*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00045"></a>00045 
<a name="l00046"></a>00046   <span class="keywordflow">if</span> (j%2) 
<a name="l00047"></a>00047     sprintf(str, <span class="stringliteral">&quot;%d2%c&quot;</span>, j, pi ? <span class="charliteral">&#39;-&#39;</span> : <span class="charliteral">&#39;+&#39;</span>);
<a name="l00048"></a>00048   <span class="keywordflow">else</span>
<a name="l00049"></a>00049     sprintf(str, <span class="stringliteral">&quot;%d%c&quot;</span>, j/2, pi ? <span class="charliteral">&#39;-&#39;</span> : <span class="charliteral">&#39;+&#39;</span>);
<a name="l00050"></a>00050 
<a name="l00051"></a>00051   <span class="keywordflow">return</span> str;
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="Projection_8h.html#ac87bb7fb183abeb15fc0454df5babd55">00055</a> <span class="keywordtype">char</span>* <a class="code" href="Projection_8c.html#ac87bb7fb183abeb15fc0454df5babd55">ProjectiontoStr</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>)
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057   <span class="keywordtype">char</span>* suffix = malloc(36*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   <span class="keywordtype">char</span> jmaxsuf[10] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00060"></a>00060   <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a> != <a class="code" href="Projection_8h.html#a6f799b3fb32ecd6a70300d45fe1dfaad">JMAX</a>)
<a name="l00061"></a>00061     sprintf(jmaxsuf, <span class="stringliteral">&quot;jmax-%d-&quot;</span>, P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>-1);
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   <span class="keywordtype">char</span> angsuf[12];
<a name="l00064"></a>00064   <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> == <a class="code" href="Projection_8h.html#a7ff5f2dff38e7639981794c43dc9167ba55bf53a0f8c9f993e6faf4c61fe8ce10">AngNone</a>)
<a name="l00065"></a>00065     sprintf(angsuf, <span class="stringliteral">&quot;ang-none&quot;</span>);
<a name="l00066"></a>00066   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> == <a class="code" href="Projection_8h.html#a7ff5f2dff38e7639981794c43dc9167ba9610a33497e9e2e45e79bc44d5ef918f">AngProd</a>)
<a name="l00067"></a>00067     sprintf(angsuf, <span class="stringliteral">&quot;ang-%d-%d&quot;</span>, P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#abcad02e655573d2040ce82457bbd4cc7">nbeta</a>, 
<a name="l00068"></a>00068             P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a>);
<a name="l00069"></a>00069   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> == <a class="code" href="Projection_8h.html#a7ff5f2dff38e7639981794c43dc9167babf044d8a168c981d4076daf448fae0fc">AngProdA</a>)
<a name="l00070"></a>00070     sprintf(angsuf, <span class="stringliteral">&quot;ang-a%d-%d&quot;</span>, P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#abcad02e655573d2040ce82457bbd4cc7">nbeta</a>,
<a name="l00071"></a>00071             P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a>);
<a name="l00072"></a>00072   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> == <a class="code" href="Projection_8h.html#a7ff5f2dff38e7639981794c43dc9167ba9ecd3bfb04930e544c099805a7b847a6">AngZCW</a>)
<a name="l00073"></a>00073     sprintf(angsuf, <span class="stringliteral">&quot;ang-zcw-%d&quot;</span>, P-&gt;<a class="code" href="structProjection.html#a24b0c733ce6d8f892575554682ef2947">angzcw</a>.<a class="code" href="structangzcwpara.html#a10bdceb86e6bb8dceb15668131ef278b">idx</a>);
<a name="l00074"></a>00074 
<a name="l00075"></a>00075   <span class="keywordtype">char</span> cmsuf[14] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00076"></a>00076   <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> == <a class="code" href="Projection_8h.html#ae4d5251432e1a9e6803c0240cc492e18a8d869da79c82654982e95e61d10a64c4">CMNone</a>)
<a name="l00077"></a>00077     sprintf(cmsuf, <span class="stringliteral">&quot;-cm-none&quot;</span>);
<a name="l00078"></a>00078   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> == <a class="code" href="Projection_8h.html#ae4d5251432e1a9e6803c0240cc492e18a0e967fc9236e1bb9b51ddb4c16fd096e">CMSimple</a>)
<a name="l00079"></a>00079     ;
<a name="l00080"></a>00080   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> == <a class="code" href="Projection_8h.html#ae4d5251432e1a9e6803c0240cc492e18a3ebfa1463485cc7babb95b427075772a">CMProd</a>)
<a name="l00081"></a>00081     sprintf(cmsuf, <span class="stringliteral">&quot;-cm-%d-%d-%d&quot;</span>, P-&gt;<a class="code" href="structProjection.html#a4292128368222758301ad2c030afaac2">cmprod</a>.<a class="code" href="structcmprodpara.html#aceeaab6ba25f876de7f218c9e797cf01">nr</a>, P-&gt;<a class="code" href="structProjection.html#a4292128368222758301ad2c030afaac2">cmprod</a>.<a class="code" href="structcmprodpara.html#af7d2985994407467340336b7dd1b683e">ntheta</a>, 
<a name="l00082"></a>00082             P-&gt;<a class="code" href="structProjection.html#a4292128368222758301ad2c030afaac2">cmprod</a>.<a class="code" href="structcmprodpara.html#a44027ab99975309599367c045379d55d">nphi</a>);
<a name="l00083"></a>00083   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> == <a class="code" href="Projection_8h.html#ae4d5251432e1a9e6803c0240cc492e18a9930f39726023d17ca4e18c2437ebaaf">CMPoly</a>) {
<a name="l00084"></a>00084     <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#a0ecaf4c067190a16871c14bee617164e">npoly</a> == 4) 
<a name="l00085"></a>00085       sprintf(cmsuf, <span class="stringliteral">&quot;-cm-%d-tet&quot;</span>, P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#aadaf15fe4447fa26cf56004270dc7a83">nr</a>);
<a name="l00086"></a>00086     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#a0ecaf4c067190a16871c14bee617164e">npoly</a> == 6) 
<a name="l00087"></a>00087       sprintf(cmsuf, <span class="stringliteral">&quot;-cm-%d-oct&quot;</span>, P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#aadaf15fe4447fa26cf56004270dc7a83">nr</a>);
<a name="l00088"></a>00088     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#a0ecaf4c067190a16871c14bee617164e">npoly</a> == 8) 
<a name="l00089"></a>00089       sprintf(cmsuf, <span class="stringliteral">&quot;-cm-%d-cbe&quot;</span>, P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#aadaf15fe4447fa26cf56004270dc7a83">nr</a>);
<a name="l00090"></a>00090   }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   sprintf(suffix, <span class="stringliteral">&quot;%s%s%s&quot;</span>, jmaxsuf, angsuf, cmsuf);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="keywordflow">return</span> suffix;
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment">// ang-[none|nbeta-nazimuth|zcw-izcw][-cm-nr-[ntheta-nphi|tet|oct|cbe]]</span>
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="comment">// should return error code if could analyze parameters</span>
<a name="l00101"></a>00101 
<a name="l00102"></a><a class="code" href="Projection_8h.html#a8933a4a47f0572f2e2943562cd45aac5">00102</a> <span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a8933a4a47f0572f2e2943562cd45aac5">initProjection</a>(<a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keywordtype">int</span> odd, <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ae51b51057e3a9d5aa3905eed7979dca1">projpar</a>)
<a name="l00103"></a>00103 {
<a name="l00104"></a>00104   P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a> = odd;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a> = JMAX;
<a name="l00107"></a>00107   P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> = AngNone; P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> = CMSimple;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   <span class="keywordtype">char</span> projparcpy[strlen(projpar)];
<a name="l00110"></a>00110   strcpy(projparcpy, projpar);
<a name="l00111"></a>00111   <span class="keywordtype">char</span>* c = projparcpy;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <span class="comment">// different jmax</span>
<a name="l00114"></a>00114   c = strtok(c, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00115"></a>00115   <span class="keywordflow">if</span> (!strncmp(c, <span class="stringliteral">&quot;jmax&quot;</span>, 4)) {
<a name="l00116"></a>00116     c=strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00117"></a>00117     P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a> = atoi(c)+1;
<a name="l00118"></a>00118     c=strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00119"></a>00119   }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="comment">// angular momentum projection</span>
<a name="l00122"></a>00122   <span class="keywordflow">if</span> (!strncmp(c, <span class="stringliteral">&quot;ang&quot;</span>, 3)) {
<a name="l00123"></a>00123     c=strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00124"></a>00124     <span class="keywordflow">if</span> (!strncmp(c, <span class="stringliteral">&quot;none&quot;</span>, 4))
<a name="l00125"></a>00125       P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> = AngNone;
<a name="l00126"></a>00126     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strncmp(c, <span class="stringliteral">&quot;zcw&quot;</span>, 3)) {
<a name="l00127"></a>00127       P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> = AngZCW;
<a name="l00128"></a>00128       c=strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00129"></a>00129       P-&gt;<a class="code" href="structProjection.html#a24b0c733ce6d8f892575554682ef2947">angzcw</a>.<a class="code" href="structangzcwpara.html#a10bdceb86e6bb8dceb15668131ef278b">idx</a> = atoi(c);
<a name="l00130"></a>00130     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strncmp(c, <span class="stringliteral">&quot;a&quot;</span>, 1)) {
<a name="l00131"></a>00131       P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> = AngProdA;
<a name="l00132"></a>00132       P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#abcad02e655573d2040ce82457bbd4cc7">nbeta</a> = atoi(++c);
<a name="l00133"></a>00133       c=strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00134"></a>00134       P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a> = atoi(c);
<a name="l00135"></a>00135     } <span class="keywordflow">else</span> {
<a name="l00136"></a>00136       P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> = AngProd;
<a name="l00137"></a>00137       P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#abcad02e655573d2040ce82457bbd4cc7">nbeta</a> = atoi(c);
<a name="l00138"></a>00138       c=strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00139"></a>00139       P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a> = atoi(c);
<a name="l00140"></a>00140     }
<a name="l00141"></a>00141   }
<a name="l00142"></a>00142     
<a name="l00143"></a>00143   <span class="comment">// center of mass projection</span>
<a name="l00144"></a>00144   c = strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00145"></a>00145   <span class="keywordflow">if</span> (c &amp;&amp; !strncmp(c, <span class="stringliteral">&quot;cm&quot;</span>, 2)) {
<a name="l00146"></a>00146     c=strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00147"></a>00147     <span class="keywordflow">if</span> (!strncmp(c, <span class="stringliteral">&quot;none&quot;</span>, 4)) {
<a name="l00148"></a>00148       P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> = CMNone; }
<a name="l00149"></a>00149     <span class="keywordflow">else</span> {
<a name="l00150"></a>00150       <span class="keywordtype">int</span> <a class="code" href="donlp2_8h.html#a2833bf188e6bf292fa7d61e2dd54d622">nr</a> = atoi(c);
<a name="l00151"></a>00151       c=strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00152"></a>00152       <span class="keywordflow">if</span> (!strncmp(c, <span class="stringliteral">&quot;tet&quot;</span>, 3)) {
<a name="l00153"></a>00153         P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> = CMPoly;
<a name="l00154"></a>00154         P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#aadaf15fe4447fa26cf56004270dc7a83">nr</a> = nr;
<a name="l00155"></a>00155         P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#a0ecaf4c067190a16871c14bee617164e">npoly</a> = 4;
<a name="l00156"></a>00156       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strncmp(c, <span class="stringliteral">&quot;oct&quot;</span>, 3)) {
<a name="l00157"></a>00157         P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> = CMPoly;
<a name="l00158"></a>00158         P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#aadaf15fe4447fa26cf56004270dc7a83">nr</a> = nr;
<a name="l00159"></a>00159         P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#a0ecaf4c067190a16871c14bee617164e">npoly</a> = 6;
<a name="l00160"></a>00160       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strncmp(c, <span class="stringliteral">&quot;cbe&quot;</span>, 3)) {
<a name="l00161"></a>00161         P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> = CMPoly;
<a name="l00162"></a>00162         P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#aadaf15fe4447fa26cf56004270dc7a83">nr</a> = nr;
<a name="l00163"></a>00163         P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#a0ecaf4c067190a16871c14bee617164e">npoly</a> = 8;
<a name="l00164"></a>00164       } <span class="keywordflow">else</span> {
<a name="l00165"></a>00165         P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> = CMProd;
<a name="l00166"></a>00166         P-&gt;<a class="code" href="structProjection.html#a4292128368222758301ad2c030afaac2">cmprod</a>.<a class="code" href="structcmprodpara.html#aceeaab6ba25f876de7f218c9e797cf01">nr</a> = nr;
<a name="l00167"></a>00167         P-&gt;<a class="code" href="structProjection.html#a4292128368222758301ad2c030afaac2">cmprod</a>.<a class="code" href="structcmprodpara.html#af7d2985994407467340336b7dd1b683e">ntheta</a> = atoi(c);
<a name="l00168"></a>00168         c = strtok(NULL, <span class="stringliteral">&quot;-&quot;</span>);
<a name="l00169"></a>00169         P-&gt;<a class="code" href="structProjection.html#a4292128368222758301ad2c030afaac2">cmprod</a>.<a class="code" href="structcmprodpara.html#a44027ab99975309599367c045379d55d">nphi</a> = atoi(c);
<a name="l00170"></a>00170       }
<a name="l00171"></a>00171     }
<a name="l00172"></a>00172   }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="keywordflow">return</span> 0;
<a name="l00175"></a>00175 }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 
<a name="l00178"></a><a class="code" href="Projection_8h.html#af11f2a70292f93f6b5983cfc4f26d774">00178</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#af11f2a70292f93f6b5983cfc4f26d774">fprintProjectinfo</a>(FILE* fp, <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180   <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> == <a class="code" href="Projection_8h.html#a7ff5f2dff38e7639981794c43dc9167ba55bf53a0f8c9f993e6faf4c61fe8ce10">AngNone</a>)
<a name="l00181"></a>00181     fprintf(fp, <span class="stringliteral">&quot;# angular momentum projeciton - none\n&quot;</span>);
<a name="l00182"></a>00182   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> == <a class="code" href="Projection_8h.html#a7ff5f2dff38e7639981794c43dc9167ba9610a33497e9e2e45e79bc44d5ef918f">AngProd</a>)
<a name="l00183"></a>00183     fprintf(fp, <span class="stringliteral">&quot;# angular momentum projection - product integration with %d,%d,%d points (%d angles)\n&quot;</span>, 
<a name="l00184"></a>00184             P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a>, 
<a name="l00185"></a>00185             P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#abcad02e655573d2040ce82457bbd4cc7">nbeta</a>, P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a>,
<a name="l00186"></a>00186             <a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a>)*P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#abcad02e655573d2040ce82457bbd4cc7">nbeta</a>);
<a name="l00187"></a>00187   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> == <a class="code" href="Projection_8h.html#a7ff5f2dff38e7639981794c43dc9167babf044d8a168c981d4076daf448fae0fc">AngProdA</a>)
<a name="l00188"></a>00188     fprintf(fp, <span class="stringliteral">&quot;# angular momentum projection - adaptive product integration with %d,%d,%d points (%d angles)\n&quot;</span>, 
<a name="l00189"></a>00189             P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a>, 
<a name="l00190"></a>00190             P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#abcad02e655573d2040ce82457bbd4cc7">nbeta</a>, P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a>,
<a name="l00191"></a>00191             <a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#a642cc11e3f6b0ccbb9a706fd301d48f7">nazimuth</a>)*P-&gt;<a class="code" href="structProjection.html#a6e4a4c7f14e67a6eac1aed3b3f7072a3">angprod</a>.<a class="code" href="structangprodpara.html#abcad02e655573d2040ce82457bbd4cc7">nbeta</a>);
<a name="l00192"></a>00192   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#abb780259fcb446fa48e69ac25e6c8ddd" title="type of angular momentum projection">ang</a> == <a class="code" href="Projection_8h.html#a7ff5f2dff38e7639981794c43dc9167ba9ecd3bfb04930e544c099805a7b847a6">AngZCW</a>)
<a name="l00193"></a>00193     fprintf(fp, <span class="stringliteral">&quot;# angular momentum projection - integration using ZCW set %d (%d angles)\n&quot;</span>,
<a name="l00194"></a>00194             P-&gt;<a class="code" href="structProjection.html#a24b0c733ce6d8f892575554682ef2947">angzcw</a>.<a class="code" href="structangzcwpara.html#a10bdceb86e6bb8dceb15668131ef278b">idx</a>, <a class="code" href="zcw_8c.html#a5be18be997b229d9106a4ddda9a8cafd">nangles3</a>(P-&gt;<a class="code" href="structProjection.html#a24b0c733ce6d8f892575554682ef2947">angzcw</a>.<a class="code" href="structangzcwpara.html#a10bdceb86e6bb8dceb15668131ef278b">idx</a>));
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> == <a class="code" href="Projection_8h.html#ae4d5251432e1a9e6803c0240cc492e18a8d869da79c82654982e95e61d10a64c4">CMNone</a>)
<a name="l00197"></a>00197     fprintf(fp, <span class="stringliteral">&quot;# center of mass projection - none\n&quot;</span>);
<a name="l00198"></a>00198   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> == <a class="code" href="Projection_8h.html#ae4d5251432e1a9e6803c0240cc492e18a0e967fc9236e1bb9b51ddb4c16fd096e">CMSimple</a>)
<a name="l00199"></a>00199     fprintf(fp, <span class="stringliteral">&quot;# center of mass projection - simple\n&quot;</span>);
<a name="l00200"></a>00200   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> == <a class="code" href="Projection_8h.html#ae4d5251432e1a9e6803c0240cc492e18a3ebfa1463485cc7babb95b427075772a">CMProd</a>)
<a name="l00201"></a>00201     fprintf(fp, <span class="stringliteral">&quot;# center of mass projection - product integration with %d,%d,%d points\n&quot;</span>,
<a name="l00202"></a>00202             P-&gt;<a class="code" href="structProjection.html#a4292128368222758301ad2c030afaac2">cmprod</a>.<a class="code" href="structcmprodpara.html#aceeaab6ba25f876de7f218c9e797cf01">nr</a>, P-&gt;<a class="code" href="structProjection.html#a4292128368222758301ad2c030afaac2">cmprod</a>.<a class="code" href="structcmprodpara.html#af7d2985994407467340336b7dd1b683e">ntheta</a>, P-&gt;<a class="code" href="structProjection.html#a4292128368222758301ad2c030afaac2">cmprod</a>.<a class="code" href="structcmprodpara.html#a44027ab99975309599367c045379d55d">nphi</a>);
<a name="l00203"></a>00203   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P-&gt;<a class="code" href="structProjection.html#a87ccc3a184a97511dd0c056a0586a494" title="type of cm projection">cm</a> == <a class="code" href="Projection_8h.html#ae4d5251432e1a9e6803c0240cc492e18a9930f39726023d17ca4e18c2437ebaaf">CMPoly</a>)
<a name="l00204"></a>00204     fprintf(fp, <span class="stringliteral">&quot;# center of mass projection - integration using %d %s points\n&quot;</span>,
<a name="l00205"></a>00205             P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#aadaf15fe4447fa26cf56004270dc7a83">nr</a>, (P-&gt;<a class="code" href="structProjection.html#a8e0c2249fe8e8f760f7e2fbd3629f474">cmpoly</a>.<a class="code" href="structcmpolypara.html#a0ecaf4c067190a16871c14bee617164e">npoly</a> == 4 ? <span class="stringliteral">&quot;tetrahedral&quot;</span> : <span class="stringliteral">&quot;octahedral&quot;</span>));
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 
<a name="l00209"></a><a class="code" href="Projection_8c.html#a84110f2d4600522fbbd3d392ccb28fce">00209</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#a84110f2d4600522fbbd3d392ccb28fce">initprojectedvector</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211   <span class="keywordtype">int</span> p,<a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>;
<a name="l00212"></a>00212   char (**ppv)[size];
<a name="l00213"></a>00213   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215   ppv = malloc((jmax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00216"></a>00216   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00217"></a>00217     <span class="keywordflow">for</span> (j=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>; j&lt;jmax; j=j+2) {
<a name="l00218"></a>00218       ppv[idxpij(jmax,p,j)] = malloc(n*(j+1)*size);
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="keywordflow">return</span> ppv;
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="comment">// don&#39;t really allocate space for matrix elements</span>
<a name="l00225"></a><a class="code" href="Projection_8c.html#a987206e03797318b0ba64aae88d57283">00225</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#a987206e03797318b0ba64aae88d57283">initprojectedvectornull</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l00226"></a>00226 {
<a name="l00227"></a>00227   <span class="keywordtype">int</span> p,<a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>;
<a name="l00228"></a>00228   char (**ppv)[size];
<a name="l00229"></a>00229   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   ppv = malloc((jmax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00232"></a>00232   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00233"></a>00233     <span class="keywordflow">for</span> (j=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>; j&lt;jmax; j=j+2) {
<a name="l00234"></a>00234       ppv[idxpij(jmax,p,j)] = NULL;
<a name="l00235"></a>00235     }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237   <span class="keywordflow">return</span> ppv;
<a name="l00238"></a>00238 }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 
<a name="l00241"></a><a class="code" href="Projection_8c.html#abb5a41706e33979ad3bdc5f7f03f301e">00241</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#abb5a41706e33979ad3bdc5f7f03f301e">initprojectedmatrix</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243   <span class="keywordtype">int</span> p,<a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>;
<a name="l00244"></a>00244   char (**ppm)[size];
<a name="l00245"></a>00245   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   ppm = malloc((jmax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00248"></a>00248   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00249"></a>00249     <span class="keywordflow">for</span> (j=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>; j&lt;jmax; j=j+2)
<a name="l00250"></a>00250       ppm[idxpij(jmax,p,j)] = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(n*(j+1))*size);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="keywordflow">return</span> ppm;
<a name="l00253"></a>00253 }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 
<a name="l00256"></a><a class="code" href="Projection_8c.html#a3225f075e7b00ee802171dd3be087536">00256</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#a3225f075e7b00ee802171dd3be087536">initprojectedtransitionvector</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, 
<a name="l00257"></a>00257                                     <span class="keywordtype">int</span> rank, <span class="keywordtype">int</span> pi, <span class="keywordtype">int</span> size, 
<a name="l00258"></a>00258                                     <span class="keywordtype">int</span> nfin, <span class="keywordtype">int</span> nini)
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00261"></a>00261   <span class="keywordtype">int</span> oddfin = (P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>+rank)%2;
<a name="l00262"></a>00262   <span class="keywordtype">int</span> pini,jini, pfin,jfin;
<a name="l00263"></a>00263   <span class="keywordtype">int</span> ifin;
<a name="l00264"></a>00264   char (****v)[size];
<a name="l00265"></a>00265 
<a name="l00266"></a>00266   v = malloc((jmax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00267"></a>00267   <span class="keywordflow">for</span> (pfin=0; pfin&lt;=1; pfin++)
<a name="l00268"></a>00268     <span class="keywordflow">for</span> (jfin=oddfin; jfin&lt;jmax; jfin=jfin+2) {
<a name="l00269"></a>00269       v[idxpij(jmax,pfin,jfin)] = malloc((jmax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00270"></a>00270       pini = (pfin+pi)%2;
<a name="l00271"></a>00271       <span class="keywordflow">for</span> (jini=abs(jfin-rank); jini&lt;=min(jmax-1, jfin+rank); jini=jini+2) {
<a name="l00272"></a>00272         v[idxpij(jmax,pfin,jfin)][idxpij(jmax,pini,jini)] = 
<a name="l00273"></a>00273           malloc(nfin*(jfin+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00274"></a>00274         <span class="keywordflow">for</span> (ifin=0; ifin&lt;nfin*(jfin+1); ifin++)
<a name="l00275"></a>00275           v[idxpij(jmax,pfin,jfin)][idxpij(jmax,pini,jini)][ifin] = 
<a name="l00276"></a>00276             malloc(nini*(jini+1)*size);
<a name="l00277"></a>00277       }
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279   <span class="keywordflow">return</span> v;
<a name="l00280"></a>00280 }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 <span class="comment">// don&#39;t really allocate space for matrix elements</span>
<a name="l00283"></a><a class="code" href="Projection_8c.html#a221b6708e4642b8c6eb833e351a4e835">00283</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#a221b6708e4642b8c6eb833e351a4e835">initprojectedtransitionvectornull</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, 
<a name="l00284"></a>00284                                         <span class="keywordtype">int</span> rank, <span class="keywordtype">int</span> pi, <span class="keywordtype">int</span> size, 
<a name="l00285"></a>00285                                         <span class="keywordtype">int</span> nfin, <span class="keywordtype">int</span> nini)
<a name="l00286"></a>00286 {
<a name="l00287"></a>00287   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00288"></a>00288   <span class="keywordtype">int</span> oddfin = (P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>+rank)%2;
<a name="l00289"></a>00289   <span class="keywordtype">int</span> pini,jini, pfin,jfin;
<a name="l00290"></a>00290   <span class="keywordtype">int</span> ifin;
<a name="l00291"></a>00291   char (****v)[size];
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   v = malloc((jmax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00294"></a>00294   <span class="keywordflow">for</span> (pfin=0; pfin&lt;=1; pfin++)
<a name="l00295"></a>00295     <span class="keywordflow">for</span> (jfin=oddfin; jfin&lt;jmax; jfin=jfin+2) {
<a name="l00296"></a>00296       v[idxpij(jmax,pfin,jfin)] = malloc((jmax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00297"></a>00297       pini = (pfin+pi)%2;
<a name="l00298"></a>00298       <span class="keywordflow">for</span> (jini=abs(jfin-rank); jini&lt;=min(jmax-1, jfin+rank); jini=jini+2) {
<a name="l00299"></a>00299         v[idxpij(jmax,pfin,jfin)][idxpij(jmax,pini,jini)] = 
<a name="l00300"></a>00300           malloc(nfin*(jfin+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00301"></a>00301         <span class="keywordflow">for</span> (ifin=0; ifin&lt;nfin*(jfin+1); ifin++)
<a name="l00302"></a>00302           v[idxpij(jmax,pfin,jfin)][idxpij(jmax,pini,jini)][ifin] = NULL; 
<a name="l00303"></a>00303       }
<a name="l00304"></a>00304     }
<a name="l00305"></a>00305   <span class="keywordflow">return</span> v;
<a name="l00306"></a>00306 }
<a name="l00307"></a>00307 
<a name="l00309"></a><a class="code" href="Projection_8h.html#acef8d2b9b483edf18c061e6c4fb464d2">00309</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#acef8d2b9b483edf18c061e6c4fb464d2" title="store projected MEs between two ManyBody states">initprojectedMBME</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311   <span class="keywordflow">return</span> <a class="code" href="Projection_8c.html#abb5a41706e33979ad3bdc5f7f03f301e">initprojectedmatrix</a>(P, (Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>+1)*Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>), 1);
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 
<a name="l00315"></a><a class="code" href="Projection_8h.html#ab04781bf318f9779ad81b00b7d9b1837">00315</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#ab04781bf318f9779ad81b00b7d9b1837">initprojectedVector</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op, 
<a name="l00316"></a>00316                           <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318   <span class="keywordflow">return</span> <a class="code" href="Projection_8c.html#a84110f2d4600522fbbd3d392ccb28fce">initprojectedvector</a>(P, (Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>+1)*Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>), n);
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a><a class="code" href="Projection_8h.html#af1e4c360c6c9a7eb8cffcaa091201829">00321</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#af1e4c360c6c9a7eb8cffcaa091201829">initprojectedVectornull</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op, 
<a name="l00322"></a>00322                               <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l00323"></a>00323 {
<a name="l00324"></a>00324   <span class="keywordflow">return</span> <a class="code" href="Projection_8c.html#a987206e03797318b0ba64aae88d57283">initprojectedvectornull</a>(P, (Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>+1)*Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>), n);
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 
<a name="l00328"></a><a class="code" href="Projection_8h.html#aef486ac2facdd165978efd4f5bc5009d">00328</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#abfbc5cc4e535cc273485efea8f329f36">initprojectedtransitionVector</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, 
<a name="l00329"></a>00329                                     <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op, 
<a name="l00330"></a>00330                                     <span class="keywordtype">int</span> nfin, <span class="keywordtype">int</span> nini)
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332   <span class="keywordflow">return</span> <a class="code" href="Projection_8c.html#a3225f075e7b00ee802171dd3be087536">initprojectedtransitionvector</a>(P, Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>, Op-&gt;<a class="code" href="structManyBodyOperator.html#a78ec7c9f2238907255cf499427676907" title="parity of operator, 0 positve, 1 negative">pi</a>, 
<a name="l00333"></a>00333                                        Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>), 
<a name="l00334"></a>00334                                        nfin, nini);
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 
<a name="l00337"></a><a class="code" href="Projection_8h.html#a76abdc07adaf79ddd74c8402f049c8a6">00337</a> <span class="keywordtype">void</span>* <a class="code" href="Projection_8c.html#ae4ba9f7150bfe768afd50d9523154420">initprojectedtransitionVectornull</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, 
<a name="l00338"></a>00338                                     <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op, 
<a name="l00339"></a>00339                                     <span class="keywordtype">int</span> nfin, <span class="keywordtype">int</span> nini)
<a name="l00340"></a>00340 {
<a name="l00341"></a>00341   <span class="keywordflow">return</span> <a class="code" href="Projection_8c.html#a221b6708e4642b8c6eb833e351a4e835">initprojectedtransitionvectornull</a>(P, Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>, Op-&gt;<a class="code" href="structManyBodyOperator.html#a78ec7c9f2238907255cf499427676907" title="parity of operator, 0 positve, 1 negative">pi</a>, 
<a name="l00342"></a>00342                                            Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>), 
<a name="l00343"></a>00343                                            nfin, nini);
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 
<a name="l00348"></a><a class="code" href="Projection_8h.html#a086dc7277e11cd8a2335f25cb14c66b8">00348</a> <span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a086dc7277e11cd8a2335f25cb14c66b8">writeprojectedMBME</a>(gzFile fp, <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, 
<a name="l00349"></a>00349                        <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op, 
<a name="l00350"></a>00350                        <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> S, <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sp, 
<a name="l00351"></a>00351                        <span class="keyword">const</span> <span class="keywordtype">void</span>* mbme)
<a name="l00352"></a>00352 {
<a name="l00353"></a>00353   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00354"></a>00354   <span class="keywordtype">int</span> odd = P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00355"></a>00355   <span class="keywordtype">int</span> size = Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l00356"></a>00356   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a> = Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l00357"></a>00357   <span class="keywordtype">int</span> rank = Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00358"></a>00358   complex double (**me)[(rank+1)*size] = mbme;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, r;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   gzprintf(fp, <span class="stringliteral">&quot;&lt;ProjectedMBME %s %d %d&gt;\n&quot;</span>, Op-&gt;<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a>, S, Sp);
<a name="l00363"></a>00363   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00364"></a>00364     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00365"></a>00365 
<a name="l00366"></a>00366       gzprintf(fp, <span class="stringliteral">&quot;&lt;ProjectedME %d %d&gt;\n&quot;</span>, j, p); 
<a name="l00367"></a>00367       <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2)
<a name="l00368"></a>00368         <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2) {
<a name="l00369"></a>00369           <span class="comment">// Sp fixes j, k</span>
<a name="l00370"></a>00370           <span class="comment">// if Op is scalar also j,m fixed</span>
<a name="l00371"></a>00371           <span class="keywordflow">if</span> ((Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a> != 0 || <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(S, p, j, m)) &amp;&amp; 
<a name="l00372"></a>00372               <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sp, p, j, k)) {
<a name="l00373"></a>00373             <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00374"></a>00374               <span class="keywordflow">for</span> (r=0; r&lt;=rank; r++)
<a name="l00375"></a>00375                 gzprintf(fp, <span class="stringliteral">&quot;(%15.8e,%15.8e) &quot;</span>, 
<a name="l00376"></a>00376                         creal(me[idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)]),
<a name="l00377"></a>00377                         cimag(me[idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)]));
<a name="l00378"></a>00378             gzprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00379"></a>00379           }
<a name="l00380"></a>00380         }
<a name="l00381"></a>00381         gzprintf(fp, <span class="stringliteral">&quot;&lt;/ProjectedME&gt;\n&quot;</span>);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383     }   
<a name="l00384"></a>00384   gzprintf(fp, <span class="stringliteral">&quot;&lt;/ProjectedMBME&gt;\n&quot;</span>);
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   <span class="keywordflow">return</span> 0;
<a name="l00387"></a>00387 }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 
<a name="l00390"></a><a class="code" href="Projection_8h.html#a9f0871c9ab882dc39462783988c4eab2">00390</a> <span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a9722bff3ee0d982f58d704b1e6c5f205">writeprojectedMBMEtoFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* mbfilea, <span class="keyword">const</span> <span class="keywordtype">char</span>* mbfileb,
<a name="l00391"></a>00391                              <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00392"></a>00392                              <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00393"></a>00393                              <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sa, <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sb,
<a name="l00394"></a>00394                              <span class="keyword">const</span> <span class="keywordtype">void</span>* me)
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396   gzFile mefp;
<a name="l00397"></a>00397   <span class="keywordtype">char</span> mefilename[255];
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <a class="code" href="utils_8c.html#a91bd1e9936bf548fc21c811e258c81e9" title="check for existence, create if not of directory">ensuredir</a>(<span class="stringliteral">&quot;ME&quot;</span>);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   snprintf(mefilename, 255, <span class="stringliteral">&quot;ME/%s--%s%s--%s%s--%s.gz&quot;</span>, 
<a name="l00402"></a>00402            Op-&gt;<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a>, 
<a name="l00403"></a>00403            (Sa==0 ? <span class="stringliteral">&quot;&quot;</span> : <a class="code" href="utils_8c.html#ab513af03cb4d827e200043bbc98cad12" title="join two strings">strjoin</a>(<a class="code" href="Symmetry_8c.html#a57aa62a08fd12aa6fd7da2355ffb0ea0" title="get String with Symmetry">SymmetrytoStr</a>(Sa), <span class="stringliteral">&quot;:&quot;</span>)), 
<a name="l00404"></a>00404            <a class="code" href="utils_8c.html#a72e38b8773b63e202dbebc40c3346988" title="get the file component of fullname">filepart</a>(mbfilea), 
<a name="l00405"></a>00405            (Sb==0 ? <span class="stringliteral">&quot;&quot;</span> : <a class="code" href="utils_8c.html#ab513af03cb4d827e200043bbc98cad12" title="join two strings">strjoin</a>(<a class="code" href="Symmetry_8c.html#a57aa62a08fd12aa6fd7da2355ffb0ea0" title="get String with Symmetry">SymmetrytoStr</a>(Sb), <span class="stringliteral">&quot;:&quot;</span>)), 
<a name="l00406"></a>00406            <a class="code" href="utils_8c.html#a72e38b8773b63e202dbebc40c3346988" title="get the file component of fullname">filepart</a>(mbfileb), 
<a name="l00407"></a>00407            <a class="code" href="Projection_8c.html#ac87bb7fb183abeb15fc0454df5babd55">ProjectiontoStr</a>(P));
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <span class="keywordflow">if</span> (!(mefp = gzopen(mefilename, <span class="stringliteral">&quot;w&quot;</span>))) {
<a name="l00410"></a>00410     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for writing\n&quot;</span>, mefilename);
<a name="l00411"></a>00411     <span class="keywordflow">return</span> -1;
<a name="l00412"></a>00412   }
<a name="l00413"></a>00413     
<a name="l00414"></a>00414   <a class="code" href="utils_8c.html#a109d01ec3cb7ea341ed78e31316661b8" title="print info about running process">gzprintinfo</a>(mefp);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   gzprintf(mefp, <span class="stringliteral">&quot;&lt;MBFile %s %s %d&gt;\n&quot;</span>, 
<a name="l00417"></a>00417            mbfilea, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfilea), Sa);
<a name="l00418"></a>00418   gzprintf(mefp, <span class="stringliteral">&quot;&lt;MBFile %s %s %d&gt;\n\n&quot;</span>, 
<a name="l00419"></a>00419            mbfileb, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfileb), Sb);
<a name="l00420"></a>00420 
<a name="l00421"></a>00421   <a class="code" href="Projection_8c.html#a086dc7277e11cd8a2335f25cb14c66b8">writeprojectedMBME</a>(mefp, P, Op, Sa, Sb, me);
<a name="l00422"></a>00422 
<a name="l00423"></a>00423   gzclose(mefp);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="keywordflow">return</span> 0;
<a name="l00426"></a>00426 } 
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 <span class="preprocessor">#define BUFSIZE 65536</span>
<a name="l00430"></a>00430 <span class="preprocessor"></span>
<a name="l00431"></a>00431 <span class="keyword">static</span> <span class="keywordtype">char</span>* buf;
<a name="l00432"></a>00432 
<a name="l00433"></a><a class="code" href="Projection_8h.html#a24221ca9708e29fc5ea20304505d5399">00433</a> <span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a24221ca9708e29fc5ea20304505d5399">readprojectedMBME</a>(gzFile fp, 
<a name="l00434"></a>00434                       <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00435"></a>00435                       <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> S, <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sp,
<a name="l00436"></a>00436                       <span class="keywordtype">void</span>* mbme)
<a name="l00437"></a>00437 {
<a name="l00438"></a>00438   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00439"></a>00439   <span class="keywordtype">int</span> odd = P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00440"></a>00440   <span class="keywordtype">int</span> size = Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l00441"></a>00441   <span class="keywordtype">int</span> rank = Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00442"></a>00442   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a> = Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l00443"></a>00443   complex double (**me)[(rank+1)*size] = mbme;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, r;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447   <span class="comment">// possibly initialize space for buffer</span>
<a name="l00448"></a>00448   <span class="keywordflow">if</span> (!buf)
<a name="l00449"></a>00449     buf = malloc(<a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451   <span class="keywordtype">char</span> *c;
<a name="l00452"></a>00452   <span class="keywordtype">double</span> ref, imf;
<a name="l00453"></a>00453 
<a name="l00454"></a>00454   <span class="comment">// initialize matrix elements to zero</span>
<a name="l00455"></a>00455   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00456"></a>00456     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00457"></a>00457       <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00458"></a>00458         <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2)
<a name="l00459"></a>00459           <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00460"></a>00460             <span class="keywordflow">for</span> (r=0 ; r&lt;=rank; r++)
<a name="l00461"></a>00461               me[idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)] = 0.0;
<a name="l00462"></a>00462     }   
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <span class="keywordflow">do</span>
<a name="l00465"></a>00465     gzgets(fp, buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00466"></a>00466   <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;ProjectedMBME &quot;</span>, 15) &amp;&amp; !gzeof(fp));
<a name="l00467"></a>00467   <span class="keywordflow">if</span> (gzeof(fp)) {
<a name="l00468"></a>00468     fprintf(stderr, <span class="stringliteral">&quot;did&#39;t find &lt;ProjectedMBME ...&gt;\n&quot;</span>);
<a name="l00469"></a>00469     <span class="keywordflow">return</span> -1;
<a name="l00470"></a>00470   }
<a name="l00471"></a>00471   <span class="keywordtype">char</span> opname[80];
<a name="l00472"></a>00472   <span class="keywordtype">int</span> fileS, fileSp;
<a name="l00473"></a>00473   sscanf(buf, <span class="stringliteral">&quot;&lt;ProjectedMBME %s %d %d&gt;&quot;</span>, opname, &amp;fileS, &amp;fileSp);
<a name="l00474"></a>00474   <span class="keywordflow">if</span> (strcmp(<a class="code" href="utils_8c.html#af86aada130a5db5b0f52154718d67c44" title="strips strip from str">stripstr</a>(opname, <span class="stringliteral">&quot;&gt;&quot;</span>), Op-&gt;<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a>)) {
<a name="l00475"></a>00475     fprintf(stderr, <span class="stringliteral">&quot;not %s matrixelements\n&quot;</span>, Op-&gt;<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a>);
<a name="l00476"></a>00476     <span class="keywordflow">return</span> -1;
<a name="l00477"></a>00477   }
<a name="l00478"></a>00478   <span class="keywordflow">if</span> (fileS != S || fileSp != Sp) {
<a name="l00479"></a>00479     fprintf(stderr, <span class="stringliteral">&quot;Symmetries don&#39;t match\n&quot;</span>);
<a name="l00480"></a>00480     <span class="keywordflow">return</span> -1;
<a name="l00481"></a>00481   }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   <span class="keywordtype">int</span> filej, filep;
<a name="l00484"></a>00484   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00485"></a>00485     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00486"></a>00486       gzgets(fp, buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00487"></a>00487       sscanf(buf, <span class="stringliteral">&quot;&lt;ProjectedME %d %d&gt;&quot;</span>, &amp;filej, &amp;filep);
<a name="l00488"></a>00488       <span class="keywordflow">if</span> (filej != j || filep != p) {
<a name="l00489"></a>00489         fprintf(stderr, <span class="stringliteral">&quot;malformed line\n&gt;&gt;%s&lt;&lt;\n&quot;</span>, <a class="code" href="utils_8c.html#af86aada130a5db5b0f52154718d67c44" title="strips strip from str">stripstr</a>(buf, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00490"></a>00490         <span class="keywordflow">return</span> -1;
<a name="l00491"></a>00491       }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493       <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2)
<a name="l00494"></a>00494         <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2) {
<a name="l00495"></a>00495           <span class="keywordflow">if</span> ((Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a> != 0 || <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(S, p, j, m)) &amp;&amp; 
<a name="l00496"></a>00496               <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sp, p, j, k)) {
<a name="l00497"></a>00497             gzgets(fp, buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00498"></a>00498             c = strtok(buf, <span class="stringliteral">&quot; ,()&quot;</span>);
<a name="l00499"></a>00499             <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00500"></a>00500               <span class="keywordflow">for</span> (r=0; r&lt;=rank; r++) {
<a name="l00501"></a>00501                 ref=atof(c); c=strtok(NULL, <span class="stringliteral">&quot; ,()&quot;</span>);
<a name="l00502"></a>00502                 imf=atof(c); c=strtok(NULL, <span class="stringliteral">&quot; ,()&quot;</span>);
<a name="l00503"></a>00503                 me[idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)] = ref+<a class="code" href="md5_8c.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>*imf;
<a name="l00504"></a>00504             }
<a name="l00505"></a>00505           }
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507 
<a name="l00508"></a>00508       gzgets(fp, buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00509"></a>00509       <span class="keywordflow">if</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;/ProjectedME&gt;&quot;</span>, 14)) {
<a name="l00510"></a>00510         fprintf(stderr, <span class="stringliteral">&quot;didn&#39;t find &lt;/ProjectedME&gt;\n&quot;</span>);
<a name="l00511"></a>00511         <span class="keywordflow">return</span> -1;
<a name="l00512"></a>00512       }
<a name="l00513"></a>00513     }
<a name="l00514"></a>00514   gzgets(fp, buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00515"></a>00515   <span class="keywordflow">if</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;/ProjectedMBME&gt;&quot;</span>, 16)) {
<a name="l00516"></a>00516     fprintf(stderr, <span class="stringliteral">&quot;didn&#39;t find &lt;/ProjectedMBME&gt;\n&quot;</span>);
<a name="l00517"></a>00517     <span class="keywordflow">return</span> -1;
<a name="l00518"></a>00518   }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="keywordflow">return</span> 0;
<a name="l00521"></a>00521 }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 
<a name="l00526"></a><a class="code" href="Projection_8h.html#a56dd7948b0969a553329ddf6dcdc27c3">00526</a> <span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a5fd023e0c53857a334555f58605fb039">readprojectedMBMEfromFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* mbfilea, <span class="keyword">const</span> <span class="keywordtype">char</span>* mbfileb, 
<a name="l00527"></a>00527                               <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00528"></a>00528                               <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00529"></a>00529                               <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sa, <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sb,
<a name="l00530"></a>00530                               <span class="keywordtype">void</span>* mbme)
<a name="l00531"></a>00531 {
<a name="l00532"></a>00532   gzFile mefp;
<a name="l00533"></a>00533   <span class="keywordtype">char</span> mefilename[255];
<a name="l00534"></a>00534   <span class="keywordtype">char</span> buf[BUFSIZE];
<a name="l00535"></a>00535   <span class="keywordtype">char</span> fnam[255], md5fnam[33];
<a name="l00536"></a>00536   <span class="keywordtype">int</span> fileS;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   snprintf(mefilename, 255, <span class="stringliteral">&quot;ME/%s--%s%s--%s%s--%s.gz&quot;</span>, 
<a name="l00539"></a>00539            Op-&gt;<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a>, 
<a name="l00540"></a>00540            (Sa==0 ? <span class="stringliteral">&quot;&quot;</span> : <a class="code" href="utils_8c.html#ab513af03cb4d827e200043bbc98cad12" title="join two strings">strjoin</a>(<a class="code" href="Symmetry_8c.html#a57aa62a08fd12aa6fd7da2355ffb0ea0" title="get String with Symmetry">SymmetrytoStr</a>(Sa), <span class="stringliteral">&quot;:&quot;</span>)), 
<a name="l00541"></a>00541            <a class="code" href="utils_8c.html#a72e38b8773b63e202dbebc40c3346988" title="get the file component of fullname">filepart</a>(mbfilea), 
<a name="l00542"></a>00542            (Sb==0 ? <span class="stringliteral">&quot;&quot;</span> : <a class="code" href="utils_8c.html#ab513af03cb4d827e200043bbc98cad12" title="join two strings">strjoin</a>(<a class="code" href="Symmetry_8c.html#a57aa62a08fd12aa6fd7da2355ffb0ea0" title="get String with Symmetry">SymmetrytoStr</a>(Sb), <span class="stringliteral">&quot;:&quot;</span>)), 
<a name="l00543"></a>00543            <a class="code" href="utils_8c.html#a72e38b8773b63e202dbebc40c3346988" title="get the file component of fullname">filepart</a>(mbfileb), 
<a name="l00544"></a>00544            <a class="code" href="Projection_8c.html#ac87bb7fb183abeb15fc0454df5babd55">ProjectiontoStr</a>(P));
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   <span class="keywordflow">if</span> (<a class="code" href="utils_8c.html#a80285197256014b2324f0b874a91cb19" title="check if file exists and is readable (returns 0 for success)">fileexists</a>(mefilename)) {
<a name="l00547"></a>00547       fprintf(stderr, <span class="stringliteral">&quot;... %s does not exist\n&quot;</span>, mefilename);
<a name="l00548"></a>00548       <span class="keywordflow">return</span> -1;
<a name="l00549"></a>00549     }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551   <span class="keywordflow">if</span> (!(mefp = gzopen(mefilename, <span class="stringliteral">&quot;r&quot;</span>))) {
<a name="l00552"></a>00552     fprintf(stderr, <span class="stringliteral">&quot;... couldn&#39;t open %s for reading\n&quot;</span>, mefilename);
<a name="l00553"></a>00553     <span class="keywordflow">return</span> -1;
<a name="l00554"></a>00554   }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556   fprintf(stderr, <span class="stringliteral">&quot;... reading matrix elements from file %s\n&quot;</span>, mefilename);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   <span class="comment">// do many-body files match ?</span>
<a name="l00559"></a>00559   <span class="keywordflow">do</span>
<a name="l00560"></a>00560     gzgets(mefp, buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00561"></a>00561   <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;MBFile &quot;</span>, 7) &amp;&amp; !gzeof(mefp));
<a name="l00562"></a>00562   <span class="keywordflow">if</span> (gzeof(mefp)) {
<a name="l00563"></a>00563     fprintf(stderr, <span class="stringliteral">&quot;...   did&#39;t find &lt;MBFile ...&gt;\n&quot;</span>);
<a name="l00564"></a>00564     gzclose(mefp);
<a name="l00565"></a>00565     <span class="keywordflow">return</span> -2;
<a name="l00566"></a>00566   }
<a name="l00567"></a>00567   sscanf(buf, <span class="stringliteral">&quot;&lt;MBFile %s %s %d&gt;&quot;</span>, fnam, md5fnam, &amp;fileS);
<a name="l00568"></a>00568   <span class="keywordflow">if</span> (strncmp(md5fnam, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfilea), 32)) {
<a name="l00569"></a>00569     fprintf(stderr, <span class="stringliteral">&quot;...    MBFile does not match with existing ME\n&quot;</span>);
<a name="l00570"></a>00570     <span class="keywordflow">return</span> -2;
<a name="l00571"></a>00571   }
<a name="l00572"></a>00572   <span class="keywordflow">if</span> (fileS != Sa) {
<a name="l00573"></a>00573     fprintf(stderr, <span class="stringliteral">&quot;...    Symmetry does not match with existing ME\n&quot;</span>);
<a name="l00574"></a>00574     <span class="keywordflow">return</span> -2;
<a name="l00575"></a>00575   }
<a name="l00576"></a>00576   <span class="keywordflow">do</span>
<a name="l00577"></a>00577     gzgets(mefp, buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00578"></a>00578   <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;MBFile &quot;</span>, 7) &amp;&amp; !gzeof(mefp));
<a name="l00579"></a>00579   <span class="keywordflow">if</span> (gzeof(mefp)) {
<a name="l00580"></a>00580     fprintf(stderr, <span class="stringliteral">&quot;...    did&#39;t find &lt;MBFile ...&gt;\n&quot;</span>);
<a name="l00581"></a>00581     gzclose(mefp);
<a name="l00582"></a>00582     <span class="keywordflow">return</span> -2;
<a name="l00583"></a>00583   }
<a name="l00584"></a>00584   sscanf(buf, <span class="stringliteral">&quot;&lt;MBFile %s %s %d&gt;&quot;</span>, fnam, md5fnam, &amp;fileS);
<a name="l00585"></a>00585   <span class="keywordflow">if</span> (strncmp(md5fnam, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfileb), 32)) {
<a name="l00586"></a>00586     fprintf(stderr, <span class="stringliteral">&quot;...    MBFile does not match with existing ME\n&quot;</span>);
<a name="l00587"></a>00587     gzclose(mefp);
<a name="l00588"></a>00588     <span class="keywordflow">return</span> -2;
<a name="l00589"></a>00589   }
<a name="l00590"></a>00590   <span class="keywordflow">if</span> (fileS != Sb) {
<a name="l00591"></a>00591     fprintf(stderr, <span class="stringliteral">&quot;...    Symmetry does not match with existing ME\n&quot;</span>);
<a name="l00592"></a>00592     <span class="keywordflow">return</span> -2;
<a name="l00593"></a>00593   }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   <span class="comment">// now read the matrix elements</span>
<a name="l00596"></a>00596   <span class="keywordtype">int</span> res;
<a name="l00597"></a>00597   res = <a class="code" href="Projection_8c.html#a24221ca9708e29fc5ea20304505d5399">readprojectedMBME</a>(mefp, P, Op, Sa, Sb, mbme); 
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   gzclose(mefp);
<a name="l00600"></a>00600   <span class="keywordflow">return</span> res;
<a name="l00601"></a>00601 }
<a name="l00602"></a>00602 
<a name="l00603"></a>00603 <span class="comment">// 07/13/09 important change: do not normalize Q and Qp anymore</span>
<a name="l00604"></a>00604 
<a name="l00605"></a><a class="code" href="Projection_8h.html#a044ac20ed8962994aa88e59cbc93870e">00605</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a044ac20ed8962994aa88e59cbc93870e">calcprojectedMBME</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00606"></a>00606                        <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00607"></a>00607                        <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> S, <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sp,
<a name="l00608"></a>00608                        <span class="keywordtype">void</span>* mbme)
<a name="l00609"></a>00609 {
<a name="l00610"></a>00610   <span class="keywordtype">int</span> size=Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l00611"></a>00611   <span class="keywordtype">int</span> rank=Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00612"></a>00612   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l00613"></a>00613   complex double (**<a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>)[(rank+1)*size] = mbme;
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a9e0195b1777800e72b4f7af51f0c3945">Qpp</a>;
<a name="l00616"></a>00616   <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a> <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00619"></a>00619   <span class="keywordtype">int</span> odd = P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   <span class="comment">// norms of SlaterDets</span>
<a name="l00622"></a>00622   <a class="code" href="SlaterDet_8c.html#a9d28b849a027b454fd2eddb812a884c5" title="init SlaterDetAux X">initSlaterDetAux</a>(Q, &amp;X);
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   <span class="comment">// calcSlaterDetAuxod(Q, Q, &amp;X);</span>
<a name="l00625"></a>00625   <span class="comment">// double norm = sqrt(creal(X.ovlap));</span>
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   <span class="comment">// initSlaterDetAux(Qp, &amp;X);</span>
<a name="l00628"></a>00628   <span class="comment">// calcSlaterDetAuxod(Qp, Qp, &amp;X);</span>
<a name="l00629"></a>00629   <span class="comment">// double normp = sqrt(creal(X.ovlap));  </span>
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <span class="comment">// set up cm integration</span>
<a name="l00632"></a>00632   <a class="code" href="structcmintegrationpara.html">cmintegrationpara</a> <a class="code" href="structcmpara.html">cmpara</a>;
<a name="l00633"></a>00633   <a class="code" href="cmprojection_8c.html#abf4911adb463930dc540277d1da25c35">initcmintegration</a>(P, Q, Qp, &amp;cmpara);
<a name="l00634"></a>00634   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2vappcm_8c.html#a8a5e05e8fcc2b05354bff66fc1b1755c">ncm</a> = cmpara.<a class="code" href="structcmintegrationpara.html#ae1229cd214b908780ebc4ae9b66f5e19">n</a>;
<a name="l00635"></a>00635 
<a name="l00636"></a>00636   <span class="comment">// set up angular momentum integration</span>
<a name="l00637"></a>00637   <a class="code" href="structangintegrationpara.html">angintegrationpara</a> <a class="code" href="MinimizerDONLP2multivappcm_8c.html#a49105e626fcbcb1b768fedd076a84bd6">angpara</a>;
<a name="l00638"></a>00638   <a class="code" href="angprojection_8c.html#ae7ea91fc189ad0a0487363668e0ffa89">initangintegration</a>(P, Q, Qp, S, Sp, &amp;angpara);
<a name="l00639"></a>00639   <span class="keywordtype">int</span> nang = angpara.<a class="code" href="structangintegrationpara.html#a4b08f3ab8ebe1b43dc13c7e4223d3156">n</a>;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, r;
<a name="l00642"></a>00642   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644   <span class="comment">// set matrix elements to zero</span>
<a name="l00645"></a>00645   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00646"></a>00646     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00647"></a>00647       <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00648"></a>00648         <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2)
<a name="l00649"></a>00649           <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00650"></a>00650             <span class="keywordflow">for</span> (r=0; r&lt;=rank; r++)
<a name="l00651"></a>00651               <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)] = 0.0;
<a name="l00652"></a>00652     }   
<a name="l00653"></a>00653 
<a name="l00654"></a>00654   <a class="code" href="SlaterDet_8c.html#a16db6f53cfee239b7d506c86bc372686">initSlaterDet</a>(Qp, &amp;Qpp);
<a name="l00655"></a>00655   
<a name="l00656"></a>00656   <span class="keywordtype">int</span> icm; 
<a name="l00657"></a>00657   <span class="keywordtype">double</span> xcm[3]; <span class="keywordtype">double</span> weightcm;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   <span class="keywordtype">int</span> iang;
<a name="l00660"></a>00660   <span class="keywordtype">double</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a20f4c4490bc8ecbdd1ffcb79acce6035" title="finestructure constant">alpha</a>, beta, gamma; <span class="keywordtype">double</span> weightang;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662   complex <span class="keywordtype">double</span> sval[(rank+1)*size];
<a name="l00663"></a>00663   <span class="keywordtype">double</span> weight;
<a name="l00664"></a>00664   <span class="keywordtype">int</span> ip;
<a name="l00665"></a>00665 
<a name="l00666"></a>00666   <span class="keywordflow">for</span> (icm=0; icm&lt;ncm; icm++) {
<a name="l00667"></a>00667     <a class="code" href="cmprojection_8c.html#a4cde89930e46342aae042ab854f2290b">getcmintegrationpoint</a>(icm, &amp;cmpara, xcm, &amp;weightcm);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669     <span class="keywordflow">for</span> (iang=0; iang&lt;nang; iang++) {
<a name="l00670"></a>00670       <a class="code" href="angprojection_8c.html#a84c53149d9af0a652cb6486c9516cbb5">getangintegrationpoint</a>(iang, &amp;angpara, &amp;alpha, &amp;beta, &amp;gamma, &amp;weightang);
<a name="l00671"></a>00671       <span class="comment">// weight = 1.0/(2*norm*normp)*weightcm*weightang;</span>
<a name="l00672"></a>00672       weight = 0.5*weightcm*weightang;
<a name="l00673"></a>00673       
<a name="l00674"></a>00674       <a class="code" href="SlaterDet_8c.html#acd974ea424b0829a55ada79fc69abd90">copySlaterDet</a>(Qp, &amp;Qpp);
<a name="l00675"></a>00675       <a class="code" href="SlaterDet_8c.html#a5463a8afc7565b2711169b605aad5ca3" title="move Slater determinant by vector d">moveSlaterDet</a>(&amp;Qpp, xcm);
<a name="l00676"></a>00676       <a class="code" href="SlaterDet_8c.html#a8737af9032a8d87843782a88228fef00" title="rotate Slater determinant by euler angles">rotateSlaterDet</a>(&amp;Qpp, alpha, beta, gamma);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678       <span class="keywordflow">for</span> (ip=0; ip&lt;=1; ip++) {
<a name="l00679"></a>00679           <span class="keywordflow">if</span> (ip) <a class="code" href="SlaterDet_8c.html#ad0aa11be18d42c1cc26c2ad1380feb2a" title="invert Slater determinant in origin">invertSlaterDet</a>(&amp;Qpp);
<a name="l00680"></a>00680 
<a name="l00681"></a>00681           <span class="comment">// can only calculate Auxilliaries if Sldets are compatible</span>
<a name="l00682"></a>00682           <span class="keywordflow">if</span> (Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> == Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>) {
<a name="l00683"></a>00683             <span class="keywordflow">if</span> (Q-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> == Qp-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> &amp;&amp; Q-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a> == Qp-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>)
<a name="l00684"></a>00684               <a class="code" href="SlaterDet_8c.html#ad3679a655d9b6019619456e5b7961638">calcSlaterDetAuxod</a>(Q, &amp;Qpp, &amp;X);
<a name="l00685"></a>00685             <span class="keywordflow">else</span>
<a name="l00686"></a>00686               <a class="code" href="SlaterDet_8c.html#a861e4c675c3918393d69a81090376053">calcSlaterDetAuxodsingular</a>(Q, &amp;Qpp, &amp;X);
<a name="l00687"></a>00687           }
<a name="l00688"></a>00688           Op-&gt;<a class="code" href="structManyBodyOperator.html#aba2e7e550190ee2ec6e75c23c55fee2d">me</a>(Op-&gt;<a class="code" href="structManyBodyOperator.html#a05268b1b149040fd992263f2e22de7ec">par</a>, Q, &amp;Qpp, &amp;X, sval);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690           complex <span class="keywordtype">double</span> w;
<a name="l00691"></a>00691           <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00692"></a>00692             <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2)
<a name="l00693"></a>00693               <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00694"></a>00694                 <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2) {
<a name="l00695"></a>00695                   <span class="keywordflow">if</span> ((Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a> != 0 || <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(S, p, j, m)) &amp;&amp;
<a name="l00696"></a>00696                       <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sp, p, j, k)) {
<a name="l00697"></a>00697                     w = weight * (p &amp;&amp; ip%2 ? -1 : 1)*
<a name="l00698"></a>00698                       (j+1)/(8*<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(M_PI))*Djmkstar(j,m,k,alpha,beta,gamma);
<a name="l00699"></a>00699                     <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00700"></a>00700                       <span class="keywordflow">for</span> (r=0; r&lt;=rank; r++)
<a name="l00701"></a>00701                         <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)] += 
<a name="l00702"></a>00702                           w*sval[r+l*(rank+1)];
<a name="l00703"></a>00703                   }     
<a name="l00704"></a>00704                 }       
<a name="l00705"></a>00705       }
<a name="l00706"></a>00706 
<a name="l00707"></a>00707     }
<a name="l00708"></a>00708 
<a name="l00709"></a>00709   }
<a name="l00710"></a>00710   <a class="code" href="SlaterDet_8c.html#a6d10ca2b062d871a6903292600c3125a" title="free memory used by SlaterDetAux X">freeSlaterDetAux</a>(&amp;X);
<a name="l00711"></a>00711   <a class="code" href="SlaterDet_8c.html#adc279637790bc3303e9dca688966a7ab" title="free memory used by Slater determinant Q">freeSlaterDet</a>(&amp;Qpp);
<a name="l00712"></a>00712 }       
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 
<a name="l00715"></a><a class="code" href="Projection_8h.html#aea2e08302b36a68b650325373e8139df">00715</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a466107652b84c09713aea64e373bc1c8">calcprojectedMBMEs</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structManyBodyOperators.html" title="Collection of ManyBody Operators.">ManyBodyOperators</a>* Ops,
<a name="l00716"></a>00716                         <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00717"></a>00717                         <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> S, <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sp,
<a name="l00718"></a>00718                         <span class="keywordtype">void</span>* mbme)
<a name="l00719"></a>00719 {
<a name="l00720"></a>00720   <span class="keywordtype">int</span> size=Ops-&gt;<a class="code" href="structManyBodyOperators.html#a94494657638d56cc4a332f00aefcd1e4">size</a>;
<a name="l00721"></a>00721   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Ops-&gt;<a class="code" href="structManyBodyOperators.html#aa1b09f1ea3ecfedd76ca27f7954ce65b" title="has to be the same for all Operators">dim</a>;
<a name="l00722"></a>00722   complex <span class="keywordtype">double</span> ***<a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a> = mbme;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724   <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a9e0195b1777800e72b4f7af51f0c3945">Qpp</a>;
<a name="l00725"></a>00725   <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>  <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00728"></a>00728   <span class="keywordtype">int</span> odd = P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730   <span class="comment">// norms of SlaterDets</span>
<a name="l00731"></a>00731   <a class="code" href="SlaterDet_8c.html#a9d28b849a027b454fd2eddb812a884c5" title="init SlaterDetAux X">initSlaterDetAux</a>(Q, &amp;X);
<a name="l00732"></a>00732   <span class="comment">// calcSlaterDetAuxod(Q, Q, &amp;X);</span>
<a name="l00733"></a>00733   <span class="comment">// double norm = sqrt(creal(X.ovlap));</span>
<a name="l00734"></a>00734 
<a name="l00735"></a>00735   <span class="comment">// initSlaterDetAux(Qp, &amp;X);</span>
<a name="l00736"></a>00736   <span class="comment">// calcSlaterDetAuxod(Qp, Qp, &amp;X);</span>
<a name="l00737"></a>00737   <span class="comment">// double normp = sqrt(creal(X.ovlap));  </span>
<a name="l00738"></a>00738 
<a name="l00739"></a>00739   <span class="comment">// set up cm integration</span>
<a name="l00740"></a>00740   <a class="code" href="structcmintegrationpara.html">cmintegrationpara</a> <a class="code" href="structcmpara.html">cmpara</a>;
<a name="l00741"></a>00741   <a class="code" href="cmprojection_8c.html#abf4911adb463930dc540277d1da25c35">initcmintegration</a>(P, Q, Qp, &amp;cmpara);
<a name="l00742"></a>00742   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2vappcm_8c.html#a8a5e05e8fcc2b05354bff66fc1b1755c">ncm</a> = cmpara.<a class="code" href="structcmintegrationpara.html#ae1229cd214b908780ebc4ae9b66f5e19">n</a>;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744   <span class="comment">// set up angular momentum integration</span>
<a name="l00745"></a>00745   <a class="code" href="structangintegrationpara.html">angintegrationpara</a> <a class="code" href="MinimizerDONLP2multivappcm_8c.html#a49105e626fcbcb1b768fedd076a84bd6">angpara</a>;
<a name="l00746"></a>00746   <a class="code" href="angprojection_8c.html#ae7ea91fc189ad0a0487363668e0ffa89">initangintegration</a>(P, Q, Qp, S, Sp, &amp;angpara);
<a name="l00747"></a>00747   <span class="keywordtype">int</span> nang = angpara.<a class="code" href="structangintegrationpara.html#a4b08f3ab8ebe1b43dc13c7e4223d3156">n</a>;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, r;
<a name="l00750"></a>00750   <span class="keywordtype">int</span> o, p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752   <span class="comment">// helpful for indexing matrix elements</span>
<a name="l00753"></a>00753 
<a name="l00754"></a>00754   <span class="keywordtype">int</span> ranko[Ops-&gt;<a class="code" href="structManyBodyOperators.html#ab95444d93053e68e632c2ca2948b6177" title="number of operators">n</a>];
<a name="l00755"></a>00755   <span class="keywordflow">for</span> (o=0; o&lt;Ops-&gt;<a class="code" href="structManyBodyOperators.html#ab95444d93053e68e632c2ca2948b6177" title="number of operators">n</a>; o++)
<a name="l00756"></a>00756     ranko[o] = Ops-&gt;<a class="code" href="structManyBodyOperators.html#aec0b3262bd8c350633c8ba56cd09f16f">Op</a>[o].<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758   <span class="keywordtype">int</span> sizeo[Ops-&gt;<a class="code" href="structManyBodyOperators.html#ab95444d93053e68e632c2ca2948b6177" title="number of operators">n</a>];
<a name="l00759"></a>00759   for (o=0; o&lt;Ops-&gt;<a class="code" href="structManyBodyOperators.html#ab95444d93053e68e632c2ca2948b6177" title="number of operators">n</a>; o++)
<a name="l00760"></a>00760     sizeo[o] = size*(ranko[o]+1);
<a name="l00761"></a>00761 
<a name="l00762"></a>00762   <span class="keywordtype">int</span> <a class="code" href="OneNucleonOvlaps_8c.html#a13396ab49d1309c7c94166be31333904">io</a>[Ops-&gt;<a class="code" href="structManyBodyOperators.html#ab95444d93053e68e632c2ca2948b6177" title="number of operators">n</a>]; io[0] = 0;
<a name="l00763"></a>00763   <span class="keywordflow">for</span> (o=0; o&lt;Ops-&gt;<a class="code" href="structManyBodyOperators.html#ab95444d93053e68e632c2ca2948b6177" title="number of operators">n</a>-1; o++)
<a name="l00764"></a>00764     io[o+1] = io[o]+sizeo[o];
<a name="l00765"></a>00765 
<a name="l00766"></a>00766   <span class="keywordtype">int</span> no=0;
<a name="l00767"></a>00767   <span class="keywordflow">for</span> (o=0; o&lt;Ops-&gt;<a class="code" href="structManyBodyOperators.html#ab95444d93053e68e632c2ca2948b6177" title="number of operators">n</a>; o++)
<a name="l00768"></a>00768     no += sizeo[o];
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 
<a name="l00771"></a>00771   <span class="comment">// set matrix elements to zero</span>
<a name="l00772"></a>00772   <span class="keywordflow">for</span> (o=0; o&lt;Ops-&gt;<a class="code" href="structManyBodyOperators.html#ab95444d93053e68e632c2ca2948b6177" title="number of operators">n</a>; o++)
<a name="l00773"></a>00773     <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00774"></a>00774       <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00775"></a>00775         <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00776"></a>00776           <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2)
<a name="l00777"></a>00777             <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00778"></a>00778               <span class="keywordflow">for</span> (r=0; r&lt;=ranko[o]; r++)
<a name="l00779"></a>00779                 val[o][idxpij(jmax,p,j)][r+l*(ranko[o]+1)+idxjmk(j,m,k)*sizeo[o]] = 0.0;
<a name="l00780"></a>00780     }   
<a name="l00781"></a>00781 
<a name="l00782"></a>00782   <a class="code" href="SlaterDet_8c.html#a16db6f53cfee239b7d506c86bc372686">initSlaterDet</a>(Qp, &amp;Qpp);
<a name="l00783"></a>00783   
<a name="l00784"></a>00784   <span class="keywordtype">int</span> icm; 
<a name="l00785"></a>00785   <span class="keywordtype">double</span> xcm[3]; <span class="keywordtype">double</span> weightcm;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   <span class="keywordtype">int</span> iang;
<a name="l00788"></a>00788   <span class="keywordtype">double</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a20f4c4490bc8ecbdd1ffcb79acce6035" title="finestructure constant">alpha</a>, beta, gamma; <span class="keywordtype">double</span> weightang;
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 
<a name="l00791"></a>00791   complex <span class="keywordtype">double</span> sval[no];
<a name="l00792"></a>00792   <span class="keywordtype">double</span> weight;
<a name="l00793"></a>00793   <span class="keywordtype">int</span> ip;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   <span class="keywordflow">for</span> (icm=0; icm&lt;ncm; icm++) {
<a name="l00796"></a>00796     <a class="code" href="cmprojection_8c.html#a4cde89930e46342aae042ab854f2290b">getcmintegrationpoint</a>(icm, &amp;cmpara, xcm, &amp;weightcm);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798     <span class="keywordflow">for</span> (iang=0; iang&lt;nang; iang++) {
<a name="l00799"></a>00799       <a class="code" href="angprojection_8c.html#a84c53149d9af0a652cb6486c9516cbb5">getangintegrationpoint</a>(iang, &amp;angpara, &amp;alpha, &amp;beta, &amp;gamma, &amp;weightang);
<a name="l00800"></a>00800       <span class="comment">// weight = 1.0/(2*norm*normp)*weightcm*weightang;</span>
<a name="l00801"></a>00801       weight = 0.5*weightcm*weightang;
<a name="l00802"></a>00802       
<a name="l00803"></a>00803       <a class="code" href="SlaterDet_8c.html#acd974ea424b0829a55ada79fc69abd90">copySlaterDet</a>(Qp, &amp;Qpp);
<a name="l00804"></a>00804       <a class="code" href="SlaterDet_8c.html#a5463a8afc7565b2711169b605aad5ca3" title="move Slater determinant by vector d">moveSlaterDet</a>(&amp;Qpp, xcm);
<a name="l00805"></a>00805       <a class="code" href="SlaterDet_8c.html#a8737af9032a8d87843782a88228fef00" title="rotate Slater determinant by euler angles">rotateSlaterDet</a>(&amp;Qpp, alpha, beta, gamma);
<a name="l00806"></a>00806 
<a name="l00807"></a>00807       <span class="keywordflow">for</span> (ip=0; ip&lt;=1; ip++) {
<a name="l00808"></a>00808           <span class="keywordflow">if</span> (ip) <a class="code" href="SlaterDet_8c.html#ad0aa11be18d42c1cc26c2ad1380feb2a" title="invert Slater determinant in origin">invertSlaterDet</a>(&amp;Qpp);
<a name="l00809"></a>00809 
<a name="l00810"></a>00810           <span class="comment">// can only calculate Auxilliaries if Sldets are compatible</span>
<a name="l00811"></a>00811           <span class="keywordflow">if</span> (Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> == Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>) {
<a name="l00812"></a>00812             <span class="keywordflow">if</span> (Q-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> == Qp-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> &amp;&amp; Q-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a> == Qp-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>)
<a name="l00813"></a>00813               <a class="code" href="SlaterDet_8c.html#ad3679a655d9b6019619456e5b7961638">calcSlaterDetAuxod</a>(Q, &amp;Qpp, &amp;X);
<a name="l00814"></a>00814             <span class="keywordflow">else</span>
<a name="l00815"></a>00815               <a class="code" href="SlaterDet_8c.html#a861e4c675c3918393d69a81090376053">calcSlaterDetAuxodsingular</a>(Q, &amp;Qpp, &amp;X);
<a name="l00816"></a>00816           }
<a name="l00817"></a>00817           Ops-&gt;<a class="code" href="structManyBodyOperators.html#aed28a6d83fca31b2794173c96dd2d769">me</a>(Ops-&gt;<a class="code" href="structManyBodyOperators.html#a63b81b5a508a075fd10b76ebd219094f" title="the same for all operators">par</a>, Q, &amp;Qpp, &amp;X, sval);
<a name="l00818"></a>00818 
<a name="l00819"></a>00819           complex <span class="keywordtype">double</span> w;
<a name="l00820"></a>00820           <span class="keywordflow">for</span> (o=0; o&lt;Ops-&gt;<a class="code" href="structManyBodyOperators.html#ab95444d93053e68e632c2ca2948b6177" title="number of operators">n</a>; o++)
<a name="l00821"></a>00821             <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00822"></a>00822               <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2)
<a name="l00823"></a>00823                 <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00824"></a>00824                   <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2) {
<a name="l00825"></a>00825                     <span class="keywordflow">if</span> ((ranko[o] != 0 || <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(S, p, j, m)) &amp;&amp;
<a name="l00826"></a>00826                         <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sp, p, j, k)) {
<a name="l00827"></a>00827                       w = weight * (p &amp;&amp; ip%2 ? -1 : 1)*
<a name="l00828"></a>00828                         (j+1)/(8*<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(M_PI))*Djmkstar(j,m,k,alpha,beta,gamma);
<a name="l00829"></a>00829                       <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00830"></a>00830                         <span class="keywordflow">for</span> (r=0; r&lt;=ranko[o]; r++)
<a name="l00831"></a>00831                           val[o][idxpij(jmax,p,j)][r+l*(ranko[o]+1)+idxjmk(j,m,k)*sizeo[o]] += 
<a name="l00832"></a>00832                             w*sval[r+l*(ranko[o]+1)+io[o]];
<a name="l00833"></a>00833                   }     
<a name="l00834"></a>00834                 }       
<a name="l00835"></a>00835       }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   }     
<a name="l00840"></a>00840   <a class="code" href="SlaterDet_8c.html#a6d10ca2b062d871a6903292600c3125a" title="free memory used by SlaterDetAux X">freeSlaterDetAux</a>(&amp;X);
<a name="l00841"></a>00841   <a class="code" href="SlaterDet_8c.html#adc279637790bc3303e9dca688966a7ab" title="free memory used by Slater determinant Q">freeSlaterDet</a>(&amp;Qpp);
<a name="l00842"></a>00842 }       
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 
<a name="l00845"></a><a class="code" href="Projection_8h.html#a769abddc6e28e099e9725712b7ed2104">00845</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a769abddc6e28e099e9725712b7ed2104">hermitizeprojectedMBME</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00846"></a>00846                             <span class="keywordtype">void</span>* mbme, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l00847"></a>00847 {
<a name="l00848"></a>00848   <span class="keywordtype">int</span> size=Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l00849"></a>00849   <span class="keywordtype">int</span> rank=Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00850"></a>00850   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l00851"></a>00851   complex double (***<a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>)[(rank+1)*size] = mbme;
<a name="l00852"></a>00852 
<a name="l00853"></a>00853   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00854"></a>00854   <span class="keywordtype">int</span> odd = P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>;
<a name="l00857"></a>00857   <span class="keywordtype">int</span> a,b;
<a name="l00858"></a>00858   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, r;
<a name="l00859"></a>00859 
<a name="l00860"></a>00860   complex <span class="keywordtype">double</span> valu, vall;
<a name="l00861"></a>00861 
<a name="l00862"></a>00862   <span class="comment">// hermitize matrix elements</span>
<a name="l00863"></a>00863   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00864"></a>00864     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2)
<a name="l00865"></a>00865       <span class="keywordflow">for</span> (b=0; b&lt;n; b++)
<a name="l00866"></a>00866         <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00867"></a>00867           <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l00868"></a>00868             <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2)
<a name="l00869"></a>00869               <span class="keywordflow">for</span> (l=0; l&lt;dim; l++) 
<a name="l00870"></a>00870                 <span class="keywordflow">for</span> (r=0; r&lt;=rank+1; r++) {
<a name="l00871"></a>00871                   valu = <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[a+b*n][idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)];
<a name="l00872"></a>00872                   vall = <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[b+a*n][idxpij(jmax,p,j)][idxjmk(j,k,m)][r+l*(rank+1)];
<a name="l00873"></a>00873                   <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[a+b*n][idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)] = 0.5*(valu+conj(vall));
<a name="l00874"></a>00874                   <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[b+a*n][idxpij(jmax,p,j)][idxjmk(j,k,m)][r+l*(rank+1)] = 0.5*(conj(valu)+vall);
<a name="l00875"></a>00875               }
<a name="l00876"></a>00876 }    
<a name="l00877"></a>00877 
<a name="l00878"></a>00878 <span class="comment">// calculates reduced matrix element divided by sqrt(2j+1)</span>
<a name="l00879"></a>00879 
<a name="l00880"></a><a class="code" href="Projection_8h.html#a8496ec48cbc243bb807deeb60339a251">00880</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a8496ec48cbc243bb807deeb60339a251">calcexpectprojectedMBME</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00881"></a>00881                              <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00882"></a>00882                              <span class="keyword">const</span> <span class="keywordtype">void</span>* mbme,
<a name="l00883"></a>00883                              <span class="keyword">const</span> <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a>* S,
<a name="l00884"></a>00884                              <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E,
<a name="l00885"></a>00885                              <span class="keywordtype">void</span>* expectmbme)
<a name="l00886"></a>00886 {
<a name="l00887"></a>00887   <span class="keywordtype">int</span> p,<a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>,i;
<a name="l00888"></a>00888   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, k1, k2;
<a name="l00889"></a>00889   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, nu;
<a name="l00890"></a>00890   <span class="keywordtype">int</span> a, b;
<a name="l00891"></a>00891   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=E-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l00892"></a>00892   <span class="keywordtype">int</span> idx;
<a name="l00893"></a>00893   <span class="keywordtype">int</span> nj;
<a name="l00894"></a>00894   <span class="keywordtype">int</span> rank=Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00895"></a>00895   <span class="keywordtype">int</span> size=Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l00896"></a>00896   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l00897"></a>00897   <span class="keywordtype">int</span> odd=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00898"></a>00898   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00899"></a>00899   complex double (***me)[(rank+1)*size] = mbme;
<a name="l00900"></a>00900   complex double (**expme)[size] = expectmbme;
<a name="l00901"></a>00901  
<a name="l00902"></a>00902   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00903"></a>00903     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00904"></a>00904 
<a name="l00905"></a>00905       idx = idxpij(jmax,p,j);
<a name="l00906"></a>00906       nj=n*(j+1);
<a name="l00907"></a>00907       <span class="keywordflow">for</span> (i=0; i&lt;E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idx]; i++) {
<a name="l00908"></a>00908 
<a name="l00909"></a>00909         <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00910"></a>00910           expme[idx][i][l] = 0.0;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912         <span class="keywordflow">for</span> (b=0; b&lt;n; b++)
<a name="l00913"></a>00913           <span class="keywordflow">for</span> (k2=-j; k2&lt;=j; k2=k2+2)
<a name="l00914"></a>00914             <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l00915"></a>00915               <span class="keywordflow">for</span> (k1=-j; k1&lt;=j; k1=k1+2)           
<a name="l00916"></a>00916                 <span class="keywordflow">for</span> (k=max(-j,k1-rank); k&lt;=min(j,k1+rank); k=k+2) {
<a name="l00917"></a>00917                   nu=k1-k;
<a name="l00918"></a>00918                   <span class="keywordflow">if</span> (<a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(S[a], p, j, k1) &amp;&amp;
<a name="l00919"></a>00919                       <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(S[b], p, j, k2)) {
<a name="l00920"></a>00920                     <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00921"></a>00921                       expme[idx][i][l] +=
<a name="l00922"></a>00922                         <a class="code" href="clebsch_8c.html#a7b75250723cf843449ee508426c81537">clebsch</a>(j, rank, j, k, nu, k1)*
<a name="l00923"></a>00923                         conj(E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idx][idxnjm(a,j,k1) + i*nj])*
<a name="l00924"></a>00924                         me[a+b*n][idx][idxjmk(j,k,k2)][(nu+rank)/2+l*(rank+1)]*
<a name="l00925"></a>00925                         E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idx][idxnjm(b,j,k2) + i*nj];
<a name="l00926"></a>00926                   }
<a name="l00927"></a>00927                 }
<a name="l00928"></a>00928       }         
<a name="l00929"></a>00929     }           
<a name="l00930"></a>00930 }
<a name="l00931"></a>00931 
<a name="l00932"></a>00932 <span class="comment">// calculate the expectation value only for a selected state</span>
<a name="l00933"></a><a class="code" href="Projection_8h.html#a0aba2ec1c91bc314f7d6dd6529608050">00933</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a0aba2ec1c91bc314f7d6dd6529608050">calcexpectprojectedMBMEipj</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00934"></a>00934                                 <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00935"></a>00935                                 <span class="keyword">const</span> <span class="keywordtype">void</span>* mbme,
<a name="l00936"></a>00936                                 <span class="keyword">const</span> <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a>* S,
<a name="l00937"></a>00937                                 <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E,
<a name="l00938"></a>00938                                 <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> i,
<a name="l00939"></a>00939                                 <span class="keywordtype">void</span>* expectmbme)
<a name="l00940"></a>00940 {
<a name="l00941"></a>00941   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, k1, k2;
<a name="l00942"></a>00942   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, nu;
<a name="l00943"></a>00943   <span class="keywordtype">int</span> a, b;
<a name="l00944"></a>00944   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=E-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l00945"></a>00945   <span class="keywordtype">int</span> idx;
<a name="l00946"></a>00946   <span class="keywordtype">int</span> ii;
<a name="l00947"></a>00947   <span class="keywordtype">int</span> nj;
<a name="l00948"></a>00948   <span class="keywordtype">int</span> rank=Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00949"></a>00949   <span class="keywordtype">int</span> size=Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l00950"></a>00950   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l00951"></a>00951   <span class="keywordtype">int</span> odd=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00952"></a>00952   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00953"></a>00953   complex double (***me)[(rank+1)*size] = mbme;
<a name="l00954"></a>00954   complex double (**expme)[size] = expectmbme;
<a name="l00955"></a>00955  
<a name="l00956"></a>00956   idx = idxpij(jmax,p,j);
<a name="l00957"></a>00957   ii = E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[idx][i];
<a name="l00958"></a>00958   nj=n*(j+1);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960   <span class="comment">// allocate space for expectation values</span>
<a name="l00961"></a>00961   expme[idx] = malloc(nj*size*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00964"></a>00964     expme[idx][ii][l] = 0.0;
<a name="l00965"></a>00965 
<a name="l00966"></a>00966   <span class="keywordflow">for</span> (b=0; b&lt;n; b++)
<a name="l00967"></a>00967     <span class="keywordflow">for</span> (k2=-j; k2&lt;=j; k2=k2+2)
<a name="l00968"></a>00968       <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l00969"></a>00969         <span class="keywordflow">for</span> (k1=-j; k1&lt;=j; k1=k1+2)         
<a name="l00970"></a>00970           <span class="keywordflow">for</span> (k=max(-j,k1-rank); k&lt;=min(j,k1+rank); k=k+2) {
<a name="l00971"></a>00971             nu=k1-k;
<a name="l00972"></a>00972             <span class="keywordflow">if</span> (<a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(S[a], p, j, k1) &amp;&amp;
<a name="l00973"></a>00973                 <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(S[b], p, j, k2)) {
<a name="l00974"></a>00974               <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00975"></a>00975                 expme[idx][ii][l] +=
<a name="l00976"></a>00976                   <a class="code" href="clebsch_8c.html#a7b75250723cf843449ee508426c81537">clebsch</a>(j, rank, j, k, nu, k1)*
<a name="l00977"></a>00977                   conj(E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idx][idxnjm(a,j,k1) + ii*nj])*
<a name="l00978"></a>00978                   me[a+b*n][idx][idxjmk(j,k,k2)][(nu+rank)/2+l*(rank+1)]*
<a name="l00979"></a>00979                   E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idx][idxnjm(b,j,k2) + ii*nj];
<a name="l00980"></a>00980             }
<a name="l00981"></a>00981           }
<a name="l00982"></a>00982 }
<a name="l00983"></a>00983 
<a name="l00984"></a>00984 
<a name="l00985"></a>00985 <span class="comment">// calculate transition matrix elements for Eigenstates Efin &lt;- Eini</span>
<a name="l00986"></a>00986 
<a name="l00987"></a>00987 <span class="comment">// calculates reduced matrix element divided by sqrt(2jfin+1)</span>
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="comment">// slow but transparent</span>
<a name="l00990"></a>00990 <span class="comment">/*</span>
<a name="l00991"></a>00991 <span class="comment">void calctransitionprojectedMBME(const Projection* P,</span>
<a name="l00992"></a>00992 <span class="comment">                                 const ManyBodyOperator* Op,</span>
<a name="l00993"></a>00993 <span class="comment">                                 const void* mbme,</span>
<a name="l00994"></a>00994 <span class="comment">                                 const Symmetry* Sfin,</span>
<a name="l00995"></a>00995 <span class="comment">                                 const Symmetry* Sini,</span>
<a name="l00996"></a>00996 <span class="comment">                                 const Eigenstates* Efin,</span>
<a name="l00997"></a>00997 <span class="comment">                                 const Eigenstates* Eini,</span>
<a name="l00998"></a>00998 <span class="comment">                                 void* transmbme)</span>
<a name="l00999"></a>00999 <span class="comment">{       </span>
<a name="l01000"></a>01000 <span class="comment">  int pini,jini,iini, pfin,jfin,ifin;</span>
<a name="l01001"></a>01001 <span class="comment">  int k, kfin, kini;</span>
<a name="l01002"></a>01002 <span class="comment">  int l, nu;</span>
<a name="l01003"></a>01003 <span class="comment">  int afin, aini;</span>
<a name="l01004"></a>01004 <span class="comment">  int nfin=Efin-&gt;n;</span>
<a name="l01005"></a>01005 <span class="comment">  int nini=Eini-&gt;n;</span>
<a name="l01006"></a>01006 <span class="comment">  int njini, njfin;</span>
<a name="l01007"></a>01007 <span class="comment">  int idxini, idxfin;</span>
<a name="l01008"></a>01008 <span class="comment">  int p=Op-&gt;pi;</span>
<a name="l01009"></a>01009 <span class="comment">  int size=Op-&gt;size;</span>
<a name="l01010"></a>01010 <span class="comment">  int dim=Op-&gt;dim;</span>
<a name="l01011"></a>01011 <span class="comment">  int rank=Op-&gt;rank;</span>
<a name="l01012"></a>01012 <span class="comment">  int oddini=P-&gt;odd;</span>
<a name="l01013"></a>01013 <span class="comment">  int jmax=P-&gt;jmax;</span>
<a name="l01014"></a>01014 <span class="comment">  complex double (***me)[(rank+1)*size] = mbme;</span>
<a name="l01015"></a>01015 <span class="comment">  complex double (****transme)[size] = transmbme;</span>
<a name="l01016"></a>01016 <span class="comment"></span>
<a name="l01017"></a>01017 <span class="comment">  for (pini=0; pini&lt;=1; pini++)</span>
<a name="l01018"></a>01018 <span class="comment">    for (jini=oddini; jini&lt;jmax; jini=jini+2) {</span>
<a name="l01019"></a>01019 <span class="comment">      </span>
<a name="l01020"></a>01020 <span class="comment">      idxini = idxpij(jmax,pini,jini);</span>
<a name="l01021"></a>01021 <span class="comment">      njini=nini*(jini+1);</span>
<a name="l01022"></a>01022 <span class="comment"></span>
<a name="l01023"></a>01023 <span class="comment">      pfin=(pini+p)%2;</span>
<a name="l01024"></a>01024 <span class="comment">      for (jfin=abs(jini-rank); jfin&lt;=min(jmax-1,jini+rank); jfin=jfin+2) {</span>
<a name="l01025"></a>01025 <span class="comment"></span>
<a name="l01026"></a>01026 <span class="comment">        idxfin = idxpij(jmax,pfin,jfin);</span>
<a name="l01027"></a>01027 <span class="comment">        njfin=nfin*(jfin+1);</span>
<a name="l01028"></a>01028 <span class="comment">        for (iini=0; iini&lt;Eini-&gt;dim[idxini]; iini++)</span>
<a name="l01029"></a>01029 <span class="comment">          for (ifin=0; ifin&lt;Efin-&gt;dim[idxfin]; ifin++) {</span>
<a name="l01030"></a>01030 <span class="comment"></span>
<a name="l01031"></a>01031 <span class="comment">            for (l=0; l&lt;dim; l++)</span>
<a name="l01032"></a>01032 <span class="comment">              transme[idxfin][idxini][ifin][iini][l] = 0.0;</span>
<a name="l01033"></a>01033 <span class="comment"></span>
<a name="l01034"></a>01034 <span class="comment">            for (aini=0; aini&lt;nini; aini++)</span>
<a name="l01035"></a>01035 <span class="comment">              for (kini=-jini; kini&lt;=jini; kini=kini+2)</span>
<a name="l01036"></a>01036 <span class="comment">                for (afin=0; afin&lt;nfin; afin++)</span>
<a name="l01037"></a>01037 <span class="comment">                  for (kfin=-jfin; kfin&lt;=jfin; kfin=kfin+2)</span>
<a name="l01038"></a>01038 <span class="comment">                    for (k=max(-jini,kfin-rank); k&lt;=min(jini,kfin+rank); k=k+2) {</span>
<a name="l01039"></a>01039 <span class="comment">                      nu = kfin-k;</span>
<a name="l01040"></a>01040 <span class="comment">                      if (SymmetryAllowed(Sfin[afin], pfin, jfin, kfin) &amp;&amp;</span>
<a name="l01041"></a>01041 <span class="comment">                          SymmetryAllowed(Sini[aini], pini, jini, kini)) {</span>
<a name="l01042"></a>01042 <span class="comment">                        for (l=0; l&lt;dim; l++)</span>
<a name="l01043"></a>01043 <span class="comment">                          transme[idxfin][idxini][ifin][iini][l] +=</span>
<a name="l01044"></a>01044 <span class="comment">                            clebsch(jini, rank, jfin, k, nu, kfin)*</span>
<a name="l01045"></a>01045 <span class="comment">                            conj(Efin-&gt;V[idxfin][idxnjm(afin,jfin,kfin) + ifin*njfin])*</span>
<a name="l01046"></a>01046 <span class="comment">                            me[afin+aini*nfin][idxini][idxjmk(jini,k,kini)][(nu+rank)/2+l*(rank+1)]*</span>
<a name="l01047"></a>01047 <span class="comment"></span>
<a name="l01048"></a>01048 <span class="comment">                            Eini-&gt;V[idxini][idxnjm(aini,jini,kini) + iini*njini];</span>
<a name="l01049"></a>01049 <span class="comment">                      }</span>
<a name="l01050"></a>01050 <span class="comment">                    }</span>
<a name="l01051"></a>01051 <span class="comment">          }</span>
<a name="l01052"></a>01052 <span class="comment">      }                 </span>
<a name="l01053"></a>01053 <span class="comment">    }</span>
<a name="l01054"></a>01054 <span class="comment">}       </span>
<a name="l01055"></a>01055 <span class="comment">*/</span>
<a name="l01056"></a>01056 
<a name="l01057"></a>01057 
<a name="l01058"></a>01058 <span class="comment">// much faster, calculate first product of matrix elements with initial vectors</span>
<a name="l01059"></a>01059 <span class="comment">// then product with final vectors in a second step</span>
<a name="l01060"></a><a class="code" href="Projection_8h.html#a54006a58b4e31d612773ec5019bd79ef">01060</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a217dcaf1dd9b24f77026d270b3203f4d">calctransitionprojectedMBME</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01061"></a>01061                                  <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l01062"></a>01062                                  <span class="keyword">const</span> <span class="keywordtype">void</span>* mbme,
<a name="l01063"></a>01063                                  <span class="keyword">const</span> <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a>* Sfin,
<a name="l01064"></a>01064                                  <span class="keyword">const</span> <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a>* Sini,
<a name="l01065"></a>01065                                  <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Efin,
<a name="l01066"></a>01066                                  <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Eini,
<a name="l01067"></a>01067                                  <span class="keywordtype">void</span>* transmbme)
<a name="l01068"></a>01068 {       
<a name="l01069"></a>01069   <span class="keywordtype">int</span> pini,jini,iini, pfin,jfin,ifin;
<a name="l01070"></a>01070   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, kfin, kini;
<a name="l01071"></a>01071   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, nu;
<a name="l01072"></a>01072   <span class="keywordtype">int</span> afin, aini;
<a name="l01073"></a>01073   <span class="keywordtype">int</span> nfin=Efin-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l01074"></a>01074   <span class="keywordtype">int</span> nini=Eini-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l01075"></a>01075   <span class="keywordtype">int</span> njini, njfin;
<a name="l01076"></a>01076   <span class="keywordtype">int</span> idxini, idxfin;
<a name="l01077"></a>01077   <span class="keywordtype">int</span> p=Op-&gt;<a class="code" href="structManyBodyOperator.html#a78ec7c9f2238907255cf499427676907" title="parity of operator, 0 positve, 1 negative">pi</a>;
<a name="l01078"></a>01078   <span class="keywordtype">int</span> size=Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l01079"></a>01079   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l01080"></a>01080   <span class="keywordtype">int</span> rank=Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l01081"></a>01081   <span class="keywordtype">int</span> oddini=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l01082"></a>01082   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l01083"></a>01083   complex double (***me)[(rank+1)*size] = mbme;
<a name="l01084"></a>01084   complex double (****transme)[size] = transmbme;
<a name="l01085"></a>01085 
<a name="l01086"></a>01086   complex <span class="keywordtype">double</span>* meVwork = malloc(nfin*nini*(jmax+1)*(jmax+1)*size*(rank+1)*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01087"></a>01087 
<a name="l01088"></a>01088   <span class="keywordflow">for</span> (pini=0; pini&lt;=1; pini++)
<a name="l01089"></a>01089     <span class="keywordflow">for</span> (jini=oddini; jini&lt;jmax; jini=jini+2) {
<a name="l01090"></a>01090       
<a name="l01091"></a>01091       idxini = idxpij(jmax,pini,jini);
<a name="l01092"></a>01092       njini=nini*(jini+1);
<a name="l01093"></a>01093 
<a name="l01094"></a>01094       pfin=(pini+p)%2;
<a name="l01095"></a>01095       <span class="keywordflow">for</span> (jfin=abs(jini-rank); jfin&lt;=min(jmax-1,jini+rank); jfin=jfin+2) {
<a name="l01096"></a>01096 
<a name="l01097"></a>01097         idxfin = idxpij(jmax,pfin,jfin);
<a name="l01098"></a>01098         njfin=nfin*(jfin+1);
<a name="l01099"></a>01099 
<a name="l01100"></a>01100         complex double (*meV)[nini*(jini+1)][(jini+1)][size*(rank+1)] = meVwork;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102         <span class="keywordflow">for</span> (iini=0; iini&lt;Eini-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxini]; iini++)
<a name="l01103"></a>01103           <span class="keywordflow">for</span> (afin=0; afin&lt;nfin; afin++)
<a name="l01104"></a>01104             <span class="keywordflow">for</span> (k=-jini; k&lt;=jini; k=k+2)
<a name="l01105"></a>01105               <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l01106"></a>01106                 <span class="keywordflow">for</span> (nu=-rank; nu&lt;=rank; nu=nu+2)
<a name="l01107"></a>01107                   meV[afin][iini][idxjm(jini,k)][(nu+rank)/2+l*(rank+1)] = 0.0;
<a name="l01108"></a>01108 
<a name="l01109"></a>01109         <span class="keywordflow">for</span> (iini=0; iini&lt;Eini-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxini]; iini++)
<a name="l01110"></a>01110           <span class="keywordflow">for</span> (afin=0; afin&lt;nfin; afin++)
<a name="l01111"></a>01111             <span class="keywordflow">for</span> (k=-jini; k&lt;=jini; k=k+2)
<a name="l01112"></a>01112               <span class="keywordflow">for</span> (aini=0; aini&lt;nini; aini++)
<a name="l01113"></a>01113                 <span class="keywordflow">for</span> (kini=-jini; kini&lt;=jini; kini=kini+2)
<a name="l01114"></a>01114                   <span class="keywordflow">if</span> (<a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sini[aini], pini, jini, kini)) {
<a name="l01115"></a>01115               
<a name="l01116"></a>01116                     <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l01117"></a>01117                       <span class="keywordflow">for</span> (nu=-rank; nu&lt;=rank; nu=nu+2)
<a name="l01118"></a>01118                         meV[afin][iini][idxjm(jini,k)][(nu+rank)/2+l*(rank+1)] +=
<a name="l01119"></a>01119                           me[afin+aini*nfin][idxini][idxjmk(jini,k,kini)][(nu+rank)/2+l*(rank+1)]*
<a name="l01120"></a>01120 
<a name="l01121"></a>01121                           Eini-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idxini][idxnjm(aini,jini,kini) + iini*njini];
<a name="l01122"></a>01122                   }
<a name="l01123"></a>01123 
<a name="l01124"></a>01124 
<a name="l01125"></a>01125         <span class="keywordflow">for</span> (iini=0; iini&lt;Eini-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxini]; iini++)
<a name="l01126"></a>01126           <span class="keywordflow">for</span> (ifin=0; ifin&lt;Efin-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxfin]; ifin++) {
<a name="l01127"></a>01127 
<a name="l01128"></a>01128             <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l01129"></a>01129               transme[idxfin][idxini][ifin][iini][l] = 0.0;
<a name="l01130"></a>01130 
<a name="l01131"></a>01131             <span class="keywordflow">for</span> (afin=0; afin&lt;nfin; afin++)
<a name="l01132"></a>01132               <span class="keywordflow">for</span> (kfin=-jfin; kfin&lt;=jfin; kfin=kfin+2)
<a name="l01133"></a>01133                 <span class="keywordflow">for</span> (k=max(-jini,kfin-rank); k&lt;=min(jini,kfin+rank); k=k+2) {
<a name="l01134"></a>01134                   nu = kfin-k;
<a name="l01135"></a>01135                   <span class="keywordflow">if</span> (<a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sfin[afin], pfin, jfin, kfin)) {
<a name="l01136"></a>01136                     <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l01137"></a>01137                       transme[idxfin][idxini][ifin][iini][l] +=
<a name="l01138"></a>01138                         <a class="code" href="clebsch_8c.html#a7b75250723cf843449ee508426c81537">clebsch</a>(jini, rank, jfin, k, nu, kfin)*
<a name="l01139"></a>01139                         conj(Efin-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idxfin][idxnjm(afin,jfin,kfin) + ifin*njfin])*
<a name="l01140"></a>01140                         meV[afin][iini][idxjm(jini,k)][(nu+rank)/2+l*(rank+1)];
<a name="l01141"></a>01141                   }
<a name="l01142"></a>01142                 }
<a name="l01143"></a>01143           }     
<a name="l01144"></a>01144       }                 
<a name="l01145"></a>01145     }
<a name="l01146"></a>01146   
<a name="l01147"></a>01147   free(meVwork);
<a name="l01148"></a>01148 }       
<a name="l01149"></a>01149 
<a name="l01150"></a>01150 
<a name="l01151"></a><a class="code" href="Projection_8h.html#a00b2cd7ac851155cf70fc58d1cc3ab16">01151</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a9ac53216b1672c1bf051d6070442e259">calctransitionprojectedMBMEipj</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01152"></a>01152                                     <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l01153"></a>01153                                     <span class="keyword">const</span> <span class="keywordtype">void</span>* mbme,
<a name="l01154"></a>01154                                     <span class="keyword">const</span> <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a>* Sfin,
<a name="l01155"></a>01155                                     <span class="keyword">const</span> <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a>* Sini,
<a name="l01156"></a>01156                                     <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Efin,
<a name="l01157"></a>01157                                     <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Eini,
<a name="l01158"></a>01158                                     <span class="keywordtype">int</span> jfin, <span class="keywordtype">int</span> pfin, <span class="keywordtype">int</span> ifin,
<a name="l01159"></a>01159                                     <span class="keywordtype">int</span> jini, <span class="keywordtype">int</span> pini, <span class="keywordtype">int</span> iini,
<a name="l01160"></a>01160                                     <span class="keywordtype">void</span>* transmbme)
<a name="l01161"></a>01161 {       
<a name="l01162"></a>01162   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, kfin, kini;
<a name="l01163"></a>01163   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, nu;
<a name="l01164"></a>01164   <span class="keywordtype">int</span> afin, aini;
<a name="l01165"></a>01165   <span class="keywordtype">int</span> nfin=Efin-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l01166"></a>01166   <span class="keywordtype">int</span> nini=Eini-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l01167"></a>01167   <span class="keywordtype">int</span> njini, njfin;
<a name="l01168"></a>01168   <span class="keywordtype">int</span> idxini, idxfin;
<a name="l01169"></a>01169   <span class="keywordtype">int</span> iiini, iifin;
<a name="l01170"></a>01170   <span class="keywordtype">int</span> p=Op-&gt;<a class="code" href="structManyBodyOperator.html#a78ec7c9f2238907255cf499427676907" title="parity of operator, 0 positve, 1 negative">pi</a>;
<a name="l01171"></a>01171   <span class="keywordtype">int</span> size=Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l01172"></a>01172   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l01173"></a>01173   <span class="keywordtype">int</span> rank=Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l01174"></a>01174   <span class="keywordtype">int</span> oddini=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l01175"></a>01175   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l01176"></a>01176   complex double (***me)[(rank+1)*size] = mbme;
<a name="l01177"></a>01177   complex double (****transme)[size] = transmbme;
<a name="l01178"></a>01178 
<a name="l01179"></a>01179   idxini = idxpij(jmax,pini,jini);
<a name="l01180"></a>01180   iiini = Eini-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[idxini][iini];
<a name="l01181"></a>01181   njini=nini*(jini+1);
<a name="l01182"></a>01182 
<a name="l01183"></a>01183   idxfin = idxpij(jmax,pfin,jfin);
<a name="l01184"></a>01184   iifin = Efin-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[idxfin][ifin];
<a name="l01185"></a>01185   njfin=nfin*(jfin+1);
<a name="l01186"></a>01186 
<a name="l01187"></a>01187   <span class="comment">// allocate space for transition matrix elements</span>
<a name="l01188"></a>01188   transme[idxfin][idxini][iifin] = malloc(njini*size*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01189"></a>01189 
<a name="l01190"></a>01190   <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l01191"></a>01191     transme[idxfin][idxini][iifin][iiini][l] = 0.0;
<a name="l01192"></a>01192 
<a name="l01193"></a>01193   <span class="keywordflow">for</span> (aini=0; aini&lt;nini; aini++)
<a name="l01194"></a>01194     <span class="keywordflow">for</span> (kini=-jini; kini&lt;=jini; kini=kini+2)
<a name="l01195"></a>01195       <span class="keywordflow">for</span> (afin=0; afin&lt;nfin; afin++)
<a name="l01196"></a>01196         <span class="keywordflow">for</span> (kfin=-jfin; kfin&lt;=jfin; kfin=kfin+2)
<a name="l01197"></a>01197           <span class="keywordflow">for</span> (k=max(-jini,kfin-rank); k&lt;=min(jini,kfin+rank); k=k+2) {
<a name="l01198"></a>01198             nu = kfin-k;
<a name="l01199"></a>01199             <span class="keywordflow">if</span> (<a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sfin[afin], pfin, jfin, kfin) &amp;&amp;
<a name="l01200"></a>01200                 <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sini[aini], pini, jini, kini)) {
<a name="l01201"></a>01201               <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l01202"></a>01202                 transme[idxfin][idxini][iifin][iiini][l] +=
<a name="l01203"></a>01203                   <a class="code" href="clebsch_8c.html#a7b75250723cf843449ee508426c81537">clebsch</a>(jini, rank, jfin, k, nu, kfin)*
<a name="l01204"></a>01204                   conj(Efin-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idxfin][idxnjm(afin,jfin,kfin) + iifin*njfin])*
<a name="l01205"></a>01205                   me[afin+aini*nfin][idxini][idxjmk(jini,k,kini)][(nu+rank)/2+l*(rank+1)]*
<a name="l01206"></a>01206                   Eini-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idxini][idxnjm(aini,jini,kini) + iiini*njini];
<a name="l01207"></a>01207             }
<a name="l01208"></a>01208           }
<a name="l01209"></a>01209 }       
<a name="l01210"></a>01210 
<a name="l01211"></a>01211 
<a name="l01212"></a><a class="code" href="Projection_8h.html#a9be2f82e183827f27b5edbefcb794740">01212</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a9be2f82e183827f27b5edbefcb794740">initEigenstates</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l01213"></a>01213 {
<a name="l01214"></a>01214   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l01215"></a>01215 
<a name="l01216"></a>01216   E-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a> = n;
<a name="l01217"></a>01217 
<a name="l01218"></a>01218   E-&gt;<a class="code" href="structEigenstates.html#ade09c5713d0d08f69ed61126f1c8d075" title="energy eigenvalues">v</a> = <a class="code" href="Projection_8c.html#a84110f2d4600522fbbd3d392ccb28fce">initprojectedvector</a>(P, <span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>), n);
<a name="l01219"></a>01219   E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a> = <a class="code" href="Projection_8c.html#abb5a41706e33979ad3bdc5f7f03f301e">initprojectedmatrix</a>(P, <span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>), n);
<a name="l01220"></a>01220   E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a> = <a class="code" href="Projection_8c.html#a84110f2d4600522fbbd3d392ccb28fce">initprojectedvector</a>(P, <span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>), n);
<a name="l01221"></a>01221   E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a> = malloc((jmax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01222"></a>01222   E-&gt;<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a> = malloc((jmax+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l01223"></a>01223   E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a> = <a class="code" href="Projection_8c.html#a84110f2d4600522fbbd3d392ccb28fce">initprojectedvector</a>(P, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), n);
<a name="l01224"></a>01224 }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226 
<a name="l01227"></a><a class="code" href="Projection_8h.html#a24150e1691aa16292612bec682cca3ae">01227</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a24150e1691aa16292612bec682cca3ae">initAmplitudes</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <a class="code" href="structAmplitudes.html">Amplitudes</a>* A, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l01228"></a>01228 {
<a name="l01229"></a>01229   A-&gt;<a class="code" href="structAmplitudes.html#aeb28e7c61eb781e59b43e00dabb8bf79">n</a> = n;
<a name="l01230"></a>01230   A-&gt;<a class="code" href="structAmplitudes.html#a3192b8e5338e5ac43d813833b09ad221">ngood</a> = <a class="code" href="Projection_8c.html#a84110f2d4600522fbbd3d392ccb28fce">initprojectedvector</a>(P, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), n);
<a name="l01231"></a>01231   A-&gt;<a class="code" href="structAmplitudes.html#a1608d319a33b0263e17f0ac70993cce2">amp</a> = <a class="code" href="Projection_8c.html#abb5a41706e33979ad3bdc5f7f03f301e">initprojectedmatrix</a>(P, <span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>), n);
<a name="l01232"></a>01232 }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 
<a name="l01235"></a><a class="code" href="Projection_8h.html#ae1d7e6ab780b680233363090cdb2764f">01235</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#ae1d7e6ab780b680233363090cdb2764f">calcEigenstates</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01236"></a>01236                      <span class="keyword">const</span> <a class="code" href="structInteraction.html">Interaction</a>* <a class="code" href="MinimizerDONLP2_8c.html#ae051dcd567638cf29379a3fec796679c">Int</a>,
<a name="l01237"></a>01237                      <span class="keyword">const</span> <a class="code" href="structObservablesod.html">Observablesod</a> ***obsme, 
<a name="l01238"></a>01238                      <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E, <span class="keywordtype">double</span> thresh)
<a name="l01239"></a>01239 {
<a name="l01240"></a>01240   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> = E-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l01241"></a>01241   <span class="keywordtype">int</span> odd = P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l01242"></a>01242   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l01243"></a>01243 
<a name="l01244"></a>01244   complex <span class="keywordtype">double</span>* <a class="code" href="md5_8c.html#ae42219072d798876e6b08e6b78614ff6">H</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(n*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01245"></a>01245   complex <span class="keywordtype">double</span>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#afa106e3c58721409e0e2c7ae6980cf25">N</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(n*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01246"></a>01246   complex <span class="keywordtype">double</span>* N2 = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(n*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01247"></a>01247 
<a name="l01248"></a>01248   <span class="keywordtype">int</span> a, b;
<a name="l01249"></a>01249   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, i;
<a name="l01250"></a>01250   <span class="keywordtype">int</span> nj, ipj;
<a name="l01251"></a>01251 
<a name="l01252"></a>01252   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l01253"></a>01253     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l01254"></a>01254 
<a name="l01255"></a>01255       nj = n*(j+1);
<a name="l01256"></a>01256       ipj = idxpij(jmax,p,j);
<a name="l01257"></a>01257 
<a name="l01258"></a>01258       <span class="keywordflow">for</span> (b=0; b&lt;n; b++)
<a name="l01259"></a>01259         <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l01260"></a>01260           <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l01261"></a>01261             <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2) {
<a name="l01262"></a>01262               N[idxnjm(a,j,m) + idxnjm(b,j,k)*nj] = 
<a name="l01263"></a>01263                 obsme[a+b*n][ipj][idxjmk(j,m,k)].<a class="code" href="structObservablesod.html#a8c9da6cf3aa140f99b6b3f58a8f20182">n</a>;
<a name="l01264"></a>01264 
<a name="l01265"></a>01265               H[idxnjm(a,j,m) + idxnjm(b,j,k)*nj] = 
<a name="l01266"></a>01266                 obsme[a+b*n][ipj][idxjmk(j,m,k)].<a class="code" href="structObservablesod.html#a8c2c7596d9d5853b8f1701fe351dc300">h</a>;
<a name="l01267"></a>01267             }
<a name="l01268"></a>01268 
<a name="l01269"></a>01269       <a class="code" href="cmat_8c.html#aab30acd19149c3014405da4f585d4bb5">generalizedeigensystem</a>(H, N, nj, thresh, 
<a name="l01270"></a>01270                              E-&gt;<a class="code" href="structEigenstates.html#ade09c5713d0d08f69ed61126f1c8d075" title="energy eigenvalues">v</a>[ipj], E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj], 
<a name="l01271"></a>01271                              &amp;E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[ipj]);
<a name="l01272"></a>01272 
<a name="l01273"></a>01273       <span class="comment">// normalize eigenvectors such that norm = \sum_M |&lt;Q|Q;JMalpha&gt;|^2</span>
<a name="l01274"></a>01274 
<a name="l01275"></a>01275       <a class="code" href="cmat_8c.html#a32a89cb47e192550e5d5373dad79bcde" title="multiply complex matrices C = A.B">multcmat</a>(N, N, N2, nj);
<a name="l01276"></a>01276 
<a name="l01277"></a>01277       <span class="keywordflow">for</span> (i=0; i&lt;E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[ipj]; i++) {
<a name="l01278"></a>01278         
<a name="l01279"></a>01279         <span class="keywordtype">double</span> norm2=0.0, ovl2 = 0.0;
<a name="l01280"></a>01280         <span class="keywordflow">for</span> (b=0; b&lt;nj; b++)
<a name="l01281"></a>01281           <span class="keywordflow">for</span> (a=0; a&lt;nj; a++) {
<a name="l01282"></a>01282             norm2 += conj(E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][a+i*nj])*N[a+b*nj]*E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][b+i*nj];
<a name="l01283"></a>01283             ovl2 += conj(E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][a+i*nj])*N2[a+b*nj]*E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][b+i*nj];
<a name="l01284"></a>01284           }
<a name="l01285"></a>01285         
<a name="l01286"></a>01286         <span class="comment">// sort out unphysical (due to numerics) states</span>
<a name="l01287"></a>01287         <span class="keywordtype">double</span> scale;
<a name="l01288"></a>01288         <span class="keywordflow">if</span> (norm2 &lt; 0.0 || ovl2 &lt; 0.0 || isnan(norm2) || isnan(ovl2))
<a name="l01289"></a>01289           scale = 0.0;
<a name="l01290"></a>01290         <span class="keywordflow">else</span>
<a name="l01291"></a>01291           scale = sqrt(ovl2)/norm2;
<a name="l01292"></a>01292 
<a name="l01293"></a>01293         <span class="keywordflow">for</span> (a=0; a&lt;nj; a++)
<a name="l01294"></a>01294           E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][a+i*nj] *= scale;
<a name="l01295"></a>01295 
<a name="l01296"></a>01296         E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][i] = 0.0;
<a name="l01297"></a>01297         for (b=0; b&lt;nj; b++)
<a name="l01298"></a>01298           <span class="keywordflow">for</span> (a=0; a&lt;nj; a++)
<a name="l01299"></a>01299             E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][i] += 
<a name="l01300"></a>01300               conj(E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][a+i*nj])*N[a+b*nj]*E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][b+i*nj];
<a name="l01301"></a>01301       }
<a name="l01302"></a>01302 
<a name="l01303"></a>01303    }
<a name="l01304"></a>01304 
<a name="l01305"></a>01305   free(H); free(N); free(N2);
<a name="l01306"></a>01306 }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308 
<a name="l01309"></a><a class="code" href="Projection_8h.html#a2c888ae8f28458b06d1ccc71e4f31577">01309</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a2c888ae8f28458b06d1ccc71e4f31577">calcEigenstatesK</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01310"></a>01310                       <span class="keyword">const</span> <a class="code" href="structInteraction.html">Interaction</a>* <a class="code" href="MinimizerDONLP2_8c.html#ae051dcd567638cf29379a3fec796679c">Int</a>,
<a name="l01311"></a>01311                       <span class="keyword">const</span> <a class="code" href="structObservablesod.html">Observablesod</a> ***obsme, 
<a name="l01312"></a>01312                       <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E, <span class="keywordtype">int</span> K, <span class="keywordtype">double</span> thresh)
<a name="l01313"></a>01313 {
<a name="l01314"></a>01314   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> = E-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l01315"></a>01315   <span class="keywordtype">int</span> odd = P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l01316"></a>01316   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l01317"></a>01317 
<a name="l01318"></a>01318   complex <span class="keywordtype">double</span>* <a class="code" href="md5_8c.html#ae42219072d798876e6b08e6b78614ff6">H</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(n*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01319"></a>01319   complex <span class="keywordtype">double</span>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#afa106e3c58721409e0e2c7ae6980cf25">N</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(n*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01320"></a>01320   
<a name="l01321"></a>01321   <span class="keywordtype">int</span> a, b;
<a name="l01322"></a>01322   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, i;
<a name="l01323"></a>01323   <span class="keywordtype">int</span> nj, ipj;
<a name="l01324"></a>01324 
<a name="l01325"></a>01325   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l01326"></a>01326     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l01327"></a>01327       nj = n*(j+1);
<a name="l01328"></a>01328       ipj = idxpij(jmax,p,j);
<a name="l01329"></a>01329 
<a name="l01330"></a>01330       <span class="keywordflow">for</span> (b=0; b&lt;n; b++)
<a name="l01331"></a>01331         <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l01332"></a>01332           <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l01333"></a>01333             <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2) {
<a name="l01334"></a>01334               N[idxnjm(a,j,m) + idxnjm(b,j,k)*nj] =  
<a name="l01335"></a>01335                 (m == K &amp;&amp; k == K) ? obsme[a+b*n][ipj][idxjmk(j,m,k)].<a class="code" href="structObservablesod.html#a8c9da6cf3aa140f99b6b3f58a8f20182">n</a> : 0.0;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337               H[idxnjm(a,j,m) + idxnjm(b,j,k)*nj] = 
<a name="l01338"></a>01338                 (m == K &amp;&amp; k == K) ? obsme[a+b*n][ipj][idxjmk(j,m,k)].<a class="code" href="structObservablesod.html#a8c2c7596d9d5853b8f1701fe351dc300">h</a> : 0.0;
<a name="l01339"></a>01339             }
<a name="l01340"></a>01340 
<a name="l01341"></a>01341       <a class="code" href="cmat_8c.html#aab30acd19149c3014405da4f585d4bb5">generalizedeigensystem</a>(H, N, nj, thresh, 
<a name="l01342"></a>01342                              E-&gt;<a class="code" href="structEigenstates.html#ade09c5713d0d08f69ed61126f1c8d075" title="energy eigenvalues">v</a>[ipj], E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj], 
<a name="l01343"></a>01343                              &amp;E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[ipj]);
<a name="l01344"></a>01344 
<a name="l01345"></a>01345       <span class="keywordflow">for</span> (i=0; i&lt;E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[ipj]; i++) {
<a name="l01346"></a>01346         E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][i] = 0.0;
<a name="l01347"></a>01347         <span class="keywordflow">for</span> (b=0; b&lt;nj; b++)
<a name="l01348"></a>01348           <span class="keywordflow">for</span> (a=0; a&lt;nj; a++)
<a name="l01349"></a>01349             E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][i] += 
<a name="l01350"></a>01350               conj(E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][a+i*nj])*N[a+b*nj]*E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][b+i*nj];
<a name="l01351"></a>01351       }
<a name="l01352"></a>01352 
<a name="l01353"></a>01353    }
<a name="l01354"></a>01354 
<a name="l01355"></a>01355   free(H); free(N);
<a name="l01356"></a>01356 }
<a name="l01357"></a>01357 
<a name="l01358"></a>01358 <span class="comment">/*</span>
<a name="l01359"></a>01359 <span class="comment">void calcMultiEigenstates(const Projection* P,</span>
<a name="l01360"></a>01360 <span class="comment">                          const Interaction* Int,</span>
<a name="l01361"></a>01361 <span class="comment">                          const Observablesod ***obsme,</span>
<a name="l01362"></a>01362 <span class="comment">                          const Eigenstates* Ep,</span>
<a name="l01363"></a>01363 <span class="comment">                          Eigenstates* multiE, Amplitudes* multiA, </span>
<a name="l01364"></a>01364 <span class="comment">                          double thresh)</span>
<a name="l01365"></a>01365 <span class="comment">{</span>
<a name="l01366"></a>01366 <span class="comment">  int n=multiE-&gt;n;</span>
<a name="l01367"></a>01367 <span class="comment">  int odd=P-&gt;odd;</span>
<a name="l01368"></a>01368 <span class="comment">  int jmax=P-&gt;jmax;</span>
<a name="l01369"></a>01369 <span class="comment"></span>
<a name="l01370"></a>01370 <span class="comment">  complex double* H = malloc(SQR(n*(jmax+1))*sizeof(complex double));</span>
<a name="l01371"></a>01371 <span class="comment">  complex double* N = malloc(SQR(n*(jmax+1))*sizeof(complex double));</span>
<a name="l01372"></a>01372 <span class="comment">  complex double* v = malloc(n*(jmax+1)*sizeof(complex double));</span>
<a name="l01373"></a>01373 <span class="comment">  complex double* V = malloc(SQR(n*(jmax+1))*sizeof(complex double));</span>
<a name="l01374"></a>01374 <span class="comment">  </span>
<a name="l01375"></a>01375 <span class="comment">  int a, b;</span>
<a name="l01376"></a>01376 <span class="comment">  int p, j, ipj, i, m, k;</span>
<a name="l01377"></a>01377 <span class="comment">  int dim, d;</span>
<a name="l01378"></a>01378 <span class="comment">  int ai, bi, iai, ibi, idxa, idxb;</span>
<a name="l01379"></a>01379 <span class="comment">  complex double normi2, norma2;</span>
<a name="l01380"></a>01380 <span class="comment"></span>
<a name="l01381"></a>01381 <span class="comment">  for (p=0; p&lt;=1; p++)</span>
<a name="l01382"></a>01382 <span class="comment">    for (j=odd; j&lt;jmax; j=j+2) {</span>
<a name="l01383"></a>01383 <span class="comment">      ipj=idxpij(jmax,p,j);</span>
<a name="l01384"></a>01384 <span class="comment">      </span>
<a name="l01385"></a>01385 <span class="comment">      dim=0;</span>
<a name="l01386"></a>01386 <span class="comment">      for (a=0; a&lt;n; a++)</span>
<a name="l01387"></a>01387 <span class="comment">        dim += Ep[a].ngood[ipj];</span>
<a name="l01388"></a>01388 <span class="comment"></span>
<a name="l01389"></a>01389 <span class="comment">      // do we have at least a one-dimensional space</span>
<a name="l01390"></a>01390 <span class="comment">      if (dim ==0) {</span>
<a name="l01391"></a>01391 <span class="comment">        multiE-&gt;dim[ipj] = 0;</span>
<a name="l01392"></a>01392 <span class="comment">      } else {</span>
<a name="l01393"></a>01393 <span class="comment"></span>
<a name="l01394"></a>01394 <span class="comment">      idxb=-1;</span>
<a name="l01395"></a>01395 <span class="comment">      for (b=0; b&lt;n; b++)</span>
<a name="l01396"></a>01396 <span class="comment">        for (bi=0; bi&lt;Ep[b].ngood[ipj]; bi++) {</span>
<a name="l01397"></a>01397 <span class="comment">          ibi=Ep[b].index[ipj][bi];</span>
<a name="l01398"></a>01398 <span class="comment">          idxb++;</span>
<a name="l01399"></a>01399 <span class="comment">          idxa=-1;</span>
<a name="l01400"></a>01400 <span class="comment">          for (a=0; a&lt;n; a++)   </span>
<a name="l01401"></a>01401 <span class="comment">            for (ai=0; ai&lt;Ep[a].ngood[ipj]; ai++) {</span>
<a name="l01402"></a>01402 <span class="comment">              iai=Ep[a].index[ipj][ai];</span>
<a name="l01403"></a>01403 <span class="comment">              idxa++;</span>
<a name="l01404"></a>01404 <span class="comment">              N[idxa+idxb*dim] = 0.0;</span>
<a name="l01405"></a>01405 <span class="comment">              H[idxa+idxb*dim] = 0.0;</span>
<a name="l01406"></a>01406 <span class="comment"></span>
<a name="l01407"></a>01407 <span class="comment">              for (k=-j; k&lt;=j; k=k+2)</span>
<a name="l01408"></a>01408 <span class="comment">                for (m=-j; m&lt;=j; m=m+2) {</span>
<a name="l01409"></a>01409 <span class="comment">                  N[idxa+idxb*dim] +=</span>
<a name="l01410"></a>01410 <span class="comment">                    conj(Ep[a].V[ipj][idxjm(j,m)+iai*(j+1)])*</span>
<a name="l01411"></a>01411 <span class="comment">                    obsme[a+b*n][ipj][idxjmk(j,m,k)].n*</span>
<a name="l01412"></a>01412 <span class="comment">                    Ep[b].V[ipj][idxjm(j,k)+ibi*(j+1)];</span>
<a name="l01413"></a>01413 <span class="comment">                         </span>
<a name="l01414"></a>01414 <span class="comment">                  H[idxa+idxb*dim] +=</span>
<a name="l01415"></a>01415 <span class="comment">                    conj(Ep[a].V[ipj][idxjm(j,m)+iai*(j+1)])*</span>
<a name="l01416"></a>01416 <span class="comment">                    obsme[a+b*n][ipj][idxjmk(j,m,k)].h*</span>
<a name="l01417"></a>01417 <span class="comment">                    Ep[b].V[ipj][idxjm(j,k)+ibi*(j+1)];</span>
<a name="l01418"></a>01418 <span class="comment"></span>
<a name="l01419"></a>01419 <span class="comment">                }</span>
<a name="l01420"></a>01420 <span class="comment">            }   </span>
<a name="l01421"></a>01421 <span class="comment">        }      </span>
<a name="l01422"></a>01422 <span class="comment"></span>
<a name="l01423"></a>01423 <span class="comment">      generalizedeigensystem(H, N, dim, thresh, </span>
<a name="l01424"></a>01424 <span class="comment">                             v, V, </span>
<a name="l01425"></a>01425 <span class="comment">                             &amp;d);</span>
<a name="l01426"></a>01426 <span class="comment"></span>
<a name="l01427"></a>01427 <span class="comment">      // embed solution into full space</span>
<a name="l01428"></a>01428 <span class="comment"></span>
<a name="l01429"></a>01429 <span class="comment">      multiE-&gt;dim[ipj] = d;</span>
<a name="l01430"></a>01430 <span class="comment">      int nj=n*(j+1);</span>
<a name="l01431"></a>01431 <span class="comment"></span>
<a name="l01432"></a>01432 <span class="comment">      for (i=0; i&lt;d; i++) {</span>
<a name="l01433"></a>01433 <span class="comment">        multiE-&gt;v[ipj][i] = v[i];</span>
<a name="l01434"></a>01434 <span class="comment"></span>
<a name="l01435"></a>01435 <span class="comment">        for (k=-j; k&lt;=j; k=k+2) {</span>
<a name="l01436"></a>01436 <span class="comment">          idxa = -1;</span>
<a name="l01437"></a>01437 <span class="comment">          for (a=0; a&lt;n; a++) {</span>
<a name="l01438"></a>01438 <span class="comment">            multiE-&gt;V[ipj][idxnjm(a,j,k)+i*nj] = 0.0;</span>
<a name="l01439"></a>01439 <span class="comment"></span>
<a name="l01440"></a>01440 <span class="comment">            for (ai=0; ai&lt;Ep[a].ngood[ipj]; ai++) {</span>
<a name="l01441"></a>01441 <span class="comment">              idxa++;</span>
<a name="l01442"></a>01442 <span class="comment">              iai = Ep[a].index[ipj][ai];</span>
<a name="l01443"></a>01443 <span class="comment"></span>
<a name="l01444"></a>01444 <span class="comment">              multiE-&gt;V[ipj][idxnjm(a,j,k)+i*nj] += </span>
<a name="l01445"></a>01445 <span class="comment">                Ep[a].V[ipj][idxjm(j,k)+iai*(j+1)]*</span>
<a name="l01446"></a>01446 <span class="comment">                  V[idxa+i*dim];</span>
<a name="l01447"></a>01447 <span class="comment">            }</span>
<a name="l01448"></a>01448 <span class="comment">          }                                   </span>
<a name="l01449"></a>01449 <span class="comment">        }</span>
<a name="l01450"></a>01450 <span class="comment">      }</span>
<a name="l01451"></a>01451 <span class="comment"></span>
<a name="l01452"></a>01452 <span class="comment">      // calculate Amplitudes</span>
<a name="l01453"></a>01453 <span class="comment"></span>
<a name="l01454"></a>01454 <span class="comment">      for (i=0; i&lt;d; i++) {</span>
<a name="l01455"></a>01455 <span class="comment"></span>
<a name="l01456"></a>01456 <span class="comment">        normi2 = 0.0;</span>
<a name="l01457"></a>01457 <span class="comment">        for (idxb=0; idxb&lt;dim; idxb++)</span>
<a name="l01458"></a>01458 <span class="comment">          for (idxa=0; idxa&lt;dim; idxa++)</span>
<a name="l01459"></a>01459 <span class="comment">            normi2 += conj(V[idxa+i*dim])*N[idxa+idxb*dim]*V[idxb+i*dim];</span>
<a name="l01460"></a>01460 <span class="comment"></span>
<a name="l01461"></a>01461 <span class="comment">        multiE-&gt;norm[ipj][i] = normi2;</span>
<a name="l01462"></a>01462 <span class="comment"></span>
<a name="l01463"></a>01463 <span class="comment">        idxa = -1;</span>
<a name="l01464"></a>01464 <span class="comment">        for (a=0; a&lt;n; a++) {</span>
<a name="l01465"></a>01465 <span class="comment">          multiA-&gt;ngood[ipj][a] = Ep[a].ngood[ipj];</span>
<a name="l01466"></a>01466 <span class="comment">          </span>
<a name="l01467"></a>01467 <span class="comment">          for (ai=0; ai&lt;Ep[a].ngood[ipj]; ai++) {</span>
<a name="l01468"></a>01468 <span class="comment">            idxa++;</span>
<a name="l01469"></a>01469 <span class="comment">            norma2 = N[idxa+idxa*dim];</span>
<a name="l01470"></a>01470 <span class="comment">            multiA-&gt;amp[ipj][ai+a*(j+1)+i*n*(j+1)] = 0.0;</span>
<a name="l01471"></a>01471 <span class="comment">            for (idxb=0; idxb&lt;dim; idxb++)</span>
<a name="l01472"></a>01472 <span class="comment">              multiA-&gt;amp[ipj][ai+a*(j+1)+i*n*(j+1)] +=</span>
<a name="l01473"></a>01473 <span class="comment">                N[idxa+idxb*dim]*V[idxb+i*dim]/csqrt(norma2*normi2);</span>
<a name="l01474"></a>01474 <span class="comment">          }</span>
<a name="l01475"></a>01475 <span class="comment">        }</span>
<a name="l01476"></a>01476 <span class="comment">      }</span>
<a name="l01477"></a>01477 <span class="comment">      }</span>
<a name="l01478"></a>01478 <span class="comment"></span>
<a name="l01479"></a>01479 <span class="comment">   }</span>
<a name="l01480"></a>01480 <span class="comment"></span>
<a name="l01481"></a>01481 <span class="comment">  free(H); free(N);</span>
<a name="l01482"></a>01482 <span class="comment">  free(v); free(V);</span>
<a name="l01483"></a>01483 <span class="comment">}</span>
<a name="l01484"></a>01484 <span class="comment">*/</span>
<a name="l01485"></a>01485 
<a name="l01486"></a>01486 <span class="comment">// use basis states |Q^i;JMalpha&gt; normalized to 1</span>
<a name="l01487"></a>01487 
<a name="l01488"></a><a class="code" href="Projection_8h.html#a056b9a28cb7f2d352eb665582e9be9fb">01488</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a056b9a28cb7f2d352eb665582e9be9fb">calcMultiEigenstates</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01489"></a>01489                           <span class="keyword">const</span> <a class="code" href="structInteraction.html">Interaction</a>* <a class="code" href="MinimizerDONLP2_8c.html#ae051dcd567638cf29379a3fec796679c">Int</a>,
<a name="l01490"></a>01490                           <span class="keyword">const</span> <a class="code" href="structObservablesod.html">Observablesod</a> ***obsme,
<a name="l01491"></a>01491                           <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Ep,
<a name="l01492"></a>01492                           <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* multiE, <a class="code" href="structAmplitudes.html">Amplitudes</a>* multiA, 
<a name="l01493"></a>01493                           <span class="keywordtype">double</span> thresh)
<a name="l01494"></a>01494 {
<a name="l01495"></a>01495   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=multiE-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l01496"></a>01496   <span class="keywordtype">int</span> odd=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l01497"></a>01497   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l01498"></a>01498 
<a name="l01499"></a>01499   complex <span class="keywordtype">double</span>* <a class="code" href="md5_8c.html#ae42219072d798876e6b08e6b78614ff6">H</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(n*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01500"></a>01500   complex <span class="keywordtype">double</span>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#afa106e3c58721409e0e2c7ae6980cf25">N</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(n*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01501"></a>01501   complex <span class="keywordtype">double</span>* v = malloc(n*(jmax+1)*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01502"></a>01502   complex <span class="keywordtype">double</span>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ada7b84dafb505b22eca2753ef852e94a">V</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(n*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l01503"></a>01503   
<a name="l01504"></a>01504   <span class="keywordtype">int</span> a, b;
<a name="l01505"></a>01505   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, ipj, i, <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>;
<a name="l01506"></a>01506   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>, d;
<a name="l01507"></a>01507   <span class="keywordtype">int</span> ai, bi, iai, ibi, idxa, idxb;
<a name="l01508"></a>01508   <span class="keywordtype">double</span> norma2, normb2, normi2;        
<a name="l01509"></a>01509 
<a name="l01510"></a>01510   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l01511"></a>01511     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l01512"></a>01512       ipj=idxpij(jmax,p,j);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514       dim=0;
<a name="l01515"></a>01515       <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l01516"></a>01516         dim += Ep[a].ngood[ipj];
<a name="l01517"></a>01517 
<a name="l01518"></a>01518       <span class="comment">// do we have at least a one-dimensional space</span>
<a name="l01519"></a>01519       <span class="keywordflow">if</span> (dim ==0) {
<a name="l01520"></a>01520         multiE-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[ipj] = 0;
<a name="l01521"></a>01521       } <span class="keywordflow">else</span> {
<a name="l01522"></a>01522 
<a name="l01523"></a>01523       idxb=-1;
<a name="l01524"></a>01524       <span class="keywordflow">for</span> (b=0; b&lt;n; b++)
<a name="l01525"></a>01525         <span class="keywordflow">for</span> (bi=0; bi&lt;Ep[b].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj]; bi++) {
<a name="l01526"></a>01526           ibi=Ep[b].<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][bi];
<a name="l01527"></a>01527           normb2=Ep[b].<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][ibi];
<a name="l01528"></a>01528           idxb++;
<a name="l01529"></a>01529           idxa=-1;
<a name="l01530"></a>01530           <span class="keywordflow">for</span> (a=0; a&lt;n; a++)   
<a name="l01531"></a>01531             <span class="keywordflow">for</span> (ai=0; ai&lt;Ep[a].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj]; ai++) {
<a name="l01532"></a>01532               iai=Ep[a].<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][ai];
<a name="l01533"></a>01533               norma2=Ep[a].<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][iai];
<a name="l01534"></a>01534               idxa++;
<a name="l01535"></a>01535               N[idxa+idxb*dim] = 0.0;
<a name="l01536"></a>01536               H[idxa+idxb*dim] = 0.0;
<a name="l01537"></a>01537 
<a name="l01538"></a>01538               <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l01539"></a>01539                 <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2) {
<a name="l01540"></a>01540                   N[idxa+idxb*dim] +=
<a name="l01541"></a>01541                     conj(Ep[a].V[ipj][idxjm(j,m)+iai*(j+1)])*
<a name="l01542"></a>01542                     obsme[a+b*n][ipj][idxjmk(j,m,k)].<a class="code" href="structObservablesod.html#a8c9da6cf3aa140f99b6b3f58a8f20182">n</a>*
<a name="l01543"></a>01543                     Ep[b].<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][idxjm(j,k)+ibi*(j+1)]/
<a name="l01544"></a>01544                     sqrt(norma2*normb2);
<a name="l01545"></a>01545                          
<a name="l01546"></a>01546                   H[idxa+idxb*dim] +=
<a name="l01547"></a>01547                     conj(Ep[a].V[ipj][idxjm(j,m)+iai*(j+1)])*
<a name="l01548"></a>01548                     obsme[a+b*n][ipj][idxjmk(j,m,k)].<a class="code" href="structObservablesod.html#a8c2c7596d9d5853b8f1701fe351dc300">h</a>*
<a name="l01549"></a>01549                     Ep[b].<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][idxjm(j,k)+ibi*(j+1)]/
<a name="l01550"></a>01550                     sqrt(norma2*normb2);
<a name="l01551"></a>01551 
<a name="l01552"></a>01552                 }
<a name="l01553"></a>01553             }   
<a name="l01554"></a>01554         }      
<a name="l01555"></a>01555 
<a name="l01556"></a>01556       <span class="comment">/* debugging</span>
<a name="l01557"></a>01557 <span class="comment"></span>
<a name="l01558"></a>01558 <span class="comment">      fprintf(stderr, &quot;\nJ^pi = %s\n\n&quot;, AngmomtoStr(j, p));</span>
<a name="l01559"></a>01559 <span class="comment">      </span>
<a name="l01560"></a>01560 <span class="comment">      fprintf(stderr, &quot;N matrix\n&quot;);</span>
<a name="l01561"></a>01561 <span class="comment">      fprintcmat(stderr, dim, N);</span>
<a name="l01562"></a>01562 <span class="comment"></span>
<a name="l01563"></a>01563 <span class="comment">      fprintf(stderr, &quot;H matrix\n&quot;);</span>
<a name="l01564"></a>01564 <span class="comment">      fprintcmat(stderr, dim, H);</span>
<a name="l01565"></a>01565 <span class="comment"></span>
<a name="l01566"></a>01566 <span class="comment">      */</span>
<a name="l01567"></a>01567 
<a name="l01568"></a>01568       <a class="code" href="cmat_8c.html#aab30acd19149c3014405da4f585d4bb5">generalizedeigensystem</a>(H, N, dim, thresh, 
<a name="l01569"></a>01569                              v, V, 
<a name="l01570"></a>01570                              &amp;d);
<a name="l01571"></a>01571 
<a name="l01572"></a>01572       <span class="comment">// embed solution into full space</span>
<a name="l01573"></a>01573 
<a name="l01574"></a>01574       multiE-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[ipj] = d;
<a name="l01575"></a>01575       <span class="keywordtype">int</span> nj=n*(j+1);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577       <span class="keywordflow">for</span> (i=0; i&lt;d; i++) {
<a name="l01578"></a>01578         multiE-&gt;<a class="code" href="structEigenstates.html#ade09c5713d0d08f69ed61126f1c8d075" title="energy eigenvalues">v</a>[ipj][i] = v[i];
<a name="l01579"></a>01579 
<a name="l01580"></a>01580         <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2) {
<a name="l01581"></a>01581           idxa = -1;
<a name="l01582"></a>01582           <span class="keywordflow">for</span> (a=0; a&lt;n; a++) {
<a name="l01583"></a>01583             multiE-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][idxnjm(a,j,k)+i*nj] = 0.0;
<a name="l01584"></a>01584 
<a name="l01585"></a>01585             <span class="keywordflow">for</span> (ai=0; ai&lt;Ep[a].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj]; ai++) {
<a name="l01586"></a>01586               idxa++;
<a name="l01587"></a>01587               iai = Ep[a].<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][ai];
<a name="l01588"></a>01588               norma2 = Ep[a].<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][iai];
<a name="l01589"></a>01589 
<a name="l01590"></a>01590               multiE-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][idxnjm(a,j,k)+i*nj] += 
<a name="l01591"></a>01591                 Ep[a].<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][idxjm(j,k)+iai*(j+1)]/sqrt(norma2)*
<a name="l01592"></a>01592                   V[idxa+i*dim];
<a name="l01593"></a>01593             }
<a name="l01594"></a>01594           }                                   
<a name="l01595"></a>01595         }
<a name="l01596"></a>01596       }
<a name="l01597"></a>01597 
<a name="l01598"></a>01598       <span class="comment">// calculate Amplitudes</span>
<a name="l01599"></a>01599 
<a name="l01600"></a>01600       <span class="keywordflow">for</span> (i=0; i&lt;d; i++) {
<a name="l01601"></a>01601 
<a name="l01602"></a>01602         normi2 = 0.0;
<a name="l01603"></a>01603         <span class="keywordflow">for</span> (idxb=0; idxb&lt;dim; idxb++)
<a name="l01604"></a>01604           <span class="keywordflow">for</span> (idxa=0; idxa&lt;dim; idxa++)
<a name="l01605"></a>01605             normi2 += conj(V[idxa+i*dim])*N[idxa+idxb*dim]*V[idxb+i*dim];
<a name="l01606"></a>01606 
<a name="l01607"></a>01607         multiE-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][i] = normi2;
<a name="l01608"></a>01608 
<a name="l01609"></a>01609         idxa = -1;
<a name="l01610"></a>01610         <span class="keywordflow">for</span> (a=0; a&lt;n; a++) {
<a name="l01611"></a>01611           multiA-&gt;<a class="code" href="structAmplitudes.html#a3192b8e5338e5ac43d813833b09ad221">ngood</a>[ipj][a] = Ep[a].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj];
<a name="l01612"></a>01612           
<a name="l01613"></a>01613           <span class="keywordflow">for</span> (ai=0; ai&lt;Ep[a].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj]; ai++) {
<a name="l01614"></a>01614             idxa++;
<a name="l01615"></a>01615             norma2 = N[idxa+idxa*dim];
<a name="l01616"></a>01616 
<a name="l01617"></a>01617             multiA-&gt;<a class="code" href="structAmplitudes.html#a1608d319a33b0263e17f0ac70993cce2">amp</a>[ipj][ai+a*(j+1)+i*n*(j+1)] = 0.0;
<a name="l01618"></a>01618             <span class="keywordflow">for</span> (idxb=0; idxb&lt;dim; idxb++)
<a name="l01619"></a>01619               multiA-&gt;<a class="code" href="structAmplitudes.html#a1608d319a33b0263e17f0ac70993cce2">amp</a>[ipj][ai+a*(j+1)+i*n*(j+1)] +=
<a name="l01620"></a>01620                 N[idxa+idxb*dim]*V[idxb+i*dim]/sqrt(norma2*normi2);
<a name="l01621"></a>01621           }
<a name="l01622"></a>01622         }
<a name="l01623"></a>01623       }
<a name="l01624"></a>01624 
<a name="l01625"></a>01625       }
<a name="l01626"></a>01626    }
<a name="l01627"></a>01627 
<a name="l01628"></a>01628   free(H); free(N);
<a name="l01629"></a>01629   free(v); free(V);
<a name="l01630"></a>01630 }
<a name="l01631"></a>01631 
<a name="l01632"></a>01632 
<a name="l01633"></a><a class="code" href="Projection_8h.html#a6efb4a37227aadf15910f7270a97a486">01633</a> <span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a6efb4a37227aadf15910f7270a97a486">writeEigenstates</a>(FILE* fp, 
<a name="l01634"></a>01634                      <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E)
<a name="l01635"></a>01635 {
<a name="l01636"></a>01636   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>;
<a name="l01637"></a>01637   <span class="keywordtype">int</span> i;
<a name="l01638"></a>01638   <span class="keywordtype">int</span> odd=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l01639"></a>01639   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l01640"></a>01640   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=E-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l01641"></a>01641   <span class="keywordtype">int</span> idx;
<a name="l01642"></a>01642   <span class="keywordtype">int</span> nj, dimj;
<a name="l01643"></a>01643 
<a name="l01644"></a>01644   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l01645"></a>01645     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l01646"></a>01646       idx = idxpij(jmax,p,j);
<a name="l01647"></a>01647       nj = n*(j+1);
<a name="l01648"></a>01648       dimj = E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idx];
<a name="l01649"></a>01649 
<a name="l01650"></a>01650       fprintf(fp, <span class="stringliteral">&quot;&lt;Eigenstates %d %d&gt;\n&quot;</span>, j, p);
<a name="l01651"></a>01651       fprintf(fp, <span class="stringliteral">&quot;&lt;Indices %2d %2d&gt;\n&quot;</span>, dimj, E-&gt;<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[idx]);
<a name="l01652"></a>01652       <span class="keywordflow">if</span> (dimj &gt; 0) {
<a name="l01653"></a>01653         <span class="keywordflow">for</span> (i=0; i&lt;dimj; i++)
<a name="l01654"></a>01654           fprintf(fp, <span class="stringliteral">&quot;%2d   &quot;</span>, E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[idx][i]);
<a name="l01655"></a>01655         fprintf(fp, <span class="stringliteral">&quot;\n&lt;/Indices&gt;\n&quot;</span>);
<a name="l01656"></a>01656         fprintf(fp, <span class="stringliteral">&quot;&lt;Norms&gt;\n&quot;</span>);
<a name="l01657"></a>01657         <span class="keywordflow">for</span> (i=0; i&lt;dimj; i++)
<a name="l01658"></a>01658           fprintf(fp, <span class="stringliteral">&quot;(%10.8f,%10.8f)   &quot;</span>,
<a name="l01659"></a>01659                   creal(E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[idx][i]),
<a name="l01660"></a>01660                   cimag(E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[idx][i]));
<a name="l01661"></a>01661         fprintf(fp, <span class="stringliteral">&quot;\n&lt;/Norms&gt;\n&quot;</span>);
<a name="l01662"></a>01662         fprintf(fp, <span class="stringliteral">&quot;&lt;Energies&gt;\n&quot;</span>);
<a name="l01663"></a>01663         <span class="keywordflow">for</span> (i=0; i&lt;dimj; i++)
<a name="l01664"></a>01664           fprintf(fp, <span class="stringliteral">&quot;(%8.5f,%8.5f)   &quot;</span>, 
<a name="l01665"></a>01665                   creal(E-&gt;<a class="code" href="structEigenstates.html#ade09c5713d0d08f69ed61126f1c8d075" title="energy eigenvalues">v</a>[idx][i]),
<a name="l01666"></a>01666                   cimag(E-&gt;<a class="code" href="structEigenstates.html#ade09c5713d0d08f69ed61126f1c8d075" title="energy eigenvalues">v</a>[idx][i]));
<a name="l01667"></a>01667         fprintf(fp, <span class="stringliteral">&quot;\n&lt;/Energies&gt;\n&quot;</span>);
<a name="l01668"></a>01668         fprintf(fp, <span class="stringliteral">&quot;&lt;Eigenvectors&gt;\n&quot;</span>);
<a name="l01669"></a>01669         <a class="code" href="cmat_8c.html#afc76d7acbd75929591cc577301214b69" title="write colums of matrix to fp">fprintcmatcols</a>(fp, nj, dimj, E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idx]);
<a name="l01670"></a>01670         fprintf(fp, <span class="stringliteral">&quot;&lt;/Eigenvectors&gt;\n&quot;</span>);
<a name="l01671"></a>01671       }
<a name="l01672"></a>01672       fprintf(fp, <span class="stringliteral">&quot;&lt;/Eigenstates&gt;\n&quot;</span>);
<a name="l01673"></a>01673     }
<a name="l01674"></a>01674   
<a name="l01675"></a>01675   <span class="keywordflow">return</span> 0;
<a name="l01676"></a>01676 }
<a name="l01677"></a>01677 
<a name="l01678"></a>01678 
<a name="l01679"></a>01679 <span class="preprocessor">#define BUFSIZE 65536</span>
<a name="l01680"></a>01680 <span class="preprocessor"></span>
<a name="l01681"></a><a class="code" href="Projection_8h.html#a21bd7a5920ce98dea99f5ecbe591b799">01681</a> <span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a21bd7a5920ce98dea99f5ecbe591b799">readEigenstates</a>(FILE* fp,
<a name="l01682"></a>01682                     <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l01683"></a>01683 {
<a name="l01684"></a>01684   <span class="keywordtype">int</span> odd=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l01685"></a>01685   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l01686"></a>01686   <span class="keywordtype">char</span> buf[BUFSIZE];
<a name="l01687"></a>01687   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>;
<a name="l01688"></a>01688   <span class="keywordtype">int</span> filep, filej, filedim, filegood;
<a name="l01689"></a>01689   <span class="keywordtype">int</span> idx;
<a name="l01690"></a>01690   <span class="keywordtype">int</span> nj;
<a name="l01691"></a>01691   <span class="keywordtype">int</span> dimj;
<a name="l01692"></a>01692 
<a name="l01693"></a>01693   <a class="code" href="Projection_8c.html#a9be2f82e183827f27b5edbefcb794740">initEigenstates</a>(P, E, n);
<a name="l01694"></a>01694 
<a name="l01695"></a>01695   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l01696"></a>01696     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l01697"></a>01697       idx = idxpij(jmax,p,j);
<a name="l01698"></a>01698       nj = n*(j+1);
<a name="l01699"></a>01699 
<a name="l01700"></a>01700       <span class="keywordflow">do</span> 
<a name="l01701"></a>01701         fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l01702"></a>01702       <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;Eigenstates &quot;</span>, 13) &amp;&amp; !feof(fp));
<a name="l01703"></a>01703       <span class="keywordflow">if</span> (feof(fp)) {
<a name="l01704"></a>01704         fprintf(stderr, <span class="stringliteral">&quot;didn&#39;t find &lt;Eigenstates ...&gt;\n&quot;</span>);
<a name="l01705"></a>01705         <span class="keywordflow">return</span> -1;
<a name="l01706"></a>01706       }
<a name="l01707"></a>01707       sscanf(buf, <span class="stringliteral">&quot;&lt;Eigenstates %d %d&gt;&quot;</span>, &amp;filej, &amp;filep);
<a name="l01708"></a>01708       <span class="keywordflow">if</span> (j != filej || p != filep) {
<a name="l01709"></a>01709         fprintf(stderr, <span class="stringliteral">&quot;expected &lt;Eigenstates %d %d&gt;\n&quot;</span>, j, p);
<a name="l01710"></a>01710         <span class="keywordflow">return</span> -1;
<a name="l01711"></a>01711       }
<a name="l01712"></a>01712       fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l01713"></a>01713       sscanf(buf, <span class="stringliteral">&quot;&lt;Indices %d %d&gt;&quot;</span>, &amp;filedim, &amp;filegood);
<a name="l01714"></a>01714       E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idx] = filedim;
<a name="l01715"></a>01715       E-&gt;<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[idx] = filegood;
<a name="l01716"></a>01716       <span class="keywordflow">if</span> (filedim &gt; 0) {
<a name="l01717"></a>01717         dimj = filedim;
<a name="l01718"></a>01718         <a class="code" href="cmat_8c.html#a2740ad63230d1f3545d27b878070d1bf" title="read integer vector from fp">freadivec</a>(fp, dimj, E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[idx]);
<a name="l01719"></a>01719         fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp); <span class="comment">// &lt;/Indices&gt;</span>
<a name="l01720"></a>01720         fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp); <span class="comment">// &lt;Norms&gt;</span>
<a name="l01721"></a>01721         <a class="code" href="cmat_8c.html#a2b53cd2e9f3d173306b7613f4ac10167" title="read vector from fp">freadcvec</a>(fp, dimj, E-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[idx]);
<a name="l01722"></a>01722         fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp); <span class="comment">// &lt;/Norms&gt;</span>
<a name="l01723"></a>01723         fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp); <span class="comment">// &lt;Energies&gt;</span>
<a name="l01724"></a>01724         <a class="code" href="cmat_8c.html#a2b53cd2e9f3d173306b7613f4ac10167" title="read vector from fp">freadcvec</a>(fp, dimj, E-&gt;<a class="code" href="structEigenstates.html#ade09c5713d0d08f69ed61126f1c8d075" title="energy eigenvalues">v</a>[idx]);
<a name="l01725"></a>01725         fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp); <span class="comment">// &lt;/Energies&gt;</span>
<a name="l01726"></a>01726         fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp); <span class="comment">// &lt;Eigenvectors&gt;</span>
<a name="l01727"></a>01727         <a class="code" href="cmat_8c.html#a46cb0a80d9ddb8a96759c5e6ba8f4ec4" title="read colums of matrix from fp">freadcmatcols</a>(fp, nj, dimj, E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idx]);
<a name="l01728"></a>01728         fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp); <span class="comment">// &lt;/Eigenvectors&gt;</span>
<a name="l01729"></a>01729       }
<a name="l01730"></a>01730       fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l01731"></a>01731       <span class="keywordflow">if</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;/Eigenstates&gt;&quot;</span>, 14)) {
<a name="l01732"></a>01732         fprintf(stderr, <span class="stringliteral">&quot;didn&#39;t find &lt;/Eigenstates&gt;\n&quot;</span>);
<a name="l01733"></a>01733         <span class="keywordflow">return</span> -1;
<a name="l01734"></a>01734       }
<a name="l01735"></a>01735     }
<a name="l01736"></a>01736   <span class="keywordflow">return</span> 0;
<a name="l01737"></a>01737 }
<a name="l01738"></a>01738 
<a name="l01739"></a>01739 
<a name="l01740"></a>01740 
<a name="l01741"></a>01741 <span class="keyword">static</span> <span class="keywordtype">int</span> cmpmerit(<span class="keywordtype">void</span>* ap, <span class="keywordtype">void</span>* bp) 
<a name="l01742"></a>01742 {
<a name="l01743"></a>01743   <span class="keywordtype">double</span> a=*(<span class="keywordtype">double</span>*) ap;
<a name="l01744"></a>01744   <span class="keywordtype">double</span> b=*(<span class="keywordtype">double</span>*) bp;
<a name="l01745"></a>01745   
<a name="l01746"></a>01746   <span class="keywordflow">return</span> (a&lt;=b ? (a&lt;b ? 1 : 0) : -1);
<a name="l01747"></a>01747 }
<a name="l01748"></a>01748 
<a name="l01749"></a><a class="code" href="Projection_8c.html#a7c53005f48be691eb85407c5a9588267">01749</a> <span class="preprocessor">#define MAXSTATES 15</span>
<a name="l01750"></a><a class="code" href="Projection_8c.html#a0e159c7238ca2b8eae27e904e8b0c60f">01750</a> <span class="preprocessor"></span><span class="preprocessor">#define ERRJMAX 0.25            // |&lt;J^2&gt; - j(j+1)| should be smaller than ERRJMAX</span>
<a name="l01751"></a>01751 <span class="preprocessor"></span>
<a name="l01752"></a><a class="code" href="Projection_8h.html#a465ddb73457c8835e9a944d35b54f79a">01752</a> <span class="keywordtype">void</span> <a class="code" href="Projection_8c.html#a465ddb73457c8835e9a944d35b54f79a">sortEigenstates</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01753"></a>01753                      <span class="keyword">const</span> <a class="code" href="structInteraction.html">Interaction</a>* <a class="code" href="MinimizerDONLP2_8c.html#ae051dcd567638cf29379a3fec796679c">Int</a>,
<a name="l01754"></a>01754                      <span class="keyword">const</span> <a class="code" href="structObservablesod.html">Observablesod</a>** obs,
<a name="l01755"></a>01755                      <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E, 
<a name="l01756"></a>01756                      <span class="keywordtype">double</span> minnorm, <span class="keywordtype">int</span> all)
<a name="l01757"></a>01757 {
<a name="l01758"></a>01758   <span class="keywordtype">int</span> odd=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l01759"></a>01759   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l01760"></a>01760   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=E-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l01761"></a>01761 
<a name="l01762"></a>01762   <span class="keywordtype">int</span> p,<a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>,i;
<a name="l01763"></a>01763   <span class="keywordtype">int</span> dimj;
<a name="l01764"></a>01764   <span class="keywordtype">int</span> nj;
<a name="l01765"></a>01765   <span class="keywordtype">int</span> ngood;
<a name="l01766"></a>01766 
<a name="l01767"></a>01767   <span class="keywordtype">double</span> maxnorm;
<a name="l01768"></a>01768 
<a name="l01769"></a>01769   <span class="keyword">struct </span>merit {
<a name="l01770"></a>01770     <span class="keywordtype">double</span> <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>;
<a name="l01771"></a>01771     <span class="keywordtype">int</span> idx;
<a name="l01772"></a>01772   } merits[n*(jmax+1)];
<a name="l01773"></a>01773 
<a name="l01774"></a>01774   maxnorm = 0.0;
<a name="l01775"></a>01775   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l01776"></a>01776     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2)
<a name="l01777"></a>01777       <span class="keywordflow">for</span> (i=0; i&lt;E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxpij(jmax,p,j)]; i++)
<a name="l01778"></a>01778         maxnorm = fmax(maxnorm, creal(obs[idxpij(jmax,p,j)][i].n));
<a name="l01779"></a>01779 
<a name="l01780"></a>01780   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l01781"></a>01781     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l01782"></a>01782       nj = n*(j+1);
<a name="l01783"></a>01783       dimj = E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxpij(jmax,p,j)];
<a name="l01784"></a>01784 
<a name="l01785"></a>01785       <span class="comment">// determine merits of eigenstates</span>
<a name="l01786"></a>01786       <span class="keywordflow">for</span> (i=0; i&lt;dimj; i++) {
<a name="l01787"></a>01787         merits[i].idx = i;
<a name="l01788"></a>01788 
<a name="l01789"></a>01789         <span class="comment">// norm too small ?</span>
<a name="l01790"></a>01790         <span class="keywordflow">if</span> (creal(obs[idxpij(jmax,p,j)][i].n) &lt; minnorm*maxnorm)
<a name="l01791"></a>01791           merits[i].val = -100000.0;    
<a name="l01792"></a>01792         <span class="comment">// J2 looks suspicious ?</span>
<a name="l01793"></a>01793         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cabs(obs[idxpij(jmax,p,j)][i].j2/obs[idxpij(jmax,p,j)][i].n - 0.25*j*(j+2)) &gt; <a class="code" href="Projection_8c.html#a0e159c7238ca2b8eae27e904e8b0c60f">ERRJMAX</a>)
<a name="l01794"></a>01794           merits[i].val = -100000.0;
<a name="l01795"></a>01795         <span class="comment">// else use the energy</span>
<a name="l01796"></a>01796         <span class="keywordflow">else</span>
<a name="l01797"></a>01797           merits[i].val = -creal(obs[idxpij(jmax,p,j)][i].h/obs[idxpij(jmax,p,j)][i].n);
<a name="l01798"></a>01798       }
<a name="l01799"></a>01799         
<a name="l01800"></a>01800       <span class="comment">// sort according to merits value</span>
<a name="l01801"></a>01801       qsort(merits, dimj, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> merit), cmpmerit);
<a name="l01802"></a>01802 
<a name="l01803"></a>01803       i=0; <span class="keywordflow">while</span> (i&lt;dimj &amp;&amp; ( all || merits[i].<a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a> &gt; -100000.0)) i++;
<a name="l01804"></a>01804       ngood = min(i,<a class="code" href="Projection_8c.html#a7c53005f48be691eb85407c5a9588267">MAXSTATES</a>);
<a name="l01805"></a>01805       E-&gt;<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[idxpij(jmax,p,j)] = ngood;
<a name="l01806"></a>01806       <span class="keywordflow">for</span> (i=0; i&lt;dimj; i++)
<a name="l01807"></a>01807         E-&gt;<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[idxpij(jmax,p,j)][i] = merits[i].idx;
<a name="l01808"></a>01808 
<a name="l01809"></a>01809     }
<a name="l01810"></a>01810 }
<a name="l01811"></a>01811 
<a name="l01812"></a>01812 
<a name="l01813"></a>01813 <span class="comment">// don&#39;t check whether MBFile still matches </span>
<a name="l01814"></a><a class="code" href="Projection_8h.html#a5935cc6b0a5d47d441ca31d6fedbe5cc">01814</a> <span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a5935cc6b0a5d47d441ca31d6fedbe5cc">readEigenstatesfromFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* fname,
<a name="l01815"></a>01815                             <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l01816"></a>01816 {
<a name="l01817"></a>01817   FILE* fp;
<a name="l01818"></a>01818   <span class="keywordtype">char</span> fullname[255];
<a name="l01819"></a>01819 
<a name="l01820"></a>01820   snprintf(fullname, 255, <span class="stringliteral">&quot;%s.%s.states&quot;</span>, fname, <a class="code" href="Projection_8c.html#ac87bb7fb183abeb15fc0454df5babd55">ProjectiontoStr</a>(P));
<a name="l01821"></a>01821 
<a name="l01822"></a>01822   <span class="keywordflow">if</span> (!(fp = fopen(fullname, <span class="stringliteral">&quot;r&quot;</span>))) {  
<a name="l01823"></a>01823     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for reading\n&quot;</span>, fullname);
<a name="l01824"></a>01824     <span class="keywordflow">return</span> -1;
<a name="l01825"></a>01825   }
<a name="l01826"></a>01826 
<a name="l01827"></a>01827   fprintf(stderr, <span class="stringliteral">&quot;... reading Eigenstates from file %s\n&quot;</span>, fullname);
<a name="l01828"></a>01828 
<a name="l01829"></a>01829   <span class="keywordtype">int</span> err=<a class="code" href="Projection_8c.html#a21bd7a5920ce98dea99f5ecbe591b799">readEigenstates</a>(fp, P, E, n);
<a name="l01830"></a>01830   fclose(fp);
<a name="l01831"></a>01831 
<a name="l01832"></a>01832   <span class="keywordflow">return</span> err;
<a name="l01833"></a>01833 }
<a name="l01834"></a>01834 
<a name="l01835"></a>01835 
<a name="l01836"></a><a class="code" href="Projection_8h.html#a217536fb9853df72dc83c7a27de713f0">01836</a> <span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a217536fb9853df72dc83c7a27de713f0">writeMulticonfigfile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* fname,
<a name="l01837"></a>01837                          <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01838"></a>01838                          <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a>* S,
<a name="l01839"></a>01839                          <span class="keyword">const</span> <span class="keywordtype">char</span>** mbfile,
<a name="l01840"></a>01840                          <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l01841"></a>01841 {
<a name="l01842"></a>01842   FILE* fp;
<a name="l01843"></a>01843   <span class="keywordtype">char</span> filename[255];
<a name="l01844"></a>01844 
<a name="l01845"></a>01845   snprintf(filename, 255, <span class="stringliteral">&quot;%s.states&quot;</span>, fname);
<a name="l01846"></a>01846 
<a name="l01847"></a>01847   <span class="keywordflow">if</span> (!(fp = fopen(filename, <span class="stringliteral">&quot;w&quot;</span>))) {
<a name="l01848"></a>01848     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for writing\n&quot;</span>, filename);
<a name="l01849"></a>01849     <span class="keywordflow">return</span> -1;
<a name="l01850"></a>01850   }     
<a name="l01851"></a>01851 
<a name="l01852"></a>01852   <a class="code" href="utils_8c.html#ae3c710edac30cf257199e6595212a75a" title="print info about running process">fprintinfo</a>(fp);
<a name="l01853"></a>01853   <a class="code" href="Projection_8c.html#af11f2a70292f93f6b5983cfc4f26d774">fprintProjectinfo</a>(fp, P);
<a name="l01854"></a>01854   fprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01855"></a>01855   fprintf(fp, <span class="stringliteral">&quot;&lt;Multiconfprojected %d %s&gt;\n&quot;</span>, n, <a class="code" href="Projection_8c.html#ac87bb7fb183abeb15fc0454df5babd55">ProjectiontoStr</a>(P));
<a name="l01856"></a>01856 
<a name="l01857"></a>01857   <span class="keywordtype">int</span> i;
<a name="l01858"></a>01858   <span class="keywordflow">for</span> (i=0; i&lt;n; i++)
<a name="l01859"></a>01859     fprintf(fp, <span class="stringliteral">&quot;&lt;MBFile %s %s %d&gt;\n&quot;</span>,
<a name="l01860"></a>01860             mbfile[i], <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfile[i]), S[i]);
<a name="l01861"></a>01861   fprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01862"></a>01862     
<a name="l01863"></a>01863   <a class="code" href="Projection_8c.html#a6efb4a37227aadf15910f7270a97a486">writeEigenstates</a>(fp, P, E);
<a name="l01864"></a>01864 
<a name="l01865"></a>01865   fprintf(fp, <span class="stringliteral">&quot;&lt;/Multiconfprojected&gt;\n&quot;</span>);
<a name="l01866"></a>01866   fclose(fp);
<a name="l01867"></a>01867 
<a name="l01868"></a>01868   <span class="keywordflow">return</span> 0;
<a name="l01869"></a>01869 }
<a name="l01870"></a>01870 
<a name="l01871"></a>01871 
<a name="l01872"></a><a class="code" href="Projection_8c.html#aeca034f67218340ecb2261a22c2f3dcd">01872</a> <span class="preprocessor">#define BUFSIZE 1024</span>
<a name="l01873"></a><a class="code" href="Projection_8h.html#ae36142d2bd6e101eb90230d5cf022f37">01873</a> <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="Projection_8c.html#a926f3d9d5679530c163358d2d6c9cc2a">readMulticonfigfile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* fname,
<a name="l01874"></a>01874                         <span class="keywordtype">char</span>*** slaterdetfilep,
<a name="l01875"></a>01875                         <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01876"></a>01876                         <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>** <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l01877"></a>01877                         <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a>** Sp,
<a name="l01878"></a>01878                         <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E,
<a name="l01879"></a>01879                         <span class="keywordtype">int</span>* nstates)
<a name="l01880"></a>01880 {
<a name="l01881"></a>01881   FILE* fp;
<a name="l01882"></a>01882   <span class="keywordtype">char</span> buf[BUFSIZE];
<a name="l01883"></a>01883   <span class="keywordtype">int</span> i, <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>;
<a name="l01884"></a>01884   <span class="keywordtype">char</span> sldetfname[255], md5sldetfname[33];
<a name="l01885"></a>01885 
<a name="l01886"></a>01886   <span class="keywordflow">if</span> (!(fp = fopen(fname, <span class="stringliteral">&quot;r&quot;</span>))) {
<a name="l01887"></a>01887     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for reading\n&quot;</span>, fname);
<a name="l01888"></a>01888     <span class="keywordflow">return</span> -1;
<a name="l01889"></a>01889   }
<a name="l01890"></a>01890 
<a name="l01891"></a>01891   <span class="comment">// get the Projection parameters</span>
<a name="l01892"></a>01892   <span class="keywordflow">do</span>    
<a name="l01893"></a>01893     fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l01894"></a>01894   <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;Multiconfprojected &quot;</span>, 19) &amp;&amp; !feof(fp));
<a name="l01895"></a>01895   <span class="keywordflow">if</span> (feof(fp)) {
<a name="l01896"></a>01896     fprintf(stderr, <span class="stringliteral">&quot;didn&#39;t find &lt;Multiconfprojected ...&gt;\n&quot;</span>);
<a name="l01897"></a>01897     <span class="keywordflow">return</span> -1;
<a name="l01898"></a>01898   }
<a name="l01899"></a>01899   <span class="keywordtype">char</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ae51b51057e3a9d5aa3905eed7979dca1">projpar</a>[40];
<a name="l01900"></a>01900   sscanf(buf, <span class="stringliteral">&quot;&lt;Multiconfprojected %d %s&gt;&quot;</span>, &amp;n, projpar);
<a name="l01901"></a>01901   *nstates = n;
<a name="l01902"></a>01902 
<a name="l01903"></a>01903   <span class="comment">// read the Slater determinants</span>
<a name="l01904"></a>01904   *slaterdetfilep = (<span class="keywordtype">char</span>**) malloc(n*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
<a name="l01905"></a>01905   <span class="keywordflow">for</span> (i=0; i&lt;n; i++)
<a name="l01906"></a>01906     (*slaterdetfilep)[i] = (<span class="keywordtype">char</span>*) malloc(255*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01907"></a>01907   *Qp = malloc(n*<span class="keyword">sizeof</span>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>));
<a name="l01908"></a>01908   *Sp = malloc(n*<span class="keyword">sizeof</span>(<a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a>));
<a name="l01909"></a>01909   <span class="keywordtype">int</span> fileS;
<a name="l01910"></a>01910   <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
<a name="l01911"></a>01911     <span class="keywordflow">do</span>  
<a name="l01912"></a>01912       fgets(buf, <a class="code" href="DiClusterMulticonfig_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l01913"></a>01913     <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;MBFile &quot;</span>, 7) &amp;&amp; !feof(fp));
<a name="l01914"></a>01914     <span class="keywordflow">if</span> (feof(fp)) {
<a name="l01915"></a>01915       fprintf(stderr, <span class="stringliteral">&quot;...   did&#39;t find &lt;SlaterDetFile ...&gt;\n&quot;</span>);
<a name="l01916"></a>01916       fclose(fp);
<a name="l01917"></a>01917       <span class="keywordflow">return</span> -1;
<a name="l01918"></a>01918     }
<a name="l01919"></a>01919     sscanf(buf, <span class="stringliteral">&quot;&lt;MBFile %s %s %d&gt;&quot;</span>, sldetfname, md5sldetfname, &amp;fileS);
<a name="l01920"></a>01920     <span class="keywordflow">if</span> (strncmp(md5sldetfname, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(sldetfname), 32)) {
<a name="l01921"></a>01921       fprintf(stderr, <span class="stringliteral">&quot;...    SlaterDetFile %s changed\n&quot;</span>, sldetfname);
<a name="l01922"></a>01922       <span class="keywordflow">return</span> -1;
<a name="l01923"></a>01923     }
<a name="l01924"></a>01924     strcpy((*slaterdetfilep)[i], sldetfname);
<a name="l01925"></a>01925     <span class="keywordflow">if</span> (<a class="code" href="SlaterDet_8c.html#a3ebf34d0b05c3dcde99a34ddb61c49e4">readSlaterDetfromFile</a>(&amp;(*Qp)[i], sldetfname))
<a name="l01926"></a>01926       <span class="keywordflow">return</span> -1;
<a name="l01927"></a>01927     (*Sp)[i] = fileS;
<a name="l01928"></a>01928   }
<a name="l01929"></a>01929   
<a name="l01930"></a>01930   <span class="comment">// odd or even ?</span>
<a name="l01931"></a>01931   <span class="keywordtype">int</span> odd = Qp[0]-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> % 2;
<a name="l01932"></a>01932 
<a name="l01933"></a>01933   <span class="comment">// initialize Projection</span>
<a name="l01934"></a>01934   <a class="code" href="Projection_8c.html#a8933a4a47f0572f2e2943562cd45aac5">initProjection</a>(P, odd, projpar);
<a name="l01935"></a>01935 
<a name="l01936"></a>01936   <span class="comment">// read the Eigenstates</span>
<a name="l01937"></a>01937   <span class="keywordflow">if</span> (<a class="code" href="Projection_8c.html#a21bd7a5920ce98dea99f5ecbe591b799">readEigenstates</a>(fp, P, E, n))
<a name="l01938"></a>01938     <span class="keywordflow">return</span> -1;
<a name="l01939"></a>01939 
<a name="l01940"></a>01940   <span class="keywordflow">return</span> 0;
<a name="l01941"></a>01941 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 4 2012 14:05:34 for FMD by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
