<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FMD: fmd/SlaterDet.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>fmd/SlaterDet.c</h1>  </div>
</div>
<div class="contents">
<a href="SlaterDet_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;complex.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;<a class="code" href="Gaussian_8h.html">Gaussian.h</a>&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="SlaterDet_8h.html">SlaterDet.h</a>&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="CenterofMass_8h.html">CenterofMass.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="SpatialOrientation_8h.html">SpatialOrientation.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="cmath_8h.html">numerics/cmath.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="cmat_8h.html">numerics/cmat.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="rotationmatrices_8h.html">numerics/rotationmatrices.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="lapack_8h.html">numerics/lapack.h</a>&quot;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="utils_8h.html">misc/utils.h</a>&quot;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a><a class="code" href="SlaterDet_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">00029</a> <span class="preprocessor">#define SQR(x) (x)*(x)</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="SlaterDet_8h.html#a0fe6e8eefc302957926038529e37e7c9">00032</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a0fe6e8eefc302957926038529e37e7c9" title="allocate memory for SlaterDet">allocateSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keywordtype">int</span> A)
<a name="l00033"></a>00033 {
<a name="l00034"></a>00034   Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> = A;
<a name="l00035"></a>00035   Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a> = malloc(A*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00036"></a>00036   Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a> = malloc(A*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00037"></a>00037   Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a> = malloc(<a class="code" href="sldet2fmdpara_8c.html#a8fe56bf98987252342a9cb3a3efb61f5">MAXNG</a>*A*<span class="keyword">sizeof</span>(<a class="code" href="structGaussian.html">Gaussian</a>));
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="SlaterDet_8h.html#a16db6f53cfee239b7d506c86bc372686">00041</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a16db6f53cfee239b7d506c86bc372686">initSlaterDet</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>)
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043   assert(Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a> &lt;= <a class="code" href="sldet2fmdpara_8c.html#a8fe56bf98987252342a9cb3a3efb61f5">MAXNG</a>*Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>);
<a name="l00044"></a>00044   Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> = Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>;
<a name="l00045"></a>00045   Qp-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a> = Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047   Qp-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a> = malloc(Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00048"></a>00048   Qp-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a> = malloc(Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00049"></a>00049   Qp-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a> = malloc(<a class="code" href="sldet2fmdpara_8c.html#a8fe56bf98987252342a9cb3a3efb61f5">MAXNG</a>*Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<a class="code" href="structGaussian.html">Gaussian</a>));
<a name="l00050"></a>00050 }
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 
<a name="l00053"></a><a class="code" href="SlaterDet_8h.html#adc279637790bc3303e9dca688966a7ab">00053</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#adc279637790bc3303e9dca688966a7ab" title="free memory used by Slater determinant Q">freeSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>)
<a name="l00054"></a>00054 {
<a name="l00055"></a>00055   free(Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>);
<a name="l00056"></a>00056   free(Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>);
<a name="l00057"></a>00057   free(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>);
<a name="l00058"></a>00058 }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="SlaterDet_8h.html#a1046a070a040e038cac232d20a205093">00061</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a1046a070a040e038cac232d20a205093" title="write parameters of Slater determinant Q in file">writeSlaterDet</a>(FILE* fp, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>)
<a name="l00062"></a>00062 {
<a name="l00063"></a>00063   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, i, idx;
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   fprintf(fp, <span class="stringliteral">&quot;&lt;SlaterDet&gt;\n&quot;</span>);
<a name="l00066"></a>00066   fprintf(fp, <span class="stringliteral">&quot;%d %d %d\n&quot;</span>, Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>, Q-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a>, Q-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>);
<a name="l00067"></a>00067   fprintf(fp, <span class="stringliteral">&quot;%d\n&quot;</span>, Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>);
<a name="l00068"></a>00068   <span class="keywordflow">for</span> (k=0; k&lt;Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; k++)
<a name="l00069"></a>00069     <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[k]; i++) {
<a name="l00070"></a>00070       idx = Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[k]+i;
<a name="l00071"></a>00071       fprintf(fp,
<a name="l00072"></a>00072               <span class="stringliteral">&quot;%2d  %+2d  (%12.8f,%12.8f)(%12.8f,%12.8f)  (%12.8f,%12.8f)  (%12.8f,%12.8f)(%12.8f,%12.8f)(%12.8f,%12.8f)\n&quot;</span>,
<a name="l00073"></a>00073             k, Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a>, 
<a name="l00074"></a>00074             creal(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[0]), cimag(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[0]), 
<a name="l00075"></a>00075             creal(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[1]), cimag(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[1]),
<a name="l00076"></a>00076             creal(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>), cimag(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a>),
<a name="l00077"></a>00077             creal(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[0]), cimag(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[0]),
<a name="l00078"></a>00078             creal(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[1]), cimag(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[1]),
<a name="l00079"></a>00079             creal(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[2]), cimag(Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[idx].<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[2]));
<a name="l00080"></a>00080   }
<a name="l00081"></a>00081 
<a name="l00082"></a>00082   fprintf(fp, <span class="stringliteral">&quot;&lt;/SlaterDet&gt;\n&quot;</span>);
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 
<a name="l00086"></a><a class="code" href="SlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">00086</a> <span class="preprocessor">#define BUFSIZE 255</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a><a class="code" href="SlaterDet_8h.html#a45f5f0c4355fdf5dc10d5a5de969da62">00088</a> <span class="keywordtype">int</span> <a class="code" href="SlaterDet_8c.html#a45f5f0c4355fdf5dc10d5a5de969da62">readSlaterDet</a>(FILE* fp, <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>)
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090   <span class="keywordtype">char</span> buf[BUFSIZE];
<a name="l00091"></a>00091   <span class="keywordtype">int</span> i;
<a name="l00092"></a>00092   
<a name="l00093"></a>00093   <span class="keywordflow">do</span>
<a name="l00094"></a>00094     fgets(buf, <a class="code" href="SlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l00095"></a>00095   <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;SlaterDet&gt;&quot;</span>, 11) &amp;&amp; !feof(fp));
<a name="l00096"></a>00096   <span class="keywordflow">if</span> (feof(fp)) {
<a name="l00097"></a>00097     fprintf(stderr, <span class="stringliteral">&quot;did&#39;t find &lt;SlaterDet&gt;\n&quot;</span>);
<a name="l00098"></a>00098     <span class="keywordflow">return</span> -1;
<a name="l00099"></a>00099   }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   fgets(buf, <a class="code" href="SlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l00102"></a>00102   <span class="keywordflow">if</span> (sscanf(buf, <span class="stringliteral">&quot;%d %d %d&quot;</span>, &amp;Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>, &amp;Q-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a>, &amp;Q-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>) != 3) {
<a name="l00103"></a>00103     fprintf(stderr, <span class="stringliteral">&quot;malformed line\n&gt;&gt;%s&lt;&lt;\n&quot;</span>, <a class="code" href="utils_8c.html#af86aada130a5db5b0f52154718d67c44" title="strips strip from str">stripstr</a>(buf, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00104"></a>00104     <span class="keywordflow">return</span> -1;
<a name="l00105"></a>00105   }
<a name="l00106"></a>00106   <span class="keywordflow">if</span> (Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> != Q-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a>+Q-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>) {
<a name="l00107"></a>00107     fprintf(stderr, <span class="stringliteral">&quot;proton and neutron number don&#39;t sum up in line\n&gt;&gt;%s&lt;&lt;\n&quot;</span>,
<a name="l00108"></a>00108             <a class="code" href="utils_8c.html#af86aada130a5db5b0f52154718d67c44" title="strips strip from str">stripstr</a>(buf, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00109"></a>00109     <span class="keywordflow">return</span> -1;
<a name="l00110"></a>00110   }
<a name="l00111"></a>00111   fgets(buf, <a class="code" href="SlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l00112"></a>00112   <span class="keywordflow">if</span> (sscanf(buf, <span class="stringliteral">&quot;%d&quot;</span>, &amp;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>) != 1) {
<a name="l00113"></a>00113     fprintf(stderr, <span class="stringliteral">&quot;malformed line\n&gt;&gt;%s&lt;&lt;\n&quot;</span>, <a class="code" href="utils_8c.html#af86aada130a5db5b0f52154718d67c44" title="strips strip from str">stripstr</a>(buf, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00114"></a>00114     <span class="keywordflow">return</span> -1;
<a name="l00115"></a>00115   }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a> = malloc(Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00118"></a>00118   Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a> = malloc(Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00119"></a>00119   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; i++) {
<a name="l00120"></a>00120     Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[i] = 0;
<a name="l00121"></a>00121     Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[i] = 0;
<a name="l00122"></a>00122   }
<a name="l00123"></a>00123   Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a> = malloc(<a class="code" href="sldet2fmdpara_8c.html#a8fe56bf98987252342a9cb3a3efb61f5">MAXNG</a>*Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<a class="code" href="structGaussian.html">Gaussian</a>));
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, xi;
<a name="l00126"></a>00126   <span class="keywordtype">double</span> chi0re, chi0im, chi1re, chi1im;
<a name="l00127"></a>00127   <span class="keywordtype">double</span> are, aim, b0re, b0im, b1re, b1im, b2re, b2im; 
<a name="l00128"></a>00128   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++) {
<a name="l00129"></a>00129     fgets(buf, <a class="code" href="SlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l00130"></a>00130     <span class="keywordflow">if</span> (sscanf(buf, <span class="stringliteral">&quot;%d %d &quot;</span>
<a name="l00131"></a>00131                <span class="stringliteral">&quot;(%lf,%lf) (%lf,%lf) (%lf,%lf) (%lf,%lf) (%lf,%lf) (%lf,%lf)&quot;</span>, 
<a name="l00132"></a>00132                &amp;k, &amp;xi, &amp;chi0re, &amp;chi0im, &amp;chi1re, &amp;chi1im, 
<a name="l00133"></a>00133                &amp;are, &amp;aim, &amp;b0re, &amp;b0im, &amp;b1re, &amp;b1im, &amp;b2re, &amp;b2im) != 14) {
<a name="l00134"></a>00134       fprintf(stderr, <span class="stringliteral">&quot;malformed line\n&gt;&gt;%s&lt;&lt;\n&quot;</span>, 
<a name="l00135"></a>00135               <a class="code" href="utils_8c.html#af86aada130a5db5b0f52154718d67c44" title="strips strip from str">stripstr</a>(buf,<span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00136"></a>00136       <span class="keywordflow">return</span> -1;
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138     Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[k]++;
<a name="l00139"></a>00139     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i].<a class="code" href="structGaussian.html#a3102697cdce1aedb094cd515f6cd5a47" title="isospin +/- 1 (proton/neutron)">xi</a> = xi;
<a name="l00140"></a>00140     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i].<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[0] = chi0re + <a class="code" href="md5_8c.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>*chi0im;
<a name="l00141"></a>00141     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i].<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[1] = chi1re + <a class="code" href="md5_8c.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>*chi1im;
<a name="l00142"></a>00142     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i].<a class="code" href="structGaussian.html#a4d7abfae9328f879eb63aa513d57fd74" title="complex width">a</a> = are + <a class="code" href="md5_8c.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>*aim;
<a name="l00143"></a>00143     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i].<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[0] = b0re + <a class="code" href="md5_8c.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>*b0im;
<a name="l00144"></a>00144     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i].<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[1] = b1re + <a class="code" href="md5_8c.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>*b1im;
<a name="l00145"></a>00145     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i].<a class="code" href="structGaussian.html#aad8e447fed578c05fdda15ffcb15c590" title="complex position in phase space">b</a>[2] = b2re + <a class="code" href="md5_8c.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>*b2im;
<a name="l00146"></a>00146   }     
<a name="l00147"></a>00147   <span class="keywordflow">for</span> (k=1; k&lt;Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; k++) 
<a name="l00148"></a>00148     Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[k] = Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[k-1]+Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[k-1];
<a name="l00149"></a>00149          
<a name="l00150"></a>00150   fgets(buf, <a class="code" href="SlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l00151"></a>00151   <span class="keywordflow">if</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;/SlaterDet&gt;&quot;</span>, 12)) {
<a name="l00152"></a>00152     fprintf(stderr, <span class="stringliteral">&quot;did&#39;t find &lt;/SlaterDet&gt;\n&quot;</span>);
<a name="l00153"></a>00153     <span class="keywordflow">return</span> -1;
<a name="l00154"></a>00154   }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="keywordflow">return</span> 0;
<a name="l00157"></a>00157 }
<a name="l00158"></a>00158   
<a name="l00159"></a>00159 
<a name="l00162"></a><a class="code" href="SlaterDet_8h.html#a3ebf34d0b05c3dcde99a34ddb61c49e4">00162</a> <span class="keywordtype">int</span> <a class="code" href="SlaterDet_8c.html#a3ebf34d0b05c3dcde99a34ddb61c49e4">readSlaterDetfromFile</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <span class="keywordtype">char</span>* fname)
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164   FILE* fp;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166   <span class="keywordflow">if</span> (!(fp = fopen(fname, <span class="stringliteral">&quot;r&quot;</span>))) {  
<a name="l00167"></a>00167     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for reading\n&quot;</span>, fname);
<a name="l00168"></a>00168     <span class="keywordflow">return</span> -1;
<a name="l00169"></a>00169   }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   fprintf(stderr, <span class="stringliteral">&quot;... reading SlaterDet from file %s\n&quot;</span>, fname);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="keywordtype">int</span> err = <a class="code" href="SlaterDet_8c.html#a45f5f0c4355fdf5dc10d5a5de969da62">readSlaterDet</a>(fp, Q);
<a name="l00174"></a>00174   fclose(fp);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176   <span class="keywordflow">return</span> err;
<a name="l00177"></a>00177 }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 
<a name="l00180"></a><a class="code" href="SlaterDet_8h.html#acd974ea424b0829a55ada79fc69abd90">00180</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#acd974ea424b0829a55ada79fc69abd90">copySlaterDet</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>) 
<a name="l00181"></a>00181 {
<a name="l00182"></a>00182   <span class="keywordtype">int</span> i;
<a name="l00183"></a>00183   
<a name="l00184"></a>00184   assert(Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> &gt;= Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>);
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> = Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>;
<a name="l00187"></a>00187   Qp-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> = Q-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a>; Qp-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a> = Q-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>;
<a name="l00188"></a>00188   Qp-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a> = Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00189"></a>00189   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; i++) {
<a name="l00190"></a>00190     Qp-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[i] = Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[i];
<a name="l00191"></a>00191     Qp-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[i] = Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[i];
<a name="l00192"></a>00192   }
<a name="l00193"></a>00193   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++)
<a name="l00194"></a>00194     Qp-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i] = Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i];
<a name="l00195"></a>00195 }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 
<a name="l00198"></a><a class="code" href="SlaterDet_8h.html#a95061fbc1f289e0ad28e565933af63e9">00198</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a95061fbc1f289e0ad28e565933af63e9">cloneSlaterDet</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>)
<a name="l00199"></a>00199 {
<a name="l00200"></a>00200   Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> = Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>;
<a name="l00201"></a>00201   Qp-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a> = Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   Qp-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a> = malloc(Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00204"></a>00204   Qp-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a> = malloc(Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00205"></a>00205   Qp-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a> = malloc(<a class="code" href="sldet2fmdpara_8c.html#a8fe56bf98987252342a9cb3a3efb61f5">MAXNG</a>*Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<a class="code" href="structGaussian.html">Gaussian</a>));
<a name="l00206"></a>00206 
<a name="l00207"></a>00207   <a class="code" href="SlaterDet_8c.html#acd974ea424b0829a55ada79fc69abd90">copySlaterDet</a>(Q, Qp);
<a name="l00208"></a>00208 }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 
<a name="l00211"></a><a class="code" href="SlaterDet_8h.html#afdaa23393bbb93aad62823a8365f6810">00211</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#afdaa23393bbb93aad62823a8365f6810">joinSlaterDets</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* Qa, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* Qb, <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213   Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> = Qa-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>+Qb-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>;
<a name="l00214"></a>00214   Q-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> = Qa-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a>+Qb-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a>;
<a name="l00215"></a>00215   Q-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a> = Qa-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>+Qb-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>;
<a name="l00216"></a>00216   Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a> = Qa-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>+Qb-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a> = malloc(Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00219"></a>00219   Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a> = malloc(Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00220"></a>00220   Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a> = malloc(<a class="code" href="sldet2fmdpara_8c.html#a8fe56bf98987252342a9cb3a3efb61f5">MAXNG</a>*Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>*<span class="keyword">sizeof</span>(<a class="code" href="structGaussian.html">Gaussian</a>));
<a name="l00221"></a>00221 
<a name="l00222"></a>00222   <span class="keywordtype">int</span> i;
<a name="l00223"></a>00223   <span class="comment">// copy Qa</span>
<a name="l00224"></a>00224   <span class="keywordflow">for</span> (i=0; i&lt;Qa-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; i++) {
<a name="l00225"></a>00225     Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[i] = Qa-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[i];
<a name="l00226"></a>00226     Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[i] = Qa-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[i];
<a name="l00227"></a>00227   }
<a name="l00228"></a>00228   <span class="keywordflow">for</span> (i=0; i&lt;Qa-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++)
<a name="l00229"></a>00229     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i] = Qa-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i];
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   <span class="comment">// copy Qb</span>
<a name="l00232"></a>00232   for (i=0; i&lt;Qb-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; i++) {
<a name="l00233"></a>00233     Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[i+Qa-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>] = Qb-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>[i]+Qa-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00234"></a>00234     Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[i+Qa-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>] = Qb-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>[i];
<a name="l00235"></a>00235   }
<a name="l00236"></a>00236   <span class="keywordflow">for</span> (i=0; i&lt;Qb-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++) 
<a name="l00237"></a>00237     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i+Qa-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>] = Qb-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i];
<a name="l00238"></a>00238 }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 
<a name="l00241"></a><a class="code" href="SlaterDet_8h.html#a6a41a03f939c76a6a27eb78fd46a1ebc">00241</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a6a41a03f939c76a6a27eb78fd46a1ebc" title="normalize SlaterDet">normalizeSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243   <a class="code" href="SlaterDet_8c.html#ad3679a655d9b6019619456e5b7961638">calcSlaterDetAuxod</a>(Q, Q, X);
<a name="l00244"></a>00244   <span class="keywordtype">double</span> norm = sqrt(creal(X-&gt;<a class="code" href="structSlaterDetAux.html#a19bee32579f8dd37e4834f06f07a231f" title="&amp;lt;Q|Q&amp;#39;&amp;gt;, only defined for non-diagonal">ovlap</a>));
<a name="l00245"></a>00245   <span class="keywordtype">double</span> normsp = pow(norm, 1.0/Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="keywordtype">int</span> i;
<a name="l00248"></a>00248   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++) {
<a name="l00249"></a>00249     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i].<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[0] /= normsp;
<a name="l00250"></a>00250     Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i].<a class="code" href="structGaussian.html#a95da0e93add3c73c0fef74054aaf5c21" title="complex spinor, additional freedom to give norm and phase">chi</a>[1] /= normsp;
<a name="l00251"></a>00251   }
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 
<a name="l00255"></a><a class="code" href="SlaterDet_8h.html#a5463a8afc7565b2711169b605aad5ca3">00255</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a5463a8afc7565b2711169b605aad5ca3" title="move Slater determinant by vector d">moveSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keywordtype">double</span> d[3])
<a name="l00256"></a>00256 {
<a name="l00257"></a>00257   <span class="keywordtype">int</span> i;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++)
<a name="l00260"></a>00260     <a class="code" href="Gaussian_8c.html#af8befaf2546d597e54846b354c988547" title="move Gaussian by d">moveGaussian</a>(&amp;Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i], d);
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 
<a name="l00264"></a><a class="code" href="SlaterDet_8h.html#ad154093b24c00e82ac9129d87cd2e049">00264</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#ad154093b24c00e82ac9129d87cd2e049" title="boost Slater determinant with speed v">boostSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keywordtype">double</span> v[3])
<a name="l00265"></a>00265 {
<a name="l00266"></a>00266   <span class="keywordtype">int</span> i;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++)
<a name="l00269"></a>00269     <a class="code" href="Gaussian_8c.html#ace1c71776a4249cf993a3caa6c93fd6f" title="boost Gaussian by v">boostGaussian</a>(&amp;Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i], v);
<a name="l00270"></a>00270 }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 
<a name="l00273"></a><a class="code" href="SlaterDet_8h.html#ae3a4b38044ff7cac304d3258825f4ce8">00273</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#ae3a4b38044ff7cac304d3258825f4ce8" title="move and boost center of mass to origin">moveboostSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00274"></a>00274 {
<a name="l00275"></a>00275   <span class="keywordtype">int</span> i;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="comment">// move SlaterDet to origin in phase space</span>
<a name="l00278"></a>00278 
<a name="l00279"></a>00279   <span class="keywordtype">double</span> Xcm[3], Vcm[3];
<a name="l00280"></a>00280   <a class="code" href="SlaterDet_8c.html#ac1dfa773b90a1f5f6294d6081c412981">calcSlaterDetAux</a>(Q, X);
<a name="l00281"></a>00281   <a class="code" href="CenterofMass_8c.html#a1e6d03a8864c008d5eccd7a0ca7704f0">calcCMPosition</a>(Q, X, Xcm);
<a name="l00282"></a>00282   <a class="code" href="CenterofMass_8c.html#a70f46c8dd6549d99121002d39a5b1e1e">calcCMVelocity</a>(Q, X, Vcm);  
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00285"></a>00285     Vcm[i] *= -1;
<a name="l00286"></a>00286   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00287"></a>00287     Xcm[i] *= -1;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289   <a class="code" href="SlaterDet_8c.html#ad154093b24c00e82ac9129d87cd2e049" title="boost Slater determinant with speed v">boostSlaterDet</a>(Q, Vcm);
<a name="l00290"></a>00290   <a class="code" href="SlaterDet_8c.html#a5463a8afc7565b2711169b605aad5ca3" title="move Slater determinant by vector d">moveSlaterDet</a>(Q, Xcm);
<a name="l00291"></a>00291 }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 
<a name="l00294"></a><a class="code" href="SlaterDet_8h.html#acb9aa75178acc11ffabfb94f0247ee6c">00294</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a8737af9032a8d87843782a88228fef00" title="rotate Slater determinant by euler angles">rotateSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> g)
<a name="l00295"></a>00295 {
<a name="l00296"></a>00296   <span class="keywordtype">double</span> euler[3] = { a, b, g };
<a name="l00297"></a>00297 
<a name="l00298"></a>00298   complex <span class="keywordtype">double</span> R2[2][2];
<a name="l00299"></a>00299   <a class="code" href="rotationmatrices_8c.html#a35bedbe2765f5d99ca0f5fa72e50f0e1" title="spinor rotation matrix">rotatemat2</a>(euler, R2);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   <span class="keywordtype">double</span> R3[3][3];
<a name="l00302"></a>00302   <a class="code" href="rotationmatrices_8c.html#a927b76dce98d7889615bc1118ece7706" title="vector rotation matrix">rotatemat3</a>(euler, R3);
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="keywordtype">int</span> i;
<a name="l00305"></a>00305   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++)
<a name="l00306"></a>00306     <a class="code" href="Gaussian_8c.html#af534f5c66daf844c857fc9cb61ca7693">rotateGaussian</a>(&amp;Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i], R3, R2);
<a name="l00307"></a>00307 }
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 
<a name="l00310"></a><a class="code" href="SlaterDet_8h.html#a3d81dfe0c56874931a3f5ce934cd8786">00310</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a3d81dfe0c56874931a3f5ce934cd8786" title="move and boost center of mass to origin, orient main axes">moveboostorientSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00311"></a>00311 {
<a name="l00312"></a>00312   <span class="keywordtype">int</span> i;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   <span class="comment">// move SlaterDet to origin in phase space</span>
<a name="l00315"></a>00315   <span class="comment">// orient so that min moment of inertia around the z-axes</span>
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   <span class="keywordtype">double</span> Xcm[3], Vcm[3];
<a name="l00318"></a>00318   <a class="code" href="SlaterDet_8c.html#ac1dfa773b90a1f5f6294d6081c412981">calcSlaterDetAux</a>(Q, X);
<a name="l00319"></a>00319   <a class="code" href="CenterofMass_8c.html#a1e6d03a8864c008d5eccd7a0ca7704f0">calcCMPosition</a>(Q, X, Xcm);
<a name="l00320"></a>00320   <a class="code" href="CenterofMass_8c.html#a70f46c8dd6549d99121002d39a5b1e1e">calcCMVelocity</a>(Q, X, Vcm);  
<a name="l00321"></a>00321 
<a name="l00322"></a>00322   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00323"></a>00323     Vcm[i] *= -1;
<a name="l00324"></a>00324   <span class="keywordflow">for</span> (i=0; i&lt;3; i++)
<a name="l00325"></a>00325     Xcm[i] *= -1;
<a name="l00326"></a>00326 
<a name="l00327"></a>00327   <a class="code" href="SlaterDet_8c.html#ad154093b24c00e82ac9129d87cd2e049" title="boost Slater determinant with speed v">boostSlaterDet</a>(Q, Vcm);
<a name="l00328"></a>00328   <a class="code" href="SlaterDet_8c.html#a5463a8afc7565b2711169b605aad5ca3" title="move Slater determinant by vector d">moveSlaterDet</a>(Q, Xcm);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   <span class="comment">// orient the nucleus along the main axes</span>
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <span class="keywordtype">double</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a20f4c4490bc8ecbdd1ffcb79acce6035" title="finestructure constant">alpha</a>, beta, gamma;
<a name="l00333"></a>00333   <a class="code" href="SlaterDet_8c.html#ac1dfa773b90a1f5f6294d6081c412981">calcSlaterDetAux</a>(Q, X);
<a name="l00334"></a>00334   <a class="code" href="SpatialOrientation_8c.html#ac976e85596d5fab5140b3e9cd76ee1a4">calcOrientedOrientation</a>(Q, X, &amp;alpha, &amp;beta, &amp;gamma);
<a name="l00335"></a>00335   <a class="code" href="SlaterDet_8c.html#a8737af9032a8d87843782a88228fef00" title="rotate Slater determinant by euler angles">rotateSlaterDet</a>(Q, -gamma, -beta, -alpha);
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 
<a name="l00339"></a><a class="code" href="SlaterDet_8h.html#a4352c529278dcdf99e15254e4d1ce9c0">00339</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a4352c529278dcdf99e15254e4d1ce9c0" title="orient main axes">orientSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00340"></a>00340 {
<a name="l00341"></a>00341   <span class="comment">// orient the nucleus along the main axes</span>
<a name="l00342"></a>00342 
<a name="l00343"></a>00343   <span class="keywordtype">double</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a20f4c4490bc8ecbdd1ffcb79acce6035" title="finestructure constant">alpha</a>, beta, gamma;
<a name="l00344"></a>00344   <a class="code" href="SlaterDet_8c.html#ac1dfa773b90a1f5f6294d6081c412981">calcSlaterDetAux</a>(Q, X);
<a name="l00345"></a>00345   <a class="code" href="SpatialOrientation_8c.html#ac976e85596d5fab5140b3e9cd76ee1a4">calcOrientedOrientation</a>(Q, X, &amp;alpha, &amp;beta, &amp;gamma);
<a name="l00346"></a>00346   <a class="code" href="SlaterDet_8c.html#a8737af9032a8d87843782a88228fef00" title="rotate Slater determinant by euler angles">rotateSlaterDet</a>(Q, -gamma, -beta, -alpha);
<a name="l00347"></a>00347 }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 
<a name="l00350"></a><a class="code" href="SlaterDet_8h.html#ad0aa11be18d42c1cc26c2ad1380feb2a">00350</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#ad0aa11be18d42c1cc26c2ad1380feb2a" title="invert Slater determinant in origin">invertSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>)
<a name="l00351"></a>00351 {
<a name="l00352"></a>00352   <span class="keywordtype">int</span> i;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++)
<a name="l00355"></a>00355     <a class="code" href="Gaussian_8c.html#a36bcf9e971ac21dc7203e1e000bebb98" title="parity operation with respect to origin">invertGaussian</a>(&amp;Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i]);
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 
<a name="l00359"></a><a class="code" href="SlaterDet_8h.html#afd2f6a81babbbba6094dc63951676a17">00359</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#afd2f6a81babbbba6094dc63951676a17" title="invert Slater determinant with respect to cm position and velocity">invertcmSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00360"></a>00360 {
<a name="l00361"></a>00361   <span class="keywordtype">double</span> Xcm[3], Vcm[3];
<a name="l00362"></a>00362   <span class="keywordtype">int</span> i;
<a name="l00363"></a>00363 
<a name="l00364"></a>00364   <a class="code" href="SlaterDet_8c.html#ac1dfa773b90a1f5f6294d6081c412981">calcSlaterDetAux</a>(Q, X);
<a name="l00365"></a>00365   <a class="code" href="CenterofMass_8c.html#a1e6d03a8864c008d5eccd7a0ca7704f0">calcCMPosition</a>(Q, X, Xcm);
<a name="l00366"></a>00366   <a class="code" href="CenterofMass_8c.html#a70f46c8dd6549d99121002d39a5b1e1e">calcCMVelocity</a>(Q, X, Vcm);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="keywordflow">for</span> (i=0; i&lt;3; i++) {
<a name="l00369"></a>00369     Xcm[i] *= -1;
<a name="l00370"></a>00370     Vcm[i] *= -1;
<a name="l00371"></a>00371   }
<a name="l00372"></a>00372   <a class="code" href="SlaterDet_8c.html#ad154093b24c00e82ac9129d87cd2e049" title="boost Slater determinant with speed v">boostSlaterDet</a>(Q, Vcm);
<a name="l00373"></a>00373   <a class="code" href="SlaterDet_8c.html#a5463a8afc7565b2711169b605aad5ca3" title="move Slater determinant by vector d">moveSlaterDet</a>(Q, Xcm);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <a class="code" href="SlaterDet_8c.html#ad0aa11be18d42c1cc26c2ad1380feb2a" title="invert Slater determinant in origin">invertSlaterDet</a>(Q);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377   <span class="keywordflow">for</span> (i=0; i&lt;3; i++) {
<a name="l00378"></a>00378     Xcm[i] *= -1;
<a name="l00379"></a>00379     Vcm[i] *= -1;
<a name="l00380"></a>00380   }
<a name="l00381"></a>00381   <a class="code" href="SlaterDet_8c.html#a5463a8afc7565b2711169b605aad5ca3" title="move Slater determinant by vector d">moveSlaterDet</a>(Q, Xcm);
<a name="l00382"></a>00382   <a class="code" href="SlaterDet_8c.html#ad154093b24c00e82ac9129d87cd2e049" title="boost Slater determinant with speed v">boostSlaterDet</a>(Q, Vcm);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 
<a name="l00387"></a><a class="code" href="SlaterDet_8h.html#aea63bd7a51a1011e0e2024429f41c6e6">00387</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#aea63bd7a51a1011e0e2024429f41c6e6" title="time revert Slater determinant">timerevertSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>)
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389   <span class="keywordtype">int</span> i;
<a name="l00390"></a>00390 
<a name="l00391"></a>00391   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++)
<a name="l00392"></a>00392     <a class="code" href="Gaussian_8c.html#a32985da262d1721699840a4acc325508" title="time reversal operator">timerevertGaussian</a>(&amp;Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i]);
<a name="l00393"></a>00393 }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 
<a name="l00396"></a><a class="code" href="SlaterDet_8h.html#ad97350a50ef6bd07d50ed483af579542">00396</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#ad97350a50ef6bd07d50ed483af579542" title="scale Slater determinant">scaleSlaterDet</a>(<a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keywordtype">double</span> kappa)
<a name="l00397"></a>00397 {
<a name="l00398"></a>00398   <span class="keywordtype">int</span> i;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400   <span class="keywordflow">for</span> (i=0; i&lt;Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; i++)
<a name="l00401"></a>00401     <a class="code" href="Gaussian_8c.html#ad9bf36d5b778c0f741e398e2c9aa44d9" title="scale lengths by kappa">scaleGaussian</a>(&amp;Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>[i], kappa);
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 
<a name="l00405"></a><a class="code" href="SlaterDet_8h.html#a6489b81747a0bf6bab1e09d136f45065">00405</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a6489b81747a0bf6bab1e09d136f45065" title="allocate memory for SlaterDetAux">allocateSlaterDetAux</a>(<a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>, <span class="keywordtype">int</span> A)
<a name="l00406"></a>00406 {
<a name="l00407"></a>00407   X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(<a class="code" href="sldet2fmdpara_8c.html#a8fe56bf98987252342a9cb3a3efb61f5">MAXNG</a>*A)*<span class="keyword">sizeof</span>(<a class="code" href="structGaussianAux.html">GaussianAux</a>));
<a name="l00408"></a>00408   X-&gt;<a class="code" href="structSlaterDetAux.html#a50d38b691498b8b46c3ebd38a3945dd3" title="single particle ovlap matrix n(A,A)">n</a> = <a class="code" href="cmat_8c.html#a2c55a1976c165daaef0aeb57abd17f2b" title="initialize complex nxn matrix">initcmat</a>(A);
<a name="l00409"></a>00409   X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a> = <a class="code" href="cmat_8c.html#a2c55a1976c165daaef0aeb57abd17f2b" title="initialize complex nxn matrix">initcmat</a>(A);
<a name="l00410"></a>00410 }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 <span class="comment">// space is reserved for up to MAXNG Gaussians per nucleon</span>
<a name="l00414"></a><a class="code" href="SlaterDet_8h.html#a9d28b849a027b454fd2eddb812a884c5">00414</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a9d28b849a027b454fd2eddb812a884c5" title="init SlaterDetAux X">initSlaterDetAux</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00415"></a>00415 {
<a name="l00416"></a>00416   assert(Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a> &lt;= <a class="code" href="sldet2fmdpara_8c.html#a8fe56bf98987252342a9cb3a3efb61f5">MAXNG</a>*Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>);
<a name="l00417"></a>00417   X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(<a class="code" href="sldet2fmdpara_8c.html#a8fe56bf98987252342a9cb3a3efb61f5">MAXNG</a>*Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>)*<span class="keyword">sizeof</span>(<a class="code" href="structGaussianAux.html">GaussianAux</a>));
<a name="l00418"></a>00418   X-&gt;<a class="code" href="structSlaterDetAux.html#a50d38b691498b8b46c3ebd38a3945dd3" title="single particle ovlap matrix n(A,A)">n</a> = <a class="code" href="cmat_8c.html#a2c55a1976c165daaef0aeb57abd17f2b" title="initialize complex nxn matrix">initcmat</a>(Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>);
<a name="l00419"></a>00419   X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a> = <a class="code" href="cmat_8c.html#a2c55a1976c165daaef0aeb57abd17f2b" title="initialize complex nxn matrix">initcmat</a>(Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>);
<a name="l00420"></a>00420 }  
<a name="l00421"></a>00421   
<a name="l00422"></a>00422 
<a name="l00423"></a><a class="code" href="SlaterDet_8h.html#a6d10ca2b062d871a6903292600c3125a">00423</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a6d10ca2b062d871a6903292600c3125a" title="free memory used by SlaterDetAux X">freeSlaterDetAux</a>(<a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425   free(X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>);
<a name="l00426"></a>00426   free(X-&gt;<a class="code" href="structSlaterDetAux.html#a50d38b691498b8b46c3ebd38a3945dd3" title="single particle ovlap matrix n(A,A)">n</a>);
<a name="l00427"></a>00427   free(X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>);
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 <span class="comment">// hermiticity of matrices is not exploited</span>
<a name="l00432"></a><a class="code" href="SlaterDet_8h.html#ac1dfa773b90a1f5f6294d6081c412981">00432</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#ac1dfa773b90a1f5f6294d6081c412981">calcSlaterDetAux</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00433"></a>00433 {
<a name="l00434"></a>00434   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; 
<a name="l00435"></a>00435   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00436"></a>00436   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00437"></a>00437   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>,ki,li;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00442"></a>00442     <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00443"></a>00443       <span class="keywordflow">for</span> (k=0; k&lt;A; k++)
<a name="l00444"></a>00444         <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00445"></a>00445           <a class="code" href="Gaussian_8c.html#a4201ab71b543e745407c852ff52a6e13" title="calculate auxiliary quantities for two Gaussians">calcGaussianAux</a>(&amp;G[idx[k]+ki], &amp;G[idx[l]+li], 
<a name="l00446"></a>00446                           &amp;Gaux[(idx[k]+ki)+(idx[l]+li)*ngauss]);
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   <span class="keywordflow">for</span> (l=0; l&lt;A; l++) 
<a name="l00450"></a>00450     <span class="keywordflow">for</span> (k=0; k&lt;A; k++) {
<a name="l00451"></a>00451       X-&gt;<a class="code" href="structSlaterDetAux.html#a50d38b691498b8b46c3ebd38a3945dd3" title="single particle ovlap matrix n(A,A)">n</a>[k+l*A] = 0.0;
<a name="l00452"></a>00452       <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00453"></a>00453         <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00454"></a>00454           X-&gt;<a class="code" href="structSlaterDetAux.html#a50d38b691498b8b46c3ebd38a3945dd3" title="single particle ovlap matrix n(A,A)">n</a>[k+l*A] += Gaux[(idx[k]+ki)+(idx[l]+li)*ngauss].Q;
<a name="l00455"></a>00455     }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="keywordtype">char</span> UPLO=<span class="charliteral">&#39;U&#39;</span>;
<a name="l00458"></a>00458   <span class="keywordtype">int</span> info;
<a name="l00459"></a>00459 
<a name="l00460"></a>00460   <a class="code" href="cmat_8c.html#a25c4069e471b679af8dfdf807f30cd5a" title="copy matrix A into B">copycmat</a>(A, X-&gt;<a class="code" href="structSlaterDetAux.html#a50d38b691498b8b46c3ebd38a3945dd3" title="single particle ovlap matrix n(A,A)">n</a>, X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>);
<a name="l00461"></a>00461   <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#ae9da3f49c13b8f99c7017b05a7e40dcd" title="cholesky factorization of complex Hermitian positive definite matrix A">zpotrf</a>)(&amp;UPLO, &amp;A, X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>, &amp;A, &amp;info);
<a name="l00462"></a>00462   <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#a0d0c3c5dbc1ba1328f61aef8a29ef11b">zpotri</a>)(&amp;UPLO, &amp;A, X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>, &amp;A, &amp;info);
<a name="l00463"></a>00463   <a class="code" href="cmat_8c.html#ae1c4783c61266d516df6ce359dc3c284" title="mirror upper triangle of hermitian matrix into lower triangle">mirrorcmat</a>(A, X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>);
<a name="l00464"></a>00464 }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 
<a name="l00468"></a><a class="code" href="SlaterDet_8h.html#ad3679a655d9b6019619456e5b7961638">00468</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#ad3679a655d9b6019619456e5b7961638">calcSlaterDetAuxod</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00469"></a>00469                         <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00470"></a>00470 {
<a name="l00471"></a>00471   assert(Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> == Qp-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> &amp;&amp; Q-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> == Qp-&gt;<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> &amp;&amp; Q-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a> == Qp-&gt;<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00474"></a>00474   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* idxp=Qp-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; 
<a name="l00475"></a>00475   <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>; <span class="keywordtype">int</span>* ngp=Qp-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00476"></a>00476   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>; <a class="code" href="structGaussian.html">Gaussian</a>* Gp=Qp-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00477"></a>00477   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00478"></a>00478   complex <span class="keywordtype">double</span>* <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=X-&gt;<a class="code" href="structSlaterDetAux.html#a50d38b691498b8b46c3ebd38a3945dd3" title="single particle ovlap matrix n(A,A)">n</a>;
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>,ki,li;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00483"></a>00483     <span class="keywordflow">for</span> (li=0; li&lt;ngp[l]; li++)
<a name="l00484"></a>00484       <span class="keywordflow">for</span> (k=0; k&lt;A; k++)
<a name="l00485"></a>00485         <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00486"></a>00486           <a class="code" href="Gaussian_8c.html#a4201ab71b543e745407c852ff52a6e13" title="calculate auxiliary quantities for two Gaussians">calcGaussianAux</a>(&amp;G[idx[k]+ki], &amp;Gp[idxp[l]+li], 
<a name="l00487"></a>00487                           &amp;Gaux[(idx[k]+ki)+(idxp[l]+li)*ngauss]);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 
<a name="l00490"></a>00490   <span class="keywordflow">for</span> (l=0; l&lt;A; l++) 
<a name="l00491"></a>00491     <span class="keywordflow">for</span> (k=0; k&lt;A; k++) {
<a name="l00492"></a>00492       n[k+l*A] = 0.0;
<a name="l00493"></a>00493       <span class="keywordflow">for</span> (li=0; li&lt;ngp[l]; li++)
<a name="l00494"></a>00494         <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00495"></a>00495           n[k+l*A] += Gaux[(idx[k]+ki)+(idxp[l]+li)*ngauss].Q;
<a name="l00496"></a>00496     }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   <span class="keywordtype">int</span> ipiv[A];
<a name="l00500"></a>00500   <span class="keywordtype">int</span> lwork=A*A;
<a name="l00501"></a>00501   complex <span class="keywordtype">double</span> work[lwork];
<a name="l00502"></a>00502   <span class="keywordtype">int</span> info;
<a name="l00503"></a>00503   
<a name="l00504"></a>00504   <a class="code" href="cmat_8c.html#a25c4069e471b679af8dfdf807f30cd5a" title="copy matrix A into B">copycmat</a>(A, X-&gt;<a class="code" href="structSlaterDetAux.html#a50d38b691498b8b46c3ebd38a3945dd3" title="single particle ovlap matrix n(A,A)">n</a>, X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>);
<a name="l00505"></a>00505   <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#ae87f81c04c9dcd293299f610428d3cb3" title="compute an LU factorization of a general M-by-N matrix A">zgetrf</a>)(&amp;A, &amp;A, X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>, &amp;A, ipiv, &amp;info);
<a name="l00506"></a>00506   <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#a45cd458d60d896788dc5024019d30828">zdet</a>)(X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>, &amp;A, &amp;A, ipiv, &amp;X-&gt;<a class="code" href="structSlaterDetAux.html#a19bee32579f8dd37e4834f06f07a231f" title="&amp;lt;Q|Q&amp;#39;&amp;gt;, only defined for non-diagonal">ovlap</a>);
<a name="l00507"></a>00507   <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#a28dff83214199a090e2d62becf3a7bca">zgetri</a>)(&amp;A, X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>, &amp;A, ipiv, work, &amp;lwork, &amp;info);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509   <span class="keywordflow">if</span> (info)
<a name="l00510"></a>00510     fprintf(stderr, <span class="stringliteral">&quot;calcSlaterDetAuxod: overlap matrix singular !\n&quot;</span>);
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 <span class="comment">// sort of a hack</span>
<a name="l00515"></a>00515 <span class="comment">// calculate cofactors by using the svd </span>
<a name="l00516"></a>00516 <span class="comment">// assume rank A-1 for overlap matrix</span>
<a name="l00517"></a>00517 <span class="comment">// ovlap is set to 1 </span>
<a name="l00518"></a>00518 <span class="comment">// only use for off-diagonal matrix elements of One-Body Operators</span>
<a name="l00519"></a>00519 <span class="comment">// broken for Two-body Operators</span>
<a name="l00520"></a><a class="code" href="SlaterDet_8h.html#a861e4c675c3918393d69a81090376053">00520</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a861e4c675c3918393d69a81090376053">calcSlaterDetAuxodsingular</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00521"></a>00521                                 <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>)
<a name="l00522"></a>00522 {
<a name="l00523"></a>00523   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00524"></a>00524   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* idxp=Qp-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; 
<a name="l00525"></a>00525   <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>; <span class="keywordtype">int</span>* ngp=Qp-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00526"></a>00526   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>; <a class="code" href="structGaussian.html">Gaussian</a>* Gp=Qp-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00527"></a>00527   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00528"></a>00528   complex <span class="keywordtype">double</span>* <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=X-&gt;<a class="code" href="structSlaterDetAux.html#a50d38b691498b8b46c3ebd38a3945dd3" title="single particle ovlap matrix n(A,A)">n</a>;
<a name="l00529"></a>00529   complex <span class="keywordtype">double</span>* o=X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>;
<a name="l00530"></a>00530 
<a name="l00531"></a>00531   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>,ki,li;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00534"></a>00534     <span class="keywordflow">for</span> (li=0; li&lt;ngp[l]; li++)
<a name="l00535"></a>00535       <span class="keywordflow">for</span> (k=0; k&lt;A; k++)
<a name="l00536"></a>00536         <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00537"></a>00537           <a class="code" href="Gaussian_8c.html#a4201ab71b543e745407c852ff52a6e13" title="calculate auxiliary quantities for two Gaussians">calcGaussianAux</a>(&amp;G[idx[k]+ki], &amp;Gp[idxp[l]+li], 
<a name="l00538"></a>00538                           &amp;Gaux[(idx[k]+ki)+(idxp[l]+li)*ngauss]);
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 
<a name="l00541"></a>00541   <span class="keywordflow">for</span> (l=0; l&lt;A; l++) 
<a name="l00542"></a>00542     <span class="keywordflow">for</span> (k=0; k&lt;A; k++) {
<a name="l00543"></a>00543       n[k+l*A] = 0.0;
<a name="l00544"></a>00544       <span class="keywordflow">for</span> (li=0; li&lt;ngp[l]; li++)
<a name="l00545"></a>00545         <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00546"></a>00546           n[k+l*A] += Gaux[(idx[k]+ki)+(idxp[l]+li)*ngauss].Q;
<a name="l00547"></a>00547     }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="comment">// calculate SVD of overlap matrix</span>
<a name="l00550"></a>00550   complex <span class="keywordtype">double</span> U[A*A];
<a name="l00551"></a>00551   complex <span class="keywordtype">double</span> Vh[A*A];
<a name="l00552"></a>00552   <span class="keywordtype">double</span> S[A];
<a name="l00553"></a>00553   {
<a name="l00554"></a>00554     <span class="keyword">const</span> <span class="keywordtype">char</span> jobu=<span class="charliteral">&#39;A&#39;</span>, jobvt=<span class="charliteral">&#39;A&#39;</span>;
<a name="l00555"></a>00555     <span class="keyword">const</span> <span class="keywordtype">int</span> lwork=5*A;
<a name="l00556"></a>00556     complex <span class="keywordtype">double</span> work[lwork];
<a name="l00557"></a>00557     <span class="keywordtype">double</span> rwork[lwork];
<a name="l00558"></a>00558     <span class="keywordtype">int</span> info;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560     <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#abeeaa93428c215c1d1052c3322b4a6a2" title="compute the singular value decomposition (SVD) of a complex matrix">zgesvd</a>)(&amp;jobu, &amp;jobvt, &amp;A, &amp;A, n, &amp;A, S,
<a name="l00561"></a>00561                     U, &amp;A, Vh, &amp;A, work, &amp;lwork, rwork, &amp;info);
<a name="l00562"></a>00562   }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564   <span class="comment">// calculate phase detVhU using LU decomposition</span>
<a name="l00565"></a>00565   complex <span class="keywordtype">double</span> detVhU;
<a name="l00566"></a>00566   {
<a name="l00567"></a>00567     complex <span class="keywordtype">double</span> VhU[A*A];
<a name="l00568"></a>00568     <span class="keywordtype">int</span> ipiv[A];
<a name="l00569"></a>00569     <span class="keywordtype">int</span> info;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571     <a class="code" href="cmat_8c.html#a32a89cb47e192550e5d5373dad79bcde" title="multiply complex matrices C = A.B">multcmat</a>(Vh, U, VhU, A);
<a name="l00572"></a>00572     <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#ae87f81c04c9dcd293299f610428d3cb3" title="compute an LU factorization of a general M-by-N matrix A">zgetrf</a>)(&amp;A, &amp;A, VhU, &amp;A, ipiv, &amp;info);
<a name="l00573"></a>00573     <a class="code" href="interpol_8h.html#a742b1a3b3d50237eaf54269ea927f452">FORTRAN</a>(<a class="code" href="lapack_8h.html#a45cd458d60d896788dc5024019d30828">zdet</a>)(VhU, &amp;A, &amp;A, ipiv, &amp;detVhU);
<a name="l00574"></a>00574   }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   <span class="keywordtype">int</span> i,<a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>;
<a name="l00577"></a>00577   <span class="keywordtype">double</span> prodS;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   prodS = 1.0;
<a name="l00580"></a>00580   <span class="keywordflow">for</span> (j=0; j&lt;A-1; j++)
<a name="l00581"></a>00581     prodS *= S[j];
<a name="l00582"></a>00582   
<a name="l00583"></a>00583   <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00584"></a>00584     <span class="keywordflow">for</span> (k=0; k&lt;A; k++)
<a name="l00585"></a>00585       o[k+l*A] = conj(Vh[A-1+k*A])*prodS*conj(U[l+(A-1)*A])*detVhU;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587   X-&gt;<a class="code" href="structSlaterDetAux.html#a19bee32579f8dd37e4834f06f07a231f" title="&amp;lt;Q|Q&amp;#39;&amp;gt;, only defined for non-diagonal">ovlap</a> = 1.0;
<a name="l00588"></a>00588 }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 
<a name="l00591"></a><a class="code" href="SlaterDet_8h.html#a6635ee67b67d4b93287d558fb8d22504">00591</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a6635ee67b67d4b93287d558fb8d22504">calcSlaterDetOBME</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>,
<a name="l00592"></a>00592                        <span class="keyword">const</span> <a class="code" href="structOneBodyOperator.html">OneBodyOperator</a>* op, <span class="keywordtype">double</span> <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[])
<a name="l00593"></a>00593 {
<a name="l00594"></a>00594   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; 
<a name="l00595"></a>00595   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00596"></a>00596   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00597"></a>00597   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00598"></a>00598   complex <span class="keywordtype">double</span>* o=X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>;
<a name="l00599"></a>00599 
<a name="l00600"></a>00600   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>,ki,li;
<a name="l00601"></a>00601   <span class="keywordtype">int</span> i;
<a name="l00602"></a>00602   complex <span class="keywordtype">double</span> *gval = malloc(op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00603"></a>00603 
<a name="l00604"></a>00604   <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++)
<a name="l00605"></a>00605     val[i] = 0.0;
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="keywordflow">for</span> (l=0; l&lt;A; l++) {
<a name="l00608"></a>00608     <span class="keywordflow">for</span> (k=0; k&lt;l; k++) 
<a name="l00609"></a>00609       <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structOneBodyOperator.html#a99c3db87c16a8748935021b35ba6cdd5">opt</a> || Gaux[idx[k]+idx[l]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00610"></a>00610       <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++) 
<a name="l00611"></a>00611         gval[i] = 0.0;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613       <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00614"></a>00614         <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00615"></a>00615           op-&gt;<a class="code" href="structOneBodyOperator.html#a888fa1c19bc6609362e8c560bf442db2">me</a>(op-&gt;<a class="code" href="structOneBodyOperator.html#a24c25f9ac34237bf8191f7b1de382e5f">par</a>, 
<a name="l00616"></a>00616                  &amp;G[idx[k]+ki], &amp;G[idx[l]+li], 
<a name="l00617"></a>00617                  &amp;Gaux[(idx[k]+ki)+(idx[l]+li)*ngauss], 
<a name="l00618"></a>00618                  gval);
<a name="l00619"></a>00619 
<a name="l00620"></a>00620       <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++)
<a name="l00621"></a>00621         val[i] += 2.0*gval[i]*o[l+k*A];
<a name="l00622"></a>00622     }   
<a name="l00623"></a>00623     
<a name="l00624"></a>00624     <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++) 
<a name="l00625"></a>00625       gval[i] = 0.0;
<a name="l00626"></a>00626     <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00627"></a>00627       <span class="keywordflow">for</span> (ki=0; ki&lt;ng[l]; ki++)
<a name="l00628"></a>00628         op-&gt;<a class="code" href="structOneBodyOperator.html#a888fa1c19bc6609362e8c560bf442db2">me</a>(op-&gt;<a class="code" href="structOneBodyOperator.html#a24c25f9ac34237bf8191f7b1de382e5f">par</a>,
<a name="l00629"></a>00629                &amp;G[idx[l]+ki], &amp;G[idx[l]+li], 
<a name="l00630"></a>00630                &amp;Gaux[(idx[l]+ki)+(idx[l]+li)*ngauss], 
<a name="l00631"></a>00631                gval);    
<a name="l00632"></a>00632 
<a name="l00633"></a>00633     <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++)
<a name="l00634"></a>00634       val[i] += creal(gval[i])*creal(o[k+l*A]);
<a name="l00635"></a>00635   }     
<a name="l00636"></a>00636 
<a name="l00637"></a>00637   free(gval);
<a name="l00638"></a>00638 }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 
<a name="l00641"></a><a class="code" href="SlaterDet_8h.html#a975c7ab0a35f0e9888d4d7410d019cf4">00641</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a975c7ab0a35f0e9888d4d7410d019cf4">calcSlaterDetTBME</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>,
<a name="l00642"></a>00642                        <span class="keyword">const</span> <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a>* op, <span class="keywordtype">double</span> <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[])
<a name="l00643"></a>00643 {
<a name="l00644"></a>00644   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; 
<a name="l00645"></a>00645   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00646"></a>00646   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00647"></a>00647   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00648"></a>00648   complex <span class="keywordtype">double</span>* o=X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>;
<a name="l00649"></a>00649 
<a name="l00650"></a>00650   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>,<a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>,<a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, ki,li,mi,ni;
<a name="l00651"></a>00651   <span class="keywordtype">int</span> i;
<a name="l00652"></a>00652   complex <span class="keywordtype">double</span> *gval = malloc(op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00653"></a>00653 
<a name="l00654"></a>00654   <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++)
<a name="l00655"></a>00655     val[i] = 0.0;
<a name="l00656"></a>00656 
<a name="l00657"></a>00657   <span class="keywordflow">for</span> (n=0; n&lt;A; n++)
<a name="l00658"></a>00658     <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00659"></a>00659       <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[l]+idx[n]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00660"></a>00660         <span class="keywordflow">for</span> (m=0; m&lt;A; m++)
<a name="l00661"></a>00661           <span class="keywordflow">for</span> (k=0; k&lt;l; k++)
<a name="l00662"></a>00662             <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[k]+idx[m]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00663"></a>00663 
<a name="l00664"></a>00664               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++) 
<a name="l00665"></a>00665                 gval[i] = 0.0;
<a name="l00666"></a>00666 
<a name="l00667"></a>00667               <span class="keywordflow">for</span> (ni=0; ni&lt;ng[n]; ni++)
<a name="l00668"></a>00668                 <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00669"></a>00669                   <span class="keywordflow">for</span> (mi=0; mi&lt;ng[m]; mi++)
<a name="l00670"></a>00670                     <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00671"></a>00671                       op-&gt;<a class="code" href="structTwoBodyOperator.html#ab0e427b9221cd201e201c1d4939a15b7">me</a>(op-&gt;<a class="code" href="structTwoBodyOperator.html#abe1d35d4264d137a39b4f4055056fa04">par</a>, 
<a name="l00672"></a>00672                              &amp;G[idx[k]+ki], &amp;G[idx[l]+li], 
<a name="l00673"></a>00673                              &amp;G[idx[m]+mi], &amp;G[idx[n]+ni], 
<a name="l00674"></a>00674                              &amp;Gaux[(idx[k]+ki)+(idx[m]+mi)*ngauss],
<a name="l00675"></a>00675                              &amp;Gaux[(idx[l]+li)+(idx[n]+ni)*ngauss],
<a name="l00676"></a>00676                              gval);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++)
<a name="l00679"></a>00679                 val[i] += gval[i]*
<a name="l00680"></a>00680                   (o[m+k*A]*o[n+l*A]-o[n+k*A]*o[m+l*A]);
<a name="l00681"></a>00681             }   
<a name="l00682"></a>00682       }
<a name="l00683"></a>00683   
<a name="l00684"></a>00684   free(gval);
<a name="l00685"></a>00685 }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687 
<a name="l00688"></a><a class="code" href="SlaterDet_8h.html#a3d1e03222b2c3d9b66ccbbe535963b7a">00688</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a3d1e03222b2c3d9b66ccbbe535963b7a">calcSlaterDetTBMErowcol</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>,
<a name="l00689"></a>00689                              <span class="keyword">const</span> <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a>* op, <span class="keywordtype">double</span> <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[], 
<a name="l00690"></a>00690                              <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>)
<a name="l00691"></a>00691 {
<a name="l00692"></a>00692   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; 
<a name="l00693"></a>00693   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00694"></a>00694   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00695"></a>00695   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00696"></a>00696   complex <span class="keywordtype">double</span>* o=X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>,<a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, ki,li,mi,ni;
<a name="l00699"></a>00699   <span class="keywordtype">int</span> i;
<a name="l00700"></a>00700   complex <span class="keywordtype">double</span> *gval = malloc(op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00701"></a>00701 
<a name="l00702"></a>00702   <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++)
<a name="l00703"></a>00703     val[i] = 0.0;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705   <span class="keywordflow">for</span> (n=0; n&lt;A; n++)
<a name="l00706"></a>00706     <span class="comment">// for (l=0; l&lt;A; l++)</span>
<a name="l00707"></a>00707       <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[l]+idx[n]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00708"></a>00708         <span class="keywordflow">for</span> (m=0; m&lt;A; m++)
<a name="l00709"></a>00709           <span class="comment">// for (k=0; k&lt;l; k++)</span>
<a name="l00710"></a>00710             <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[k]+idx[m]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00711"></a>00711 
<a name="l00712"></a>00712               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++) 
<a name="l00713"></a>00713                 gval[i] = 0.0;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715               <span class="keywordflow">for</span> (ni=0; ni&lt;ng[n]; ni++)
<a name="l00716"></a>00716                 <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00717"></a>00717                   <span class="keywordflow">for</span> (mi=0; mi&lt;ng[m]; mi++)
<a name="l00718"></a>00718                     <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00719"></a>00719                       op-&gt;<a class="code" href="structTwoBodyOperator.html#ab0e427b9221cd201e201c1d4939a15b7">me</a>(op-&gt;<a class="code" href="structTwoBodyOperator.html#abe1d35d4264d137a39b4f4055056fa04">par</a>, 
<a name="l00720"></a>00720                              &amp;G[idx[k]+ki], &amp;G[idx[l]+li], 
<a name="l00721"></a>00721                              &amp;G[idx[m]+mi], &amp;G[idx[n]+ni], 
<a name="l00722"></a>00722                              &amp;Gaux[(idx[k]+ki)+(idx[m]+mi)*ngauss],
<a name="l00723"></a>00723                              &amp;Gaux[(idx[l]+li)+(idx[n]+ni)*ngauss],
<a name="l00724"></a>00724                              gval);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++)
<a name="l00727"></a>00727                 val[i] += gval[i]*
<a name="l00728"></a>00728                   (o[m+k*A]*o[n+l*A]-o[n+k*A]*o[m+l*A]);
<a name="l00729"></a>00729             }   
<a name="l00730"></a>00730       } 
<a name="l00731"></a>00731 
<a name="l00732"></a>00732   free(gval);
<a name="l00733"></a>00733 }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735 
<a name="l00736"></a><a class="code" href="SlaterDet_8h.html#a269a329a135cbb79c8defd0ec551eb45">00736</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a269a329a135cbb79c8defd0ec551eb45">calcSlaterDetOBMEod</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>, 
<a name="l00737"></a>00737                          <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>,
<a name="l00738"></a>00738                          <span class="keyword">const</span> <a class="code" href="structOneBodyOperator.html">OneBodyOperator</a>* op, complex <span class="keywordtype">double</span> <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[])
<a name="l00739"></a>00739 {
<a name="l00740"></a>00740   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00741"></a>00741   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* idxp=Qp-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; 
<a name="l00742"></a>00742   <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>; <span class="keywordtype">int</span>* ngp=Qp-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00743"></a>00743   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>; <a class="code" href="structGaussian.html">Gaussian</a>* Gp=Qp-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00744"></a>00744   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00745"></a>00745   complex <span class="keywordtype">double</span>* o=X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>;
<a name="l00746"></a>00746   complex <span class="keywordtype">double</span> ovl = X-&gt;<a class="code" href="structSlaterDetAux.html#a19bee32579f8dd37e4834f06f07a231f" title="&amp;lt;Q|Q&amp;#39;&amp;gt;, only defined for non-diagonal">ovlap</a>;
<a name="l00747"></a>00747 
<a name="l00748"></a>00748   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, ki,li;
<a name="l00749"></a>00749   <span class="keywordtype">int</span> i;
<a name="l00750"></a>00750   complex <span class="keywordtype">double</span> *gval = malloc(op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00751"></a>00751 
<a name="l00752"></a>00752   <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++)
<a name="l00753"></a>00753     val[i] = 0.0;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755   <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00756"></a>00756     <span class="keywordflow">for</span> (k=0; k&lt;A; k++) 
<a name="l00757"></a>00757       <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structOneBodyOperator.html#a99c3db87c16a8748935021b35ba6cdd5">opt</a> || Gaux[idx[k]+idxp[l]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00758"></a>00758 
<a name="l00759"></a>00759         <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++) 
<a name="l00760"></a>00760           gval[i] = 0.0;
<a name="l00761"></a>00761 
<a name="l00762"></a>00762         <span class="keywordflow">for</span> (li=0; li&lt;ngp[l]; li++)
<a name="l00763"></a>00763           <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00764"></a>00764             op-&gt;<a class="code" href="structOneBodyOperator.html#a888fa1c19bc6609362e8c560bf442db2">me</a>(op-&gt;<a class="code" href="structOneBodyOperator.html#a24c25f9ac34237bf8191f7b1de382e5f">par</a>, 
<a name="l00765"></a>00765                    &amp;G[idx[k]+ki], &amp;Gp[idxp[l]+li], 
<a name="l00766"></a>00766                    &amp;Gaux[(idx[k]+ki)+(idxp[l]+li)*ngauss], 
<a name="l00767"></a>00767                    gval);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769         <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++)
<a name="l00770"></a>00770           val[i] += gval[i]*o[l+k*A]*ovl;
<a name="l00771"></a>00771       }         
<a name="l00772"></a>00772   
<a name="l00773"></a>00773   free(gval);
<a name="l00774"></a>00774 }       
<a name="l00775"></a>00775 
<a name="l00776"></a>00776 
<a name="l00777"></a><a class="code" href="SlaterDet_8h.html#a302d3cb2ba683707773a9a01e6c0f594">00777</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a302d3cb2ba683707773a9a01e6c0f594">calcSlaterDetTBMEod</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00778"></a>00778                          <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>,
<a name="l00779"></a>00779                          <span class="keyword">const</span> <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a>* op, complex <span class="keywordtype">double</span> <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[])
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00782"></a>00782   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* idxp=Qp-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; 
<a name="l00783"></a>00783   <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>; <span class="keywordtype">int</span>* ngp=Qp-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00784"></a>00784   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>; <a class="code" href="structGaussian.html">Gaussian</a>* Gp=Qp-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00785"></a>00785   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00786"></a>00786   complex <span class="keywordtype">double</span>* o=X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>;
<a name="l00787"></a>00787   complex <span class="keywordtype">double</span> ovl=X-&gt;<a class="code" href="structSlaterDetAux.html#a19bee32579f8dd37e4834f06f07a231f" title="&amp;lt;Q|Q&amp;#39;&amp;gt;, only defined for non-diagonal">ovlap</a>;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>,<a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>,<a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, ki,li,mi,ni;
<a name="l00790"></a>00790   <span class="keywordtype">int</span> i;
<a name="l00791"></a>00791   complex <span class="keywordtype">double</span> *gval = malloc(op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00792"></a>00792 
<a name="l00793"></a>00793   <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++)
<a name="l00794"></a>00794     val[i] = 0.0;
<a name="l00795"></a>00795 
<a name="l00796"></a>00796   <span class="keywordflow">for</span> (n=0; n&lt;A; n++)
<a name="l00797"></a>00797     <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00798"></a>00798       <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[l]+idxp[n]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00799"></a>00799         <span class="keywordflow">for</span> (m=0; m&lt;A; m++)
<a name="l00800"></a>00800           <span class="keywordflow">for</span> (k=0; k&lt;A; k++)
<a name="l00801"></a>00801             <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[k]+idxp[m]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00802"></a>00802 
<a name="l00803"></a>00803               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++) 
<a name="l00804"></a>00804                 gval[i] = 0.0;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806               <span class="keywordflow">for</span> (ni=0; ni&lt;ngp[n]; ni++)
<a name="l00807"></a>00807                 <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00808"></a>00808                   <span class="keywordflow">for</span> (mi=0; mi&lt;ngp[m]; mi++)
<a name="l00809"></a>00809                     <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00810"></a>00810                       op-&gt;<a class="code" href="structTwoBodyOperator.html#ab0e427b9221cd201e201c1d4939a15b7">me</a>(op-&gt;<a class="code" href="structTwoBodyOperator.html#abe1d35d4264d137a39b4f4055056fa04">par</a>, 
<a name="l00811"></a>00811                              &amp;G[idx[k]+ki], &amp;G[idx[l]+li], 
<a name="l00812"></a>00812                              &amp;Gp[idxp[m]+mi], &amp;Gp[idxp[n]+ni], 
<a name="l00813"></a>00813                              &amp;Gaux[(idx[k]+ki)+(idxp[m]+mi)*ngauss],
<a name="l00814"></a>00814                              &amp;Gaux[(idx[l]+li)+(idxp[n]+ni)*ngauss],
<a name="l00815"></a>00815                              gval);
<a name="l00816"></a>00816 
<a name="l00817"></a>00817               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++)
<a name="l00818"></a>00818                 val[i] += 0.5*gval[i]*
<a name="l00819"></a>00819                   (o[m+k*A]*o[n+l*A]-o[n+k*A]*o[m+l*A])*ovl;
<a name="l00820"></a>00820             }   
<a name="l00821"></a>00821       }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   free(gval);
<a name="l00824"></a>00824 }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 
<a name="l00827"></a><a class="code" href="SlaterDet_8h.html#a1566c80344b499c26afc08afd0015d3b">00827</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a1566c80344b499c26afc08afd0015d3b">calcSlaterDetTBMEodrowcol</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l00828"></a>00828                                <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>,
<a name="l00829"></a>00829                                <span class="keyword">const</span> <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a>* op, complex <span class="keywordtype">double</span> <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[],
<a name="l00830"></a>00830                                <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>)
<a name="l00831"></a>00831 {
<a name="l00832"></a>00832   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>;
<a name="l00833"></a>00833   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* idxp=Qp-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; 
<a name="l00834"></a>00834   <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>; <span class="keywordtype">int</span>* ngp=Qp-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00835"></a>00835   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>; <a class="code" href="structGaussian.html">Gaussian</a>* Gp=Qp-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00836"></a>00836   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00837"></a>00837   complex <span class="keywordtype">double</span>* o=X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>;
<a name="l00838"></a>00838   complex <span class="keywordtype">double</span> ovl=X-&gt;<a class="code" href="structSlaterDetAux.html#a19bee32579f8dd37e4834f06f07a231f" title="&amp;lt;Q|Q&amp;#39;&amp;gt;, only defined for non-diagonal">ovlap</a>;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>,<a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, ki,li,mi,ni;
<a name="l00841"></a>00841   <span class="keywordtype">int</span> i;
<a name="l00842"></a>00842   complex <span class="keywordtype">double</span> *gval = malloc(op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00843"></a>00843 
<a name="l00844"></a>00844   <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++)
<a name="l00845"></a>00845     val[i] = 0.0;
<a name="l00846"></a>00846 
<a name="l00847"></a>00847   <span class="keywordflow">for</span> (n=0; n&lt;A; n++)
<a name="l00848"></a>00848     <span class="comment">// for (l=0; l&lt;A; l++)</span>
<a name="l00849"></a>00849       <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[l]+idxp[n]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00850"></a>00850         <span class="keywordflow">for</span> (m=0; m&lt;A; m++)
<a name="l00851"></a>00851           <span class="comment">// for (k=0; k&lt;A; k++)</span>
<a name="l00852"></a>00852             <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[k]+idxp[m]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00853"></a>00853 
<a name="l00854"></a>00854               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++) 
<a name="l00855"></a>00855                 gval[i] = 0.0;
<a name="l00856"></a>00856 
<a name="l00857"></a>00857               <span class="keywordflow">for</span> (ni=0; ni&lt;ngp[n]; ni++)
<a name="l00858"></a>00858                 <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00859"></a>00859                   <span class="keywordflow">for</span> (mi=0; mi&lt;ngp[m]; mi++)
<a name="l00860"></a>00860                     <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00861"></a>00861                       op-&gt;<a class="code" href="structTwoBodyOperator.html#ab0e427b9221cd201e201c1d4939a15b7">me</a>(op-&gt;<a class="code" href="structTwoBodyOperator.html#abe1d35d4264d137a39b4f4055056fa04">par</a>, 
<a name="l00862"></a>00862                              &amp;G[idx[k]+ki], &amp;G[idx[l]+li], 
<a name="l00863"></a>00863                              &amp;Gp[idxp[m]+mi], &amp;Gp[idxp[n]+ni], 
<a name="l00864"></a>00864                              &amp;Gaux[(idx[k]+ki)+(idxp[m]+mi)*ngauss],
<a name="l00865"></a>00865                              &amp;Gaux[(idx[l]+li)+(idxp[n]+ni)*ngauss],
<a name="l00866"></a>00866                              gval);
<a name="l00867"></a>00867 
<a name="l00868"></a>00868               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++)
<a name="l00869"></a>00869                 val[i] += gval[i]*
<a name="l00870"></a>00870                   (o[m+k*A]*o[n+l*A]-o[n+k*A]*o[m+l*A])*ovl;
<a name="l00871"></a>00871             }   
<a name="l00872"></a>00872       }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874   free(gval);
<a name="l00875"></a>00875 }
<a name="l00876"></a>00876 
<a name="l00877"></a>00877 
<a name="l00878"></a>00878 
<a name="l00879"></a><a class="code" href="SlaterDet_8h.html#a46a76d441c14b6581a2cbc080c100157">00879</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a46a76d441c14b6581a2cbc080c100157" title="calculate Hartree-Fock matrix elements for one-body operator">calcSlaterDetOBHFMEs</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>,
<a name="l00880"></a>00880                           <span class="keyword">const</span> <a class="code" href="structOneBodyOperator.html">OneBodyOperator</a>* op, <span class="keywordtype">void</span>* <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>)
<a name="l00881"></a>00881 {
<a name="l00882"></a>00882   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; 
<a name="l00883"></a>00883   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00884"></a>00884   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00885"></a>00885   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00886"></a>00886   complex double (*mes)[op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>] = val;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>,ki,li;
<a name="l00889"></a>00889   <span class="keywordtype">int</span> i;
<a name="l00890"></a>00890   complex <span class="keywordtype">double</span> gval[op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>];
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00893"></a>00893     <span class="keywordflow">for</span> (k=0; k&lt;A; k++)
<a name="l00894"></a>00894       <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++)
<a name="l00895"></a>00895         mes[k+l*A][i] = 0.0;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897   <span class="keywordflow">for</span> (l=0; l&lt;A; l++) {
<a name="l00898"></a>00898     <span class="keywordflow">for</span> (k=0; k&lt;A; k++) 
<a name="l00899"></a>00899       <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structOneBodyOperator.html#a99c3db87c16a8748935021b35ba6cdd5">opt</a> || Gaux[idx[k]+idx[l]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00900"></a>00900       <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++) 
<a name="l00901"></a>00901         gval[i] = 0.0;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903       <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00904"></a>00904         <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00905"></a>00905           op-&gt;<a class="code" href="structOneBodyOperator.html#a888fa1c19bc6609362e8c560bf442db2">me</a>(op-&gt;<a class="code" href="structOneBodyOperator.html#a24c25f9ac34237bf8191f7b1de382e5f">par</a>, 
<a name="l00906"></a>00906                  &amp;G[idx[k]+ki], &amp;G[idx[l]+li], 
<a name="l00907"></a>00907                  &amp;Gaux[(idx[k]+ki)+(idx[l]+li)*ngauss], 
<a name="l00908"></a>00908                  gval);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910       <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structOneBodyOperator.html#a0d6192ba1c2267be5d9afe3fbe28b20d">dim</a>; i++)
<a name="l00911"></a>00911         mes[k+l*A][i] += gval[i];
<a name="l00912"></a>00912     }   
<a name="l00913"></a>00913   }     
<a name="l00914"></a>00914 }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 
<a name="l00917"></a><a class="code" href="SlaterDet_8h.html#a8f3c1824f12353267efc90cd6643d59a">00917</a> <span class="keywordtype">void</span> <a class="code" href="SlaterDet_8c.html#a8f3c1824f12353267efc90cd6643d59a" title="calculate Hartree-Fock matrix elements for two-body operator">calcSlaterDetTBHFMEs</a>(<span class="keyword">const</span> <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <span class="keyword">const</span> <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a>* <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>,
<a name="l00918"></a>00918                           <span class="keyword">const</span> <a class="code" href="structTwoBodyOperator.html">TwoBodyOperator</a>* op, <span class="keywordtype">void</span>* <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>)
<a name="l00919"></a>00919 {
<a name="l00920"></a>00920   <span class="keywordtype">int</span> A=Q-&gt;<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a>; <span class="keywordtype">int</span> ngauss=Q-&gt;<a class="code" href="structSlaterDet.html#aa49d03f0c2aafc2bc042c834c61fdd9c" title="total number of gaussians">ngauss</a>; 
<a name="l00921"></a>00921   <span class="keywordtype">int</span>* idx=Q-&gt;<a class="code" href="structSlaterDet.html#a1cb8dd92221385316b00c719a227c804" title="index of nucleons">idx</a>; <span class="keywordtype">int</span>* <a class="code" href="donlp2_8h.html#a05dddf13e5d94b9b27a10b39fdd60c2a">ng</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a40059f4be29c6490a20b0f2987d91cae" title="number of gaussians per nucleon">ng</a>;
<a name="l00922"></a>00922   <a class="code" href="structGaussian.html">Gaussian</a>* <a class="code" href="md5_8c.html#ad96b7cf3182ce2ba85e5a7a93b12c441">G</a>=Q-&gt;<a class="code" href="structSlaterDet.html#a4402796d6bc7406894d9f573e7866e6a" title="Gaussians.">G</a>;
<a name="l00923"></a>00923   <a class="code" href="structGaussianAux.html">GaussianAux</a>* Gaux=X-&gt;<a class="code" href="structSlaterDetAux.html#af13f59ec13b3b0565098537c1a216c1b" title="Gaussian Auxiliaries Gaux(ngauss, ngauss).">Gaux</a>;
<a name="l00924"></a>00924   complex <span class="keywordtype">double</span>* o=X-&gt;<a class="code" href="structSlaterDetAux.html#ac3ebc58940366da582c6698aab5fb6b8" title="inverse ovlap matrix o(A,A)">o</a>;
<a name="l00925"></a>00925   complex double (*mes)[op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>] = val;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>,<a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>,<a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a>,<a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, ki,li,mi,ni;
<a name="l00928"></a>00928   <span class="keywordtype">int</span> i;
<a name="l00929"></a>00929   complex <span class="keywordtype">double</span> gval[op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>];
<a name="l00930"></a>00930 
<a name="l00931"></a>00931   <span class="keywordflow">for</span> (m=0; m&lt;A; m++)
<a name="l00932"></a>00932     <span class="keywordflow">for</span> (k=0; k&lt;A; k++)
<a name="l00933"></a>00933       <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++)
<a name="l00934"></a>00934         mes[k+m*A][i] = 0.0;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936   <span class="keywordflow">for</span> (n=0; n&lt;A; n++)
<a name="l00937"></a>00937     <span class="keywordflow">for</span> (l=0; l&lt;A; l++)
<a name="l00938"></a>00938       <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[l]+idx[n]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00939"></a>00939         <span class="keywordflow">for</span> (m=0; m&lt;A; m++)
<a name="l00940"></a>00940           <span class="keywordflow">for</span> (k=0; k&lt;A; k++)
<a name="l00941"></a>00941             <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="structTwoBodyOperator.html#a446a12989a0cfb4fd8032656574efdfd">opt</a> || Gaux[idx[k]+idx[m]*ngauss].<a class="code" href="structGaussianAux.html#a743ce58e106e0f6c4ff7fde72a78b20f">T</a>) {
<a name="l00942"></a>00942 
<a name="l00943"></a>00943               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++) 
<a name="l00944"></a>00944                 gval[i] = 0.0;
<a name="l00945"></a>00945 
<a name="l00946"></a>00946               <span class="keywordflow">for</span> (ni=0; ni&lt;ng[n]; ni++)
<a name="l00947"></a>00947                 <span class="keywordflow">for</span> (li=0; li&lt;ng[l]; li++)
<a name="l00948"></a>00948                   <span class="keywordflow">for</span> (mi=0; mi&lt;ng[m]; mi++)
<a name="l00949"></a>00949                     <span class="keywordflow">for</span> (ki=0; ki&lt;ng[k]; ki++)
<a name="l00950"></a>00950                       op-&gt;<a class="code" href="structTwoBodyOperator.html#ab0e427b9221cd201e201c1d4939a15b7">me</a>(op-&gt;<a class="code" href="structTwoBodyOperator.html#abe1d35d4264d137a39b4f4055056fa04">par</a>, 
<a name="l00951"></a>00951                              &amp;G[idx[k]+ki], &amp;G[idx[l]+li], 
<a name="l00952"></a>00952                              &amp;G[idx[m]+mi], &amp;G[idx[n]+ni], 
<a name="l00953"></a>00953                              &amp;Gaux[(idx[k]+ki)+(idx[m]+mi)*ngauss],
<a name="l00954"></a>00954                              &amp;Gaux[(idx[l]+li)+(idx[n]+ni)*ngauss],
<a name="l00955"></a>00955                              gval);
<a name="l00956"></a>00956 
<a name="l00957"></a>00957               <span class="keywordflow">for</span> (i=0; i&lt;op-&gt;<a class="code" href="structTwoBodyOperator.html#adffa325591daadf6d30d38f7f912c8e3">dim</a>; i++) {
<a name="l00958"></a>00958                 mes[k+m*A][i] += gval[i]*o[n+l*A];
<a name="l00959"></a>00959                 mes[k+n*A][i] -= gval[i]*o[m+l*A];
<a name="l00960"></a>00960               }
<a name="l00961"></a>00961             }   
<a name="l00962"></a>00962       } 
<a name="l00963"></a>00963 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 4 2012 14:05:34 for FMD by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
