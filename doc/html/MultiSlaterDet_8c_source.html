<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FMD: fmd/MultiSlaterDet.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>fmd/MultiSlaterDet.c</h1>  </div>
</div>
<div class="contents">
<a href="MultiSlaterDet_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;zlib.h&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="SlaterDet_8h.html">SlaterDet.h</a>&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="Symmetry_8h.html">Symmetry.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="Observables_8h.html">Observables.h</a>&quot;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="MultiSlaterDet_8h.html">MultiSlaterDet.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="SimpleSlaterDet_8h.html">SimpleSlaterDet.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="SymmetricSlaterDet_8h.html">SymmetricSlaterDet.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="SymmetricMultiSlaterDet_8h.html">SymmetricMultiSlaterDet.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="DiClusterProjSlaterDet_8h.html">DiClusterProjSlaterDet.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="DiClusterMultiProjSlaterDet_8h.html">DiClusterMultiProjSlaterDet.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="DiClusterMulticonfig_8h.html">DiClusterMulticonfig.h</a>&quot;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="utils_8h.html">misc/utils.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="wignerd_8h.html">numerics/wignerd.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="clebsch_8h.html">numerics/clebsch.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="zcw_8h.html">numerics/zcw.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="gaussquad_8h.html">numerics/gaussquad.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="cmat_8h.html">numerics/cmat.h</a>&quot;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 
<a name="l00039"></a><a class="code" href="MultiSlaterDet_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">00039</a> <span class="preprocessor">#define SQR(x) ((x)*(x))</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a><a class="code" href="MultiSlaterDet_8h.html#aeb9c0b0c54f48ada63a9c1b8b7683e2e">00041</a> <span class="keywordtype">void</span> <a class="code" href="MultiSlaterDet_8c.html#aeb9c0b0c54f48ada63a9c1b8b7683e2e">extractIndicesfromString</a>(<span class="keywordtype">char</span>** str, <a class="code" href="structIndices.html">Indices</a>* Ind)
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043   <span class="keywordtype">int</span> i;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   Ind-&gt;<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a> = 0;
<a name="l00046"></a>00046   Ind-&gt;<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a> = 0;
<a name="l00047"></a>00047   <span class="keywordflow">for</span> (i=0; i&lt;NMAX; i++)
<a name="l00048"></a>00048     Ind-&gt;<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[i] = 0;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="keywordtype">char</span> *c, *s = *str;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   i = 0;
<a name="l00053"></a>00053   <span class="keywordflow">while</span>(1) {
<a name="l00054"></a>00054     c = strtok(s, <span class="stringliteral">&quot;: &gt;&quot;</span>);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056     <span class="keywordflow">if</span> (c == NULL) {
<a name="l00057"></a>00057       *str = NULL;
<a name="l00058"></a>00058       <span class="keywordflow">return</span>;
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061     <span class="keywordflow">if</span> (isdigit(*c)) 
<a name="l00062"></a>00062       Ind-&gt;<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[i++] = atoi(c);
<a name="l00063"></a>00063     <span class="keywordflow">else</span> {
<a name="l00064"></a>00064       Ind-&gt;<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a> = i;
<a name="l00065"></a>00065       *str = c;
<a name="l00066"></a>00066       <span class="keywordflow">return</span>;
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068     s = NULL;
<a name="l00069"></a>00069   }
<a name="l00070"></a>00070 }
<a name="l00071"></a>00071  
<a name="l00072"></a>00072 
<a name="l00073"></a><a class="code" href="MultiSlaterDet_8h.html#a91d5b4deab687d45ccd81990914b95e4">00073</a> <span class="keywordtype">char</span>* <a class="code" href="MultiSlaterDet_8c.html#a91d5b4deab687d45ccd81990914b95e4">IndicestoStr</a>(<span class="keyword">const</span> <a class="code" href="structIndices.html">Indices</a>* Ind)
<a name="l00074"></a>00074 {
<a name="l00075"></a>00075   <span class="keywordtype">char</span>* str;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   str = malloc(20*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00078"></a>00078   str[0] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="comment">// all indices means empty string</span>
<a name="l00081"></a>00081   <span class="keywordflow">if</span> (Ind-&gt;<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a> == Ind-&gt;<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>)
<a name="l00082"></a>00082     <span class="keywordflow">return</span> str;
<a name="l00083"></a>00083     
<a name="l00084"></a>00084   <span class="keywordtype">int</span> i;
<a name="l00085"></a>00085   <span class="keywordflow">for</span> (i=0; i&lt;Ind-&gt;<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; i++)
<a name="l00086"></a>00086     sprintf(str, <span class="stringliteral">&quot;%s%d:&quot;</span>, str, i);
<a name="l00087"></a>00087   
<a name="l00088"></a>00088   str[strlen(str)-1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00089"></a>00089   <span class="keywordflow">return</span> str;
<a name="l00090"></a>00090 }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="MultiSlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">00094</a> <span class="preprocessor">#define BUFSIZE 4096</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span>
<a name="l00096"></a><a class="code" href="MultiSlaterDet_8h.html#a74a52c6573866d58f51e7733bef5a678">00096</a> <span class="keywordtype">int</span> <a class="code" href="MultiSlaterDet_8c.html#a1314981c2216f7ca18928d2679178535">readMultiSlaterDetfromFile</a>(<a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* MB, <a class="code" href="structIndices.html">Indices</a>* In, 
<a name="l00097"></a>00097                                <span class="keyword">const</span> <span class="keywordtype">char</span>* fname)
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099   FILE* fp;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="keywordflow">if</span> (!(fp = fopen(fname, <span class="stringliteral">&quot;r&quot;</span>))) {  
<a name="l00102"></a>00102     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for reading\n&quot;</span>, fname);
<a name="l00103"></a>00103     <span class="keywordflow">return</span> -1;
<a name="l00104"></a>00104   }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   fprintf(stderr, <span class="stringliteral">&quot;... reading MultiSlaterDet from file %s\n&quot;</span>, fname);
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="keywordtype">char</span> buf[BUFSIZE];
<a name="l00109"></a>00109 
<a name="l00110"></a>00110   <span class="keywordflow">do</span>
<a name="l00111"></a>00111     fgets(buf, <a class="code" href="MultiSlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l00112"></a>00112   <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;SlaterDet&quot;</span>, 10) &amp;&amp; 
<a name="l00113"></a>00113          strncmp(buf, <span class="stringliteral">&quot;&lt;MultiSlaterDet&quot;</span>, 14) &amp;&amp; !feof(fp));
<a name="l00114"></a>00114   <span class="keywordflow">if</span> (feof(fp)) {
<a name="l00115"></a>00115     fprintf(stderr, <span class="stringliteral">&quot;did&#39;t find &lt;MultiSlaterDet ...&gt;\n&quot;</span>);
<a name="l00116"></a>00116     <span class="keywordflow">return</span> -1;
<a name="l00117"></a>00117   }
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   <span class="comment">// simple SlaterDet</span>
<a name="l00120"></a>00120   <span class="keywordflow">if</span> (!strncmp(buf, <span class="stringliteral">&quot;&lt;SlaterDet&gt;&quot;</span>, 11)) {
<a name="l00121"></a>00121     rewind(fp);
<a name="l00122"></a>00122     <span class="keywordflow">if</span> (<a class="code" href="SimpleSlaterDet_8c.html#ad5dcd8ae4325fdbed69ab9156970e326">SimpleSlaterDetRead</a>(fp, MB))
<a name="l00123"></a>00123       <span class="keywordflow">return</span> -1;
<a name="l00124"></a>00124   }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   <span class="keywordflow">else</span> {
<a name="l00127"></a>00127     <span class="keywordtype">char</span> Mname[80];
<a name="l00128"></a>00128     sscanf(buf, <span class="stringliteral">&quot;&lt;MultiSlaterDet %s&gt;&quot;</span>, Mname);
<a name="l00129"></a>00129     <a class="code" href="utils_8c.html#af86aada130a5db5b0f52154718d67c44" title="strips strip from str">stripstr</a>(Mname, <span class="stringliteral">&quot;&gt;&quot;</span>);
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="keywordflow">if</span> (!strcmp(Mname, <span class="stringliteral">&quot;SymmetricSlaterDet&quot;</span>)) {
<a name="l00132"></a>00132       <span class="keywordflow">if</span> (<a class="code" href="SymmetricSlaterDet_8c.html#a56d2f9ccb07b74815a13db61b1f98532">SymmetricSlaterDetRead</a>(fp, MB))
<a name="l00133"></a>00133         <span class="keywordflow">return</span> -1;
<a name="l00134"></a>00134     }    
<a name="l00135"></a>00135     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(Mname, <span class="stringliteral">&quot;SymmetricMultiSlaterDet&quot;</span>)) {
<a name="l00136"></a>00136       <span class="keywordflow">if</span> (<a class="code" href="SymmetricMultiSlaterDet_8c.html#aa29037d39669201e203eb2e7eaf6886b">SymmetricMultiSlaterDetRead</a>(fp, MB))
<a name="l00137"></a>00137         <span class="keywordflow">return</span> -1;
<a name="l00138"></a>00138     }    
<a name="l00139"></a>00139     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(Mname, <span class="stringliteral">&quot;DiClusterProjSlaterDet&quot;</span>)) {
<a name="l00140"></a>00140       <span class="keywordflow">if</span> (<a class="code" href="DiClusterProjParSlaterDet_8c.html#a621d89e97a7f3c27f8466a6e7c630897">DiClusterProjSlaterDetRead</a>(fp, MB))
<a name="l00141"></a>00141         <span class="keywordflow">return</span> -1;
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(Mname, <span class="stringliteral">&quot;DiClusterMultiProjSlaterDet&quot;</span>)) {
<a name="l00144"></a>00144       <span class="keywordflow">if</span> (<a class="code" href="DiClusterMultiProjSlaterDet_8c.html#a8a6329d9dc25564be51437e29c7e112a">DiClusterMultiProjSlaterDetRead</a>(fp, MB))
<a name="l00145"></a>00145         <span class="keywordflow">return</span> -1;
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(Mname, <span class="stringliteral">&quot;DiClusterMulticonfig&quot;</span>)) {
<a name="l00148"></a>00148       <span class="keywordflow">if</span> (<a class="code" href="DiClusterMulticonfig_8c.html#a1e4d542a496ea39ebd6e714124b014fc">DiClusterMulticonfigRead</a>(fp, MB))
<a name="l00149"></a>00149         <span class="keywordflow">return</span> -1;
<a name="l00150"></a>00150     }
<a name="l00151"></a>00151     <span class="keywordflow">else</span> {
<a name="l00152"></a>00152       fprintf(stderr, <span class="stringliteral">&quot;MultiSlaterDet %s not known !\n&quot;</span>, Mname);
<a name="l00153"></a>00153       <span class="keywordflow">return</span> -1;
<a name="l00154"></a>00154     }
<a name="l00155"></a>00155   }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   In-&gt;<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a> = MB-&gt;<a class="code" href="struct__MSD__.html#ae6519de16dc5677c17380eb22cf3fbfd" title="describe N many-body states">N</a>;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159   <span class="comment">// no indices selected, then take all possible ones</span>
<a name="l00160"></a>00160   <span class="keywordflow">if</span> (In-&gt;<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a> == 0) {
<a name="l00161"></a>00161     In-&gt;<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a> = In-&gt;<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a>;
<a name="l00162"></a>00162     <span class="keywordtype">int</span> i;
<a name="l00163"></a>00163     <span class="keywordflow">for</span> (i=0; i&lt;In-&gt;<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a>; i++)
<a name="l00164"></a>00164       In-&gt;<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[i] = i;
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166   
<a name="l00167"></a>00167   <span class="keywordflow">if</span> (In-&gt;<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a> &gt; In-&gt;<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a>) {
<a name="l00168"></a>00168     fprintf(stderr, <span class="stringliteral">&quot;too many Indices\n&quot;</span>);
<a name="l00169"></a>00169     <span class="keywordflow">return</span> -1;
<a name="l00170"></a>00170   }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <span class="keywordflow">return</span> 0;
<a name="l00173"></a>00173 }
<a name="l00174"></a>00174     
<a name="l00175"></a>00175 
<a name="l00176"></a><a class="code" href="MultiSlaterDet_8h.html#a90a9f616d6587aeb3d8dbd44258110b5">00176</a> <span class="keywordtype">void</span>* <a class="code" href="MultiSlaterDet_8c.html#ad754d262ef74c6a1cbc8c0151f46ef5c">initprojectedMultiMBME</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00177"></a>00177                              <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* MBA, <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* MBB)
<a name="l00178"></a>00178 {
<a name="l00179"></a>00179   <span class="keywordtype">int</span> NA = MBA-&gt;<a class="code" href="struct__MSD__.html#ae6519de16dc5677c17380eb22cf3fbfd" title="describe N many-body states">N</a>;
<a name="l00180"></a>00180   <span class="keywordtype">int</span> NB = MBB-&gt;<a class="code" href="struct__MSD__.html#ae6519de16dc5677c17380eb22cf3fbfd" title="describe N many-body states">N</a>;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <span class="keywordtype">void</span>** me = malloc(NA*NB*<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00183"></a>00183   
<a name="l00184"></a>00184   <span class="keywordtype">int</span> iA, iB;
<a name="l00185"></a>00185   <span class="keywordflow">for</span> (iB=0; iB&lt;NB; iB++)
<a name="l00186"></a>00186     <span class="keywordflow">for</span> (iA=0; iA&lt;NA; iA++)
<a name="l00187"></a>00187       me[iA+iB*NA] = <a class="code" href="Projection_8c.html#acef8d2b9b483edf18c061e6c4fb464d2" title="store projected MEs between two ManyBody states">initprojectedMBME</a>(P, Op);
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="keywordflow">return</span> me;
<a name="l00190"></a>00190 }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 
<a name="l00193"></a><a class="code" href="MultiSlaterDet_8h.html#a4d3438d9bba7d7c79b1b52398f94de62">00193</a> <span class="keywordtype">int</span> <a class="code" href="MultiSlaterDet_8c.html#a0d2233c4b39ce78513a52cbe89d3a233">readprojectedMultiMBMEfromFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* mbfilea, <span class="keyword">const</span> <span class="keywordtype">char</span>* mbfileb,
<a name="l00194"></a>00194                                    <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* MBA,
<a name="l00195"></a>00195                                    <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* MBB,
<a name="l00196"></a>00196                                    <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00197"></a>00197                                    <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00198"></a>00198                                    <span class="keywordtype">void</span>** mbme)
<a name="l00199"></a>00199 {
<a name="l00200"></a>00200   gzFile mefp;
<a name="l00201"></a>00201   <span class="keywordtype">char</span> mefilename[255];
<a name="l00202"></a>00202   <span class="keywordtype">char</span> buf[BUFSIZE];
<a name="l00203"></a>00203   <span class="keywordtype">char</span> fnam[255], md5fnam[33];
<a name="l00204"></a>00204   <span class="keywordtype">char</span> fileS[80];
<a name="l00205"></a>00205 
<a name="l00206"></a>00206   snprintf(mefilename, 255, <span class="stringliteral">&quot;ME/%s--%s--%s--%s.gz&quot;</span>, 
<a name="l00207"></a>00207            Op-&gt;<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a>, 
<a name="l00208"></a>00208            <a class="code" href="utils_8c.html#a72e38b8773b63e202dbebc40c3346988" title="get the file component of fullname">filepart</a>(mbfilea), 
<a name="l00209"></a>00209            <a class="code" href="utils_8c.html#a72e38b8773b63e202dbebc40c3346988" title="get the file component of fullname">filepart</a>(mbfileb), 
<a name="l00210"></a>00210            <a class="code" href="Projection_8c.html#ac87bb7fb183abeb15fc0454df5babd55">ProjectiontoStr</a>(P));
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="keywordflow">if</span> (<a class="code" href="utils_8c.html#a80285197256014b2324f0b874a91cb19" title="check if file exists and is readable (returns 0 for success)">fileexists</a>(mefilename)) {
<a name="l00213"></a>00213       fprintf(stderr, <span class="stringliteral">&quot;... %s does not exist\n&quot;</span>, mefilename);
<a name="l00214"></a>00214       <span class="keywordflow">return</span> -1;
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217   <span class="keywordflow">if</span> (!(mefp = gzopen(mefilename, <span class="stringliteral">&quot;r&quot;</span>))) {
<a name="l00218"></a>00218     fprintf(stderr, <span class="stringliteral">&quot;... couldn&#39;t open %s for reading\n&quot;</span>, mefilename);
<a name="l00219"></a>00219     <span class="keywordflow">return</span> -1;
<a name="l00220"></a>00220   }
<a name="l00221"></a>00221   fprintf(stderr, <span class="stringliteral">&quot;... reading matrix elements from file %s\n&quot;</span>, mefilename);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223   <span class="comment">// do many-body files match ?</span>
<a name="l00224"></a>00224   <span class="comment">// agreement of Symmetries not checked</span>
<a name="l00225"></a>00225   <span class="keywordflow">do</span>
<a name="l00226"></a>00226     gzgets(mefp, buf, <a class="code" href="MultiSlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00227"></a>00227   <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;MBFile &quot;</span>, 7) &amp;&amp; !gzeof(mefp));
<a name="l00228"></a>00228   <span class="keywordflow">if</span> (gzeof(mefp)) {
<a name="l00229"></a>00229     fprintf(stderr, <span class="stringliteral">&quot;...   did&#39;t find &lt;MBFile ...&gt;\n&quot;</span>);
<a name="l00230"></a>00230     gzclose(mefp);
<a name="l00231"></a>00231     <span class="keywordflow">return</span> -2;
<a name="l00232"></a>00232   }
<a name="l00233"></a>00233   sscanf(buf, <span class="stringliteral">&quot;&lt;MBFile %s %s %s&gt;&quot;</span>, fnam, md5fnam, fileS);
<a name="l00234"></a>00234   <span class="keywordflow">if</span> (strncmp(md5fnam, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfilea), 32)) {
<a name="l00235"></a>00235     fprintf(stderr, <span class="stringliteral">&quot;...    MBFile does not match with existing ME\n&quot;</span>);
<a name="l00236"></a>00236     <span class="keywordflow">return</span> -2;
<a name="l00237"></a>00237   }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239   <span class="keywordflow">do</span>
<a name="l00240"></a>00240     gzgets(mefp, buf, <a class="code" href="MultiSlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>);
<a name="l00241"></a>00241   <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;MBFile &quot;</span>, 7) &amp;&amp; !gzeof(mefp));
<a name="l00242"></a>00242   <span class="keywordflow">if</span> (gzeof(mefp)) {
<a name="l00243"></a>00243     fprintf(stderr, <span class="stringliteral">&quot;...    did&#39;t find &lt;MBFile ...&gt;\n&quot;</span>);
<a name="l00244"></a>00244     gzclose(mefp);
<a name="l00245"></a>00245     <span class="keywordflow">return</span> -2;
<a name="l00246"></a>00246   }
<a name="l00247"></a>00247   sscanf(buf, <span class="stringliteral">&quot;&lt;MBFile %s %s %s&gt;&quot;</span>, fnam, md5fnam, fileS);
<a name="l00248"></a>00248   <span class="keywordflow">if</span> (strncmp(md5fnam, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfileb), 32)) {
<a name="l00249"></a>00249     fprintf(stderr, <span class="stringliteral">&quot;...    MBFile does not match with existing ME\n&quot;</span>);
<a name="l00250"></a>00250     gzclose(mefp);
<a name="l00251"></a>00251     <span class="keywordflow">return</span> -2;
<a name="l00252"></a>00252   }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254   <span class="comment">// now read the matrix elements</span>
<a name="l00255"></a>00255   <span class="keywordtype">int</span> NA = MBA-&gt;<a class="code" href="struct__MSD__.html#ae6519de16dc5677c17380eb22cf3fbfd" title="describe N many-body states">N</a>; <span class="keywordtype">int</span> NB = MBB-&gt;<a class="code" href="struct__MSD__.html#ae6519de16dc5677c17380eb22cf3fbfd" title="describe N many-body states">N</a>;
<a name="l00256"></a>00256   <span class="keywordtype">int</span> iA, iB;
<a name="l00257"></a>00257   <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> SA, SB;
<a name="l00258"></a>00258   <span class="keywordtype">int</span> res = 0;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260   <span class="keywordflow">for</span> (iB=0; iB&lt;NB; iB++) {
<a name="l00261"></a>00261     SB = MBB-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBB, iB);
<a name="l00262"></a>00262     <span class="keywordflow">for</span> (iA=0; iA&lt;NA; iA++) {
<a name="l00263"></a>00263       SA = MBA-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBA, iA); 
<a name="l00264"></a>00264       res &amp;= <a class="code" href="Projection_8c.html#a24221ca9708e29fc5ea20304505d5399">readprojectedMBME</a>(mefp, P, Op, SA, SB, mbme[iA+iB*NA]); 
<a name="l00265"></a>00265     }
<a name="l00266"></a>00266   }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268   gzclose(mefp);
<a name="l00269"></a>00269   <span class="keywordflow">return</span> res;
<a name="l00270"></a>00270 }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> dmin(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b)
<a name="l00273"></a>00273 {
<a name="l00274"></a>00274   <span class="keywordflow">return</span> (a &lt; b ? a : b);
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> dmax(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b)
<a name="l00278"></a>00278 {
<a name="l00279"></a>00279   <span class="keywordflow">return</span> (a &gt; b ? a : b);
<a name="l00280"></a>00280 }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 <span class="keyword">static</span> <span class="keywordtype">double</span> dminarray(<span class="keywordtype">double</span> a[], <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)
<a name="l00283"></a>00283 {
<a name="l00284"></a>00284   <span class="keywordtype">double</span> <a class="code" href="HOBasis_8c.html#a742204794ea328ba293fe59cec79b990">m</a> = a[0];
<a name="l00285"></a>00285   <span class="keywordtype">int</span> i;
<a name="l00286"></a>00286   <span class="keywordflow">for</span> (i=1; i&lt;n; i++)
<a name="l00287"></a>00287     m = dmin(m, a[i]);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289   <span class="keywordflow">return</span> m;
<a name="l00290"></a>00290 }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="keyword">static</span> <span class="keywordtype">double</span> dmaxarray(<span class="keywordtype">double</span> a[], <span class="keywordtype">int</span> n)
<a name="l00293"></a>00293 {
<a name="l00294"></a>00294   <span class="keywordtype">double</span> m = a[0];
<a name="l00295"></a>00295   <span class="keywordtype">int</span> i;
<a name="l00296"></a>00296   <span class="keywordflow">for</span> (i=1; i&lt;n; i++)
<a name="l00297"></a>00297     m = dmax(m, a[i]);
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <span class="keywordflow">return</span> m;
<a name="l00300"></a>00300 }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 
<a name="l00303"></a><a class="code" href="MultiSlaterDet_8c.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">00303</a> <span class="preprocessor">#define MAX(a,b) ((a)&gt;(b) ? (a) : (b))</span>
<a name="l00304"></a>00304 <span class="preprocessor"></span>
<a name="l00305"></a>00305 <span class="comment">// 07/13/09 imortant change: do not normalize individual SlaterDets anymore</span>
<a name="l00306"></a>00306 
<a name="l00307"></a><a class="code" href="MultiSlaterDet_8h.html#aa0b1e0fbd816be9bd0e25a7907cd8ae4">00307</a> <span class="keywordtype">void</span> <a class="code" href="MultiSlaterDet_8c.html#a88187629c65a1ca8cd05e81726b0df76">calcprojectedMultiMBME</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>, <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00308"></a>00308                             <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* MBA, 
<a name="l00309"></a>00309                             <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* MBB,
<a name="l00310"></a>00310                             <span class="keywordtype">void</span>** mbme)
<a name="l00311"></a>00311 {
<a name="l00312"></a>00312   <span class="keywordtype">int</span> size=Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l00313"></a>00313   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l00314"></a>00314   <span class="keywordtype">int</span> rank=Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00315"></a>00315   complex double (***<a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>)[(rank+1)*size] = mbme;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   <span class="keywordtype">int</span> jmax = P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00318"></a>00318   <span class="keywordtype">int</span> odd = P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="comment">// loop over the individual SlaterDets in the MultiSlaterDets</span>
<a name="l00321"></a>00321   <span class="keywordtype">int</span> nA = MBA-&gt;<a class="code" href="struct__MSD__.html#a63d226f46025181c738b22cc68f5af0a" title="by n SlaterDets">n</a>; <span class="keywordtype">int</span> nB = MBB-&gt;<a class="code" href="struct__MSD__.html#a63d226f46025181c738b22cc68f5af0a" title="by n SlaterDets">n</a>;
<a name="l00322"></a>00322   <span class="keywordtype">int</span> iA, iB;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   <span class="keywordtype">int</span> NA = MBA-&gt;<a class="code" href="struct__MSD__.html#ae6519de16dc5677c17380eb22cf3fbfd" title="describe N many-body states">N</a>; <span class="keywordtype">int</span> NB = MBB-&gt;<a class="code" href="struct__MSD__.html#ae6519de16dc5677c17380eb22cf3fbfd" title="describe N many-body states">N</a>;
<a name="l00325"></a>00325   <span class="keywordtype">int</span> IA, IB;
<a name="l00326"></a>00326 
<a name="l00327"></a>00327   <a class="code" href="structSlaterDet.html" title="Slater Determinant.">SlaterDet</a> <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a9e0195b1777800e72b4f7af51f0c3945">Qpp</a>;
<a name="l00328"></a>00328   <a class="code" href="SlaterDet_8c.html#a0fe6e8eefc302957926038529e37e7c9" title="allocate memory for SlaterDet">allocateSlaterDet</a>(&amp;Q, MBA-&gt;<a class="code" href="struct__MSD__.html#a999772a06b90565150e39f99d8429589" title="particle number">A</a>);
<a name="l00329"></a>00329   <a class="code" href="SlaterDet_8c.html#a0fe6e8eefc302957926038529e37e7c9" title="allocate memory for SlaterDet">allocateSlaterDet</a>(&amp;Qp, MBB-&gt;<a class="code" href="struct__MSD__.html#a999772a06b90565150e39f99d8429589" title="particle number">A</a>);
<a name="l00330"></a>00330   <a class="code" href="SlaterDet_8c.html#a0fe6e8eefc302957926038529e37e7c9" title="allocate memory for SlaterDet">allocateSlaterDet</a>(&amp;Qpp, MBB-&gt;<a class="code" href="struct__MSD__.html#a999772a06b90565150e39f99d8429589" title="particle number">A</a>);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <a class="code" href="structSlaterDetAux.html">SlaterDetAux</a> <a class="code" href="MinimizerDONLP2_8c.html#a40641ce31f478e07b357ff308ee3e47f">X</a>;
<a name="l00333"></a>00333   <a class="code" href="SlaterDet_8c.html#a6489b81747a0bf6bab1e09d136f45065" title="allocate memory for SlaterDetAux">allocateSlaterDetAux</a>(&amp;X, <a class="code" href="MultiSlaterDet_8c.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(MBA-&gt;<a class="code" href="struct__MSD__.html#a999772a06b90565150e39f99d8429589" title="particle number">A</a>, MBB-&gt;<a class="code" href="struct__MSD__.html#a999772a06b90565150e39f99d8429589" title="particle number">A</a>));
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> S, Sp;
<a name="l00336"></a>00336   <span class="keywordtype">int</span> axialsym;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, r;
<a name="l00339"></a>00339   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, m, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 
<a name="l00342"></a>00342   <span class="comment">// set matrix elements to zero</span>
<a name="l00343"></a>00343   <span class="keywordflow">for</span> (IB=0; IB&lt;NB; IB++)
<a name="l00344"></a>00344     <span class="keywordflow">for</span> (IA=0; IA&lt;NA; IA++)
<a name="l00345"></a>00345       <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00346"></a>00346         <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00347"></a>00347           <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00348"></a>00348             <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2)
<a name="l00349"></a>00349               <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00350"></a>00350                 <span class="keywordflow">for</span> (r=0; r&lt;=rank; r++)
<a name="l00351"></a>00351                   <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[IA+IB*NA][idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)] = 0.0;
<a name="l00352"></a>00352         }                       
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 
<a name="l00355"></a>00355   <span class="comment">// we need a common denominaotor for the NA*NB matrix elements</span>
<a name="l00356"></a>00356   <span class="comment">// all states have axial symmetry ? use axial as indicator</span>
<a name="l00357"></a>00357   <span class="comment">// also spherical will be tretated like axial</span>
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   S=0;
<a name="l00360"></a>00360   axialsym=1;
<a name="l00361"></a>00361   <span class="keywordflow">for</span> (IA=0; IA&lt;NA; IA++)
<a name="l00362"></a>00362     axialsym &amp;= hasAxialSymmetry(MBA-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBA, IA));
<a name="l00363"></a>00363   <span class="keywordflow">if</span> (axialsym)
<a name="l00364"></a>00364     setSymmetry(&amp;S, <a class="code" href="Symmetry_8h.html#ab48899087cc647f0f791ed0c459adc53ab22f0ff9db3be11856d1b582fd09f474">axial</a>);
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   Sp=0;
<a name="l00367"></a>00367   axialsym=1;
<a name="l00368"></a>00368   <span class="keywordflow">for</span> (IB=0; IB&lt;NB; IB++)
<a name="l00369"></a>00369     axialsym &amp;= hasAxialSymmetry(MBB-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBB, IB));
<a name="l00370"></a>00370   <span class="keywordflow">if</span> (axialsym)
<a name="l00371"></a>00371     setSymmetry(&amp;Sp, <a class="code" href="Symmetry_8h.html#ab48899087cc647f0f791ed0c459adc53ab22f0ff9db3be11856d1b582fd09f474">axial</a>);
<a name="l00372"></a>00372 
<a name="l00373"></a>00373   fprintf(stderr, <span class="stringliteral">&quot;Symmetry - MBA: %s, MBB: %s\n&quot;</span>, <a class="code" href="Symmetry_8c.html#a57aa62a08fd12aa6fd7da2355ffb0ea0" title="get String with Symmetry">SymmetrytoStr</a>(S), <a class="code" href="Symmetry_8c.html#a57aa62a08fd12aa6fd7da2355ffb0ea0" title="get String with Symmetry">SymmetrytoStr</a>(Sp)); 
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="keywordtype">double</span> kappaA[nA], kappaB[nB];
<a name="l00376"></a>00376   <span class="keywordtype">double</span> acmA[nA], acmB[nB];
<a name="l00377"></a>00377   
<a name="l00378"></a>00378   <span class="keywordflow">for</span> (iA=0; iA&lt;nA; iA++) {
<a name="l00379"></a>00379     MBA-&gt;<a class="code" href="struct__MSD__.html#a4f583db94740455d1e0853d1b95aa0a9" title="copy i-th SlaterDet into Q">get</a>(MBA, iA, &amp;Q);
<a name="l00380"></a>00380     kappaA[iA] = <a class="code" href="angprojection_8c.html#a96407d07755537e4db8a7047f7a3549d">_estimateangkappa</a>(&amp;Q);
<a name="l00381"></a>00381     acmA[iA] = <a class="code" href="cmprojection_8c.html#a48b0cf8e41bc07938e5a8260c308f742">_estimateacm</a>(&amp;Q);
<a name="l00382"></a>00382   }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   <span class="keywordflow">for</span> (iB=0; iB&lt;nB; iB++) {
<a name="l00385"></a>00385     MBB-&gt;<a class="code" href="struct__MSD__.html#a4f583db94740455d1e0853d1b95aa0a9" title="copy i-th SlaterDet into Q">get</a>(MBB, iB, &amp;Qp);
<a name="l00386"></a>00386     kappaB[iB] = <a class="code" href="angprojection_8c.html#a96407d07755537e4db8a7047f7a3549d">_estimateangkappa</a>(&amp;Qp);
<a name="l00387"></a>00387     acmB[iB] = <a class="code" href="cmprojection_8c.html#a48b0cf8e41bc07938e5a8260c308f742">_estimateacm</a>(&amp;Qp);
<a name="l00388"></a>00388   }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390   fprintf(stderr, <span class="stringliteral">&quot;kappacrit: %6.2f\n&quot;</span>, <a class="code" href="angprojection_8c.html#a58a9090fd80baea2ab54d2032e2531fd">_getangkappacrit</a>());
<a name="l00391"></a>00391   fprintf(stderr, <span class="stringliteral">&quot;kappa - MBA: [%6.2f - %6.2f], MBB: [%6.2f - %6.2f]\n&quot;</span>,
<a name="l00392"></a>00392           dminarray(kappaA, nA), dmaxarray(kappaA, nA),
<a name="l00393"></a>00393           dminarray(kappaB, nB), dmaxarray(kappaB, nB));
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 
<a name="l00396"></a>00396   <span class="keywordtype">int</span> c=0; 
<a name="l00397"></a>00397   <span class="keywordtype">int</span> cmax=nA*nB; 
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <span class="keywordflow">for</span> (iB=0; iB&lt;nB; iB++) {
<a name="l00400"></a>00400     MBB-&gt;<a class="code" href="struct__MSD__.html#a4f583db94740455d1e0853d1b95aa0a9" title="copy i-th SlaterDet into Q">get</a>(MBB, iB, &amp;Qp);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402     <span class="keywordflow">for</span> (iA=0; iA&lt;nA; iA++) {
<a name="l00403"></a>00403       MBA-&gt;<a class="code" href="struct__MSD__.html#a4f583db94740455d1e0853d1b95aa0a9" title="copy i-th SlaterDet into Q">get</a>(MBA, iA, &amp;Q);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405       <span class="comment">// progress indicator</span>
<a name="l00406"></a>00406       c++;
<a name="l00407"></a>00407       <span class="keywordflow">if</span> (c%100==0) fprintf(stderr, <span class="stringliteral">&quot;%d%%&quot;</span>, (100*c)/cmax);
<a name="l00408"></a>00408       <span class="keywordflow">if</span> (c%10==0) fprintf(stderr, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410       <span class="comment">// norms of SlaterDets</span>
<a name="l00411"></a>00411       <span class="comment">// calcSlaterDetAuxod(&amp;Q, &amp;Q, &amp;X);</span>
<a name="l00412"></a>00412       <span class="comment">// double norm = sqrt(creal(X.ovlap));</span>
<a name="l00413"></a>00413 
<a name="l00414"></a>00414       <span class="comment">// calcSlaterDetAuxod(&amp;Qp, &amp;Qp, &amp;X);</span>
<a name="l00415"></a>00415       <span class="comment">// double normp = sqrt(creal(X.ovlap));  </span>
<a name="l00416"></a>00416 
<a name="l00417"></a>00417       <span class="comment">// set up cm integration</span>
<a name="l00418"></a>00418       <a class="code" href="structcmintegrationpara.html">cmintegrationpara</a> <a class="code" href="structcmpara.html">cmpara</a>;
<a name="l00419"></a>00419       <span class="keywordtype">double</span> cmalpha = 0.5/(acmA[iA]+acmB[iB]);
<a name="l00420"></a>00420       <a class="code" href="cmprojection_8c.html#afd49fd9499450859075a07b9c48230d3">_initcmintegration</a>(P, cmalpha, &amp;cmpara);
<a name="l00421"></a>00421       <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2vappcm_8c.html#a8a5e05e8fcc2b05354bff66fc1b1755c">ncm</a> = cmpara.<a class="code" href="structcmintegrationpara.html#ae1229cd214b908780ebc4ae9b66f5e19">n</a>;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423       <span class="comment">// set up ang integration</span>
<a name="l00424"></a>00424       <a class="code" href="structangintegrationpara.html">angintegrationpara</a> <a class="code" href="MinimizerDONLP2multivappcm_8c.html#a49105e626fcbcb1b768fedd076a84bd6">angpara</a>;
<a name="l00425"></a>00425       <span class="keywordtype">double</span> angkappa = dmin(kappaA[iA], kappaB[iB]);
<a name="l00426"></a>00426       <a class="code" href="angprojection_8c.html#a80b9d82dadcaadc0a6026004285b49f4">_initangintegration</a>(P, angkappa, S, Sp, &amp;angpara);
<a name="l00427"></a>00427       <span class="keywordtype">int</span> nang = angpara.<a class="code" href="structangintegrationpara.html#a4b08f3ab8ebe1b43dc13c7e4223d3156">n</a>;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429       <span class="keywordtype">int</span> icm; 
<a name="l00430"></a>00430       <span class="keywordtype">double</span> xcm[3]; <span class="keywordtype">double</span> weightcm;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432       <span class="keywordtype">int</span> iang;
<a name="l00433"></a>00433       <span class="keywordtype">double</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#a20f4c4490bc8ecbdd1ffcb79acce6035" title="finestructure constant">alpha</a>, beta, gamma; <span class="keywordtype">double</span> weightang;
<a name="l00434"></a>00434 
<a name="l00435"></a>00435       complex <span class="keywordtype">double</span> sval[(rank+1)*size];
<a name="l00436"></a>00436       <span class="keywordtype">double</span> weight;
<a name="l00437"></a>00437       <span class="keywordtype">int</span> ip;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439       <span class="keywordflow">for</span> (icm=0; icm&lt;ncm; icm++) {
<a name="l00440"></a>00440         <a class="code" href="cmprojection_8c.html#a4cde89930e46342aae042ab854f2290b">getcmintegrationpoint</a>(icm, &amp;cmpara, xcm, &amp;weightcm);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442         <span class="keywordflow">for</span> (iang=0; iang&lt;nang; iang++) {
<a name="l00443"></a>00443           <a class="code" href="angprojection_8c.html#a84c53149d9af0a652cb6486c9516cbb5">getangintegrationpoint</a>(iang, &amp;angpara, &amp;alpha, &amp;beta, &amp;gamma, &amp;weightang);
<a name="l00444"></a>00444           <span class="comment">// weight = 1.0/(2*norm*normp)*weightcm*weightang;</span>
<a name="l00445"></a>00445           weight = 0.5*weightcm*weightang;
<a name="l00446"></a>00446       
<a name="l00447"></a>00447           <a class="code" href="SlaterDet_8c.html#acd974ea424b0829a55ada79fc69abd90">copySlaterDet</a>(&amp;Qp, &amp;Qpp);
<a name="l00448"></a>00448           <a class="code" href="SlaterDet_8c.html#a5463a8afc7565b2711169b605aad5ca3" title="move Slater determinant by vector d">moveSlaterDet</a>(&amp;Qpp, xcm);
<a name="l00449"></a>00449           <a class="code" href="SlaterDet_8c.html#a8737af9032a8d87843782a88228fef00" title="rotate Slater determinant by euler angles">rotateSlaterDet</a>(&amp;Qpp, alpha, beta, gamma);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451           <span class="keywordflow">for</span> (ip=0; ip&lt;=1; ip++) {
<a name="l00452"></a>00452             <span class="keywordflow">if</span> (ip) <a class="code" href="SlaterDet_8c.html#ad0aa11be18d42c1cc26c2ad1380feb2a" title="invert Slater determinant in origin">invertSlaterDet</a>(&amp;Qpp);
<a name="l00453"></a>00453 
<a name="l00454"></a>00454             <span class="comment">// can only calculate Auxiliaries if Sldets are compatible</span>
<a name="l00455"></a>00455             <span class="keywordflow">if</span> (Q.<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> == Qp.<a class="code" href="structSlaterDet.html#a608c038b00ef605b3871e920459ee4f3" title="number of nucleons">A</a> &amp;&amp; Q.<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> == Qp.<a class="code" href="structSlaterDet.html#a6c7238078110732052290c5feb3fcecb" title="number of protons">Z</a> &amp;&amp; Q.<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a> == Qp.<a class="code" href="structSlaterDet.html#aba9b875a3a8af9a9056dc7d1a48934ac" title="number of neutrons">N</a>)
<a name="l00456"></a>00456               <a class="code" href="SlaterDet_8c.html#ad3679a655d9b6019619456e5b7961638">calcSlaterDetAuxod</a>(&amp;Q, &amp;Qpp, &amp;X);
<a name="l00457"></a>00457             Op-&gt;<a class="code" href="structManyBodyOperator.html#aba2e7e550190ee2ec6e75c23c55fee2d">me</a>(Op-&gt;<a class="code" href="structManyBodyOperator.html#a05268b1b149040fd992263f2e22de7ec">par</a>, &amp;Q, &amp;Qpp, &amp;X, sval);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459             complex <span class="keywordtype">double</span> w, wA, wB;
<a name="l00460"></a>00460             <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> SA, SB;
<a name="l00461"></a>00461             <span class="keywordflow">for</span> (IB=0; IB&lt;NB; IB++) {
<a name="l00462"></a>00462               SB = MBB-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBB, IB);
<a name="l00463"></a>00463               wB = MBB-&gt;<a class="code" href="struct__MSD__.html#af0a4a5e43b17ace83f6a2b6b51437dd0" title="weight of i-th SlaterDet in I-th many-body state">weight</a>(MBB, IB, iB);
<a name="l00464"></a>00464               <span class="keywordflow">for</span> (IA=0; IA&lt;NA; IA++) {
<a name="l00465"></a>00465                 SA = MBA-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBA, IA);
<a name="l00466"></a>00466                 wA = MBA-&gt;<a class="code" href="struct__MSD__.html#af0a4a5e43b17ace83f6a2b6b51437dd0" title="weight of i-th SlaterDet in I-th many-body state">weight</a>(MBA, IA, iA);
<a name="l00467"></a>00467                 <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00468"></a>00468                   <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2)
<a name="l00469"></a>00469                     <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00470"></a>00470                       <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2) {
<a name="l00471"></a>00471                         <span class="keywordflow">if</span> ((Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a> != 0 || <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(SA, p, j, m)) &amp;&amp;
<a name="l00472"></a>00472                             <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(SB, p, j, k)) {
<a name="l00473"></a>00473                           w = conj(wA)*wB*       
<a name="l00474"></a>00474                             weight * (p &amp;&amp; ip%2 ? -1 : 1)*
<a name="l00475"></a>00475                             (j+1)/(8*<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(M_PI))*Djmkstar(j,m,k,alpha,beta,gamma);
<a name="l00476"></a>00476                           <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00477"></a>00477                             <span class="keywordflow">for</span> (r=0; r&lt;=rank; r++)
<a name="l00478"></a>00478                               <a class="code" href="donlp2_8h.html#a4826db9a70669b4ad6637f200d0dd976">val</a>[IA+IB*NA][idxpij(jmax,p,j)][idxjmk(j,m,k)][r+l*(rank+1)] += w*sval[r+l*(rank+1)];
<a name="l00479"></a>00479                     }   
<a name="l00480"></a>00480                   }
<a name="l00481"></a>00481               }
<a name="l00482"></a>00482             }   
<a name="l00483"></a>00483           }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485         }
<a name="l00486"></a>00486 
<a name="l00487"></a>00487       } 
<a name="l00488"></a>00488 
<a name="l00489"></a>00489       <a class="code" href="angprojection_8c.html#a5c0336acd3f2e1e48e88942a353129cd">freeAngintegration</a>(&amp;angpara);
<a name="l00490"></a>00490       <a class="code" href="cmprojection_8c.html#a7ae9754fe9db92205d761777cfa5e336">freecmintegration</a>(&amp;cmpara);
<a name="l00491"></a>00491       
<a name="l00492"></a>00492     }
<a name="l00493"></a>00493   }
<a name="l00494"></a>00494 }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 
<a name="l00497"></a><a class="code" href="MultiSlaterDet_8h.html#a93c3e43f7fe22b20cbe9c9a4c49cd998">00497</a> <span class="keywordtype">int</span> <a class="code" href="MultiSlaterDet_8c.html#a78b753fc4b987333484ccbdf249e0647">writeprojectedMultiMBMEtoFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* mbfilea, <span class="keyword">const</span> <span class="keywordtype">char</span>* mbfileb,
<a name="l00498"></a>00498                                   <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* MBA,
<a name="l00499"></a>00499                                   <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* MBB,
<a name="l00500"></a>00500                                   <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00501"></a>00501                                   <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00502"></a>00502                                   <span class="keywordtype">void</span>** mbme)
<a name="l00503"></a>00503 {
<a name="l00504"></a>00504   gzFile mefp;
<a name="l00505"></a>00505   <span class="keywordtype">char</span> mefilename[255];
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <a class="code" href="utils_8c.html#a91bd1e9936bf548fc21c811e258c81e9" title="check for existence, create if not of directory">ensuredir</a>(<span class="stringliteral">&quot;ME&quot;</span>);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509   snprintf(mefilename, 255, <span class="stringliteral">&quot;ME/%s--%s--%s--%s.gz&quot;</span>, 
<a name="l00510"></a>00510            Op-&gt;<a class="code" href="structManyBodyOperator.html#a4262723cd836949c28d7b922bc7178cd" title="uniquely identify operator including parameters">name</a>, 
<a name="l00511"></a>00511            <a class="code" href="utils_8c.html#a72e38b8773b63e202dbebc40c3346988" title="get the file component of fullname">filepart</a>(mbfilea), 
<a name="l00512"></a>00512            <a class="code" href="utils_8c.html#a72e38b8773b63e202dbebc40c3346988" title="get the file component of fullname">filepart</a>(mbfileb), 
<a name="l00513"></a>00513            <a class="code" href="Projection_8c.html#ac87bb7fb183abeb15fc0454df5babd55">ProjectiontoStr</a>(P));
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   <span class="keywordflow">if</span> (!(mefp = gzopen(mefilename, <span class="stringliteral">&quot;w&quot;</span>))) {
<a name="l00516"></a>00516     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for writing\n&quot;</span>, mefilename);
<a name="l00517"></a>00517     <span class="keywordflow">return</span> -1;
<a name="l00518"></a>00518   }
<a name="l00519"></a>00519     
<a name="l00520"></a>00520   <a class="code" href="utils_8c.html#a109d01ec3cb7ea341ed78e31316661b8" title="print info about running process">gzprintinfo</a>(mefp);
<a name="l00521"></a>00521 
<a name="l00522"></a>00522   <span class="keywordtype">int</span> NA = MBA-&gt;<a class="code" href="struct__MSD__.html#ae6519de16dc5677c17380eb22cf3fbfd" title="describe N many-body states">N</a>; <span class="keywordtype">int</span> NB = MBB-&gt;<a class="code" href="struct__MSD__.html#ae6519de16dc5677c17380eb22cf3fbfd" title="describe N many-body states">N</a>;
<a name="l00523"></a>00523   <span class="keywordtype">int</span> IA, IB;
<a name="l00524"></a>00524   <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> SA, SB;
<a name="l00525"></a>00525   <span class="keywordtype">char</span> syma[80] = <span class="stringliteral">&quot;&quot;</span>, symb[80] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00526"></a>00526   
<a name="l00527"></a>00527   <span class="keywordflow">for</span> (IA=0; IA&lt;NA; IA++) {
<a name="l00528"></a>00528     SA = MBA-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBA, IA);
<a name="l00529"></a>00529     sprintf(syma, <span class="stringliteral">&quot;%s%d:&quot;</span>, syma, SA);
<a name="l00530"></a>00530   }
<a name="l00531"></a>00531   syma[strlen(syma)-1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   <span class="keywordflow">for</span> (IB=0; IB&lt;NB; IB++) {
<a name="l00534"></a>00534     SB = MBB-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBB, IB);
<a name="l00535"></a>00535     sprintf(symb, <span class="stringliteral">&quot;%s%d:&quot;</span>, symb, SB);
<a name="l00536"></a>00536   }
<a name="l00537"></a>00537   symb[strlen(symb)-1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   gzprintf(mefp, <span class="stringliteral">&quot;&lt;MBFile %s %s %s&gt;\n&quot;</span>, 
<a name="l00540"></a>00540            mbfilea, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfilea), syma);
<a name="l00541"></a>00541   gzprintf(mefp, <span class="stringliteral">&quot;&lt;MBFile %s %s %s&gt;\n&quot;</span>, 
<a name="l00542"></a>00542            mbfileb, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfileb), symb);
<a name="l00543"></a>00543 
<a name="l00544"></a>00544   <span class="comment">// write matrix elements</span>
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   <span class="keywordtype">int</span> res = 0;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548   <span class="keywordflow">for</span> (IB=0; IB&lt;NB; IB++) {
<a name="l00549"></a>00549     SB = MBB-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBB, IB);
<a name="l00550"></a>00550     <span class="keywordflow">for</span> (IA=0; IA&lt;NA; IA++) {
<a name="l00551"></a>00551       SA = MBA-&gt;<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(MBA, IA); 
<a name="l00552"></a>00552 
<a name="l00553"></a>00553       gzprintf(mefp, <span class="stringliteral">&quot;\n# Matrixelement :%d  :%d\n&quot;</span>, IA, IB);
<a name="l00554"></a>00554       res &amp;= <a class="code" href="Projection_8c.html#a086dc7277e11cd8a2335f25cb14c66b8">writeprojectedMBME</a>(mefp, P, Op, SA, SB, mbme[IA+IB*NA]); 
<a name="l00555"></a>00555     }
<a name="l00556"></a>00556   }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   gzclose(mefp);
<a name="l00559"></a>00559   <span class="keywordflow">return</span> res;
<a name="l00560"></a>00560 } 
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 
<a name="l00563"></a><a class="code" href="MultiSlaterDet_8h.html#a8d9d4a5da3d20043389d0dad8d149388">00563</a> <span class="keywordtype">void</span> <a class="code" href="MultiSlaterDet_8c.html#a8489b2bdc1cf12d8b0fabfc2b03dd86a">calcMultiEigenstatesMulti</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00564"></a>00564                                <span class="keyword">const</span> <a class="code" href="structInteraction.html">Interaction</a>* <a class="code" href="MinimizerDONLP2_8c.html#ae051dcd567638cf29379a3fec796679c">Int</a>,
<a name="l00565"></a>00565                                <span class="keyword">const</span> <a class="code" href="structObservablesod.html">Observablesod</a> ****obsme,
<a name="l00566"></a>00566                                <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Ep,
<a name="l00567"></a>00567                                <span class="keyword">const</span> <a class="code" href="structIndices.html">Indices</a>* In,
<a name="l00568"></a>00568                                <span class="keywordtype">int</span> n,
<a name="l00569"></a>00569                                <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* multiE, <a class="code" href="structAmplitudes.html">Amplitudes</a>* multiA, 
<a name="l00570"></a>00570                                <span class="keywordtype">double</span> thresh)
<a name="l00571"></a>00571 {
<a name="l00572"></a>00572   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=multiE-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>;
<a name="l00573"></a>00573   <span class="keywordtype">int</span> odd=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00574"></a>00574   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   complex <span class="keywordtype">double</span>* <a class="code" href="md5_8c.html#ae42219072d798876e6b08e6b78614ff6">H</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(dim*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00577"></a>00577   complex <span class="keywordtype">double</span>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#afa106e3c58721409e0e2c7ae6980cf25">N</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(dim*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00578"></a>00578   complex <span class="keywordtype">double</span>* v = malloc(dim*(jmax+1)*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00579"></a>00579   complex <span class="keywordtype">double</span>* <a class="code" href="MinimizerDONLP2multivapp_8c.html#ada7b84dafb505b22eca2753ef852e94a">V</a> = malloc(<a class="code" href="calcbasisovlapmulti_8c.html#aa7866fa5e4e0ee9b034e9dab6599a9cc">SQR</a>(dim*(jmax+1))*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00580"></a>00580   
<a name="l00581"></a>00581   <span class="keywordtype">int</span> a, aa, b, bb;
<a name="l00582"></a>00582   <span class="keywordtype">int</span> p, <a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>, ipj, i, m, <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>;
<a name="l00583"></a>00583   <span class="keywordtype">int</span> smalldim, fulldim, d;
<a name="l00584"></a>00584   <span class="keywordtype">int</span> ai, bi, iai, ibi, idxa, idxb, idxai, idxbi;
<a name="l00585"></a>00585   <span class="keywordtype">double</span> norma2, normb2, normi2;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00588"></a>00588     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00589"></a>00589       fulldim = dim*(j+1);
<a name="l00590"></a>00590 
<a name="l00591"></a>00591       ipj=idxpij(jmax,p,j);
<a name="l00592"></a>00592 
<a name="l00593"></a>00593       <span class="comment">// how many good basis states do we really have ?</span>
<a name="l00594"></a>00594       smalldim=0;
<a name="l00595"></a>00595       idxa=-1;
<a name="l00596"></a>00596       <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l00597"></a>00597         <span class="keywordflow">for</span> (aa=0; aa&lt;In[a].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aa++) {
<a name="l00598"></a>00598           idxa++;
<a name="l00599"></a>00599           smalldim += Ep[idxa].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj];
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602       <span class="comment">// do we have at least a one-dimensional space</span>
<a name="l00603"></a>00603       <span class="keywordflow">if</span> (smalldim == 0) {
<a name="l00604"></a>00604         multiE-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[ipj] = 0;
<a name="l00605"></a>00605       } <span class="keywordflow">else</span> {
<a name="l00606"></a>00606 
<a name="l00607"></a>00607         idxb=-1; idxbi=-1;
<a name="l00608"></a>00608         <span class="keywordflow">for</span> (b=0; b&lt;n; b++)
<a name="l00609"></a>00609           <span class="keywordflow">for</span> (bb=0; bb&lt;In[b].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; bb++) {
<a name="l00610"></a>00610             idxb++;
<a name="l00611"></a>00611             <span class="keywordflow">for</span> (bi=0; bi&lt;Ep[idxb].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj]; bi++) {
<a name="l00612"></a>00612               ibi=Ep[idxb].<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][bi];
<a name="l00613"></a>00613               normb2=Ep[idxb].<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][ibi];
<a name="l00614"></a>00614               idxbi++;
<a name="l00615"></a>00615               idxa=-1; idxai=-1;
<a name="l00616"></a>00616               <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l00617"></a>00617                 <span class="keywordflow">for</span> (aa=0; aa&lt;In[a].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aa++) {
<a name="l00618"></a>00618                   idxa++;
<a name="l00619"></a>00619                   <span class="keywordflow">for</span> (ai=0; ai&lt;Ep[idxa].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj]; ai++) {
<a name="l00620"></a>00620                     iai=Ep[idxa].<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][ai];
<a name="l00621"></a>00621                     norma2=Ep[idxa].<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][iai];
<a name="l00622"></a>00622                     idxai++;
<a name="l00623"></a>00623                     N[idxai+idxbi*smalldim] = 0.0;
<a name="l00624"></a>00624                     H[idxai+idxbi*smalldim] = 0.0;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626                     <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00627"></a>00627                       <span class="keywordflow">for</span> (m=-j; m&lt;=j; m=m+2) {
<a name="l00628"></a>00628                         N[idxai+idxbi*smalldim] +=
<a name="l00629"></a>00629                           conj(Ep[idxa].V[ipj][idxjm(j,m)+iai*(j+1)])*
<a name="l00630"></a>00630                           obsme[a+b*n][In[a].<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[aa]+In[b].<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[bb]*In[a].<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a>][ipj][idxjmk(j,m,k)].<a class="code" href="structObservablesod.html#a8c9da6cf3aa140f99b6b3f58a8f20182">n</a>*
<a name="l00631"></a>00631                           Ep[idxb].<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][idxjm(j,k)+ibi*(j+1)]/
<a name="l00632"></a>00632                           sqrt(norma2*normb2);
<a name="l00633"></a>00633                          
<a name="l00634"></a>00634                         H[idxai+idxbi*smalldim] +=
<a name="l00635"></a>00635                           conj(Ep[idxa].V[ipj][idxjm(j,m)+iai*(j+1)])*
<a name="l00636"></a>00636                           obsme[a+b*n][In[a].<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[aa]+In[b].<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[bb]*In[a].<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a>][ipj][idxjmk(j,m,k)].<a class="code" href="structObservablesod.html#a8c2c7596d9d5853b8f1701fe351dc300">h</a>*
<a name="l00637"></a>00637                           Ep[idxb].<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][idxjm(j,k)+ibi*(j+1)]/
<a name="l00638"></a>00638                           sqrt(norma2*normb2);  
<a name="l00639"></a>00639 
<a name="l00640"></a>00640                       }
<a name="l00641"></a>00641                   }
<a name="l00642"></a>00642                 }
<a name="l00643"></a>00643             }   
<a name="l00644"></a>00644           }                   
<a name="l00645"></a>00645 
<a name="l00646"></a>00646         <a class="code" href="cmat_8c.html#aab30acd19149c3014405da4f585d4bb5">generalizedeigensystem</a>(H, N, smalldim, thresh, 
<a name="l00647"></a>00647                                v, V, 
<a name="l00648"></a>00648                                &amp;d);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         <span class="comment">// embed solution into full space</span>
<a name="l00651"></a>00651 
<a name="l00652"></a>00652         <span class="comment">// real dimension of eigenspace, may be smaller than smalldim</span>
<a name="l00653"></a>00653         multiE-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[ipj] = d;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         <span class="keywordflow">for</span> (i=0; i&lt;d; i++) {
<a name="l00656"></a>00656           multiE-&gt;<a class="code" href="structEigenstates.html#ade09c5713d0d08f69ed61126f1c8d075" title="energy eigenvalues">v</a>[ipj][i] = v[i];
<a name="l00657"></a>00657 
<a name="l00658"></a>00658           idxa=-1;
<a name="l00659"></a>00659           <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l00660"></a>00660             <span class="keywordflow">for</span> (aa=0; aa&lt;In[a].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aa++) {
<a name="l00661"></a>00661               idxa++;
<a name="l00662"></a>00662               <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2)
<a name="l00663"></a>00663                 multiE-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][idxjm(j,k)+idxa*(j+1)+i*fulldim] = 0.0;
<a name="l00664"></a>00664             }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666           idxa=-1; idxai=-1;
<a name="l00667"></a>00667           <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l00668"></a>00668             <span class="keywordflow">for</span> (aa=0; aa&lt;In[a].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aa++) {
<a name="l00669"></a>00669               idxa++;
<a name="l00670"></a>00670               <span class="keywordflow">for</span> (ai=0; ai&lt;Ep[idxa].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj]; ai++) {
<a name="l00671"></a>00671                 idxai++;
<a name="l00672"></a>00672                 iai = Ep[idxa].<a class="code" href="structEigenstates.html#a0a44e079b2e594d09a15d3a1ddd4a35c" title="indexing eigenstates according to &amp;quot;goodness&amp;quot;">index</a>[ipj][ai];
<a name="l00673"></a>00673                 norma2 = Ep[idxa].<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][iai];
<a name="l00674"></a>00674 
<a name="l00675"></a>00675                 <span class="keywordflow">for</span> (k=-j; k&lt;=j; k=k+2) {
<a name="l00676"></a>00676 
<a name="l00677"></a>00677                   multiE-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[ipj][idxjm(j,k)+idxa*(j+1)+i*fulldim] += 
<a name="l00678"></a>00678                     Ep[idxa].V[ipj][idxjm(j,k)+iai*(j+1)]/sqrt(norma2)*
<a name="l00679"></a>00679                     V[idxai+i*smalldim];
<a name="l00680"></a>00680                 }
<a name="l00681"></a>00681               }                               
<a name="l00682"></a>00682             }
<a name="l00683"></a>00683         }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="comment">// calculate Amplitudes</span>
<a name="l00686"></a>00686 
<a name="l00687"></a>00687         <span class="keywordflow">for</span> (i=0; i&lt;d; i++) {
<a name="l00688"></a>00688 
<a name="l00689"></a>00689           normi2 = 0.0;
<a name="l00690"></a>00690           <span class="keywordflow">for</span> (idxbi=0; idxbi&lt;smalldim; idxbi++)
<a name="l00691"></a>00691             <span class="keywordflow">for</span> (idxai=0; idxai&lt;smalldim; idxai++)
<a name="l00692"></a>00692               normi2 += conj(V[idxai+i*smalldim])*
<a name="l00693"></a>00693                 N[idxai+idxbi*smalldim]*V[idxbi+i*smalldim];
<a name="l00694"></a>00694 
<a name="l00695"></a>00695           multiE-&gt;<a class="code" href="structEigenstates.html#aafb83e8289ec1cb2c7e882311c35ea3a" title="many-body norm^2 of eigenstates">norm</a>[ipj][i] = normi2;
<a name="l00696"></a>00696 
<a name="l00697"></a>00697           idxa=-1; idxai=-1;
<a name="l00698"></a>00698           <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l00699"></a>00699             <span class="keywordflow">for</span> (aa=0; aa&lt;In[a].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aa++) {
<a name="l00700"></a>00700               idxa++;
<a name="l00701"></a>00701 
<a name="l00702"></a>00702               multiA-&gt;<a class="code" href="structAmplitudes.html#a3192b8e5338e5ac43d813833b09ad221">ngood</a>[ipj][idxa] = Ep[idxa].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj];
<a name="l00703"></a>00703           
<a name="l00704"></a>00704               <span class="keywordflow">for</span> (ai=0; ai&lt;Ep[idxa].<a class="code" href="structEigenstates.html#a44b4a004824004e5635d83048d875e21" title="number of eigenstates considered as &amp;quot;good&amp;quot;">ngood</a>[ipj]; ai++) {
<a name="l00705"></a>00705                 idxai++;
<a name="l00706"></a>00706                 norma2 = N[idxai+idxai*smalldim];
<a name="l00707"></a>00707                 multiA-&gt;<a class="code" href="structAmplitudes.html#a1608d319a33b0263e17f0ac70993cce2">amp</a>[ipj][ai+idxa*(j+1)+i*fulldim] = 0.0;
<a name="l00708"></a>00708                 <span class="keywordflow">for</span> (idxbi=0; idxbi&lt;smalldim; idxbi++)
<a name="l00709"></a>00709                   multiA-&gt;<a class="code" href="structAmplitudes.html#a1608d319a33b0263e17f0ac70993cce2">amp</a>[ipj][ai+idxa*(j+1)+i*fulldim] +=
<a name="l00710"></a>00710                     N[idxai+idxbi*smalldim]*V[idxbi+i*smalldim]/
<a name="l00711"></a>00711                     sqrt(norma2*normi2);
<a name="l00712"></a>00712               }
<a name="l00713"></a>00713             }
<a name="l00714"></a>00714         }
<a name="l00715"></a>00715         
<a name="l00716"></a>00716       }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718    }
<a name="l00719"></a>00719 
<a name="l00720"></a>00720   free(H); free(N);
<a name="l00721"></a>00721   free(v); free(V);
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 <span class="comment">// calculates reduced matrix element divided by sqrt(2j+1)</span>
<a name="l00726"></a>00726 
<a name="l00727"></a><a class="code" href="MultiSlaterDet_8h.html#ae3b59c98a5fc7bfa57943a16433bf36d">00727</a> <span class="keywordtype">void</span> <a class="code" href="MultiSlaterDet_8c.html#ae3b59c98a5fc7bfa57943a16433bf36d">calcexpectprojectedMultiMBME</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00728"></a>00728                                   <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00729"></a>00729                                   <span class="keyword">const</span> <span class="keywordtype">void</span>* mbme,
<a name="l00730"></a>00730                                   <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* <a class="code" href="MinimizerDONLP2_8c.html#ac4f7151b4c1c951d242ff9f8856381a0">Q</a>,
<a name="l00731"></a>00731                                   <span class="keyword">const</span> <a class="code" href="structIndices.html">Indices</a>* In,
<a name="l00732"></a>00732                                   <span class="keywordtype">int</span> n,
<a name="l00733"></a>00733                                   <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E,
<a name="l00734"></a>00734                                   <span class="keywordtype">void</span>* expectmbme)
<a name="l00735"></a>00735 {
<a name="l00736"></a>00736   <span class="keywordtype">int</span> p,<a class="code" href="MinimizerDONLP2multivapp_8c.html#a37d972ae0b47b9099e30983131d31916">j</a>,i;
<a name="l00737"></a>00737   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, k1, k2;
<a name="l00738"></a>00738   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, r, nu;
<a name="l00739"></a>00739   <span class="keywordtype">int</span> idx;
<a name="l00740"></a>00740   <span class="keywordtype">int</span> rank=Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00741"></a>00741   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l00742"></a>00742   <span class="keywordtype">int</span> size=Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l00743"></a>00743   <span class="keywordtype">int</span> odd=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00744"></a>00744   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00745"></a>00745   complex double (****me)[(rank+1)*size] = mbme;
<a name="l00746"></a>00746   complex double (**expme)[size] = expectmbme;
<a name="l00747"></a>00747  
<a name="l00748"></a>00748   <span class="keywordtype">int</span> dimj;
<a name="l00749"></a>00749   <span class="keywordtype">int</span> a, b, aa, bb;
<a name="l00750"></a>00750   <span class="keywordtype">int</span> idxa, idxb;
<a name="l00751"></a>00751   <span class="keywordtype">int</span> Idxaa, Idxbb;
<a name="l00752"></a>00752   <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sa, Sb;
<a name="l00753"></a>00753 
<a name="l00754"></a>00754   <span class="keywordflow">for</span> (p=0; p&lt;=1; p++)
<a name="l00755"></a>00755     <span class="keywordflow">for</span> (j=odd; j&lt;jmax; j=j+2) {
<a name="l00756"></a>00756 
<a name="l00757"></a>00757       idx = idxpij(jmax,p,j);
<a name="l00758"></a>00758       dimj=E-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>*(j+1);
<a name="l00759"></a>00759       <span class="keywordflow">for</span> (i=0; i&lt;E-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idx]; i++) {
<a name="l00760"></a>00760 
<a name="l00761"></a>00761         <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00762"></a>00762           expme[idx][i][l] = 0.0;
<a name="l00763"></a>00763         
<a name="l00764"></a>00764         idxb=-1;
<a name="l00765"></a>00765         <span class="keywordflow">for</span> (b=0; b&lt;n; b++)
<a name="l00766"></a>00766           <span class="keywordflow">for</span> (bb=0; bb&lt;In[b].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; bb++) {
<a name="l00767"></a>00767             idxb++;
<a name="l00768"></a>00768             Idxbb = In[b].<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[bb];
<a name="l00769"></a>00769             Sb = Q[b].<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(&amp;Q[b], Idxbb);
<a name="l00770"></a>00770             <span class="keywordflow">for</span> (k2=-j; k2&lt;=j; k2=k2+2) {
<a name="l00771"></a>00771               idxa=-1;
<a name="l00772"></a>00772               <span class="keywordflow">for</span> (a=0; a&lt;n; a++)
<a name="l00773"></a>00773                 <span class="keywordflow">for</span> (aa=0; aa&lt;In[a].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aa++) {
<a name="l00774"></a>00774                   idxa++;
<a name="l00775"></a>00775                   Idxaa = In[a].<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[aa];
<a name="l00776"></a>00776                   Sa = Q[a].<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(&amp;Q[a], Idxaa);
<a name="l00777"></a>00777                   <span class="keywordflow">for</span> (k1=-j; k1&lt;=j; k1=k1+2)       
<a name="l00778"></a>00778                     <span class="keywordflow">for</span> (k=max(-j,k1-rank); k&lt;=min(j,k1+rank); k=k+2) {
<a name="l00779"></a>00779                       nu=k1-k;
<a name="l00780"></a>00780                       <span class="keywordflow">if</span> (<a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sa, p, j, k1) &amp;&amp;
<a name="l00781"></a>00781                           <a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sb, p, j, k2)) {
<a name="l00782"></a>00782                         <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00783"></a>00783                           expme[idx][i][l] +=
<a name="l00784"></a>00784                             <a class="code" href="clebsch_8c.html#a7b75250723cf843449ee508426c81537">clebsch</a>(j, rank, j, k, nu, k1)*
<a name="l00785"></a>00785                             me[a+b*n][Idxaa+Idxbb*In[a].<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a>][idx][idxjmk(j,k,k2)][(nu+rank)/2+l*(rank+1)]*
<a name="l00786"></a>00786                             conj(E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idx][idxjm(j,k1) + idxa*(j+1) + i*dimj])*
<a name="l00787"></a>00787                             E-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idx][idxjm(j,k2)+ idxb*(j+1) + i*dimj];
<a name="l00788"></a>00788                       }
<a name="l00789"></a>00789                     }
<a name="l00790"></a>00790                 }               
<a name="l00791"></a>00791             }
<a name="l00792"></a>00792           }
<a name="l00793"></a>00793       }
<a name="l00794"></a>00794     }                   
<a name="l00795"></a>00795 }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 <span class="comment">// calculate transition matrix elements for Eigenstates Efin &lt;- Eini</span>
<a name="l00799"></a>00799 
<a name="l00800"></a>00800 <span class="comment">// calculates reduced matrix element divided by sqrt(2jfin+1)</span>
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 <span class="comment">// slow but transparent</span>
<a name="l00803"></a>00803 <span class="comment">/*</span>
<a name="l00804"></a>00804 <span class="comment">void calctransitionprojectedMultiMBME(const Projection* P,</span>
<a name="l00805"></a>00805 <span class="comment">                                      const ManyBodyOperator* Op,</span>
<a name="l00806"></a>00806 <span class="comment">                                      const void* mbme,</span>
<a name="l00807"></a>00807 <span class="comment">                                      const MultiSlaterDet* Qfin,</span>
<a name="l00808"></a>00808 <span class="comment">                                      const MultiSlaterDet* Qini,</span>
<a name="l00809"></a>00809 <span class="comment">                                      const Indices* Infin,</span>
<a name="l00810"></a>00810 <span class="comment">                                      const Indices* Inini,</span>
<a name="l00811"></a>00811 <span class="comment">                                      int nfin, int nini,</span>
<a name="l00812"></a>00812 <span class="comment">                                      const Eigenstates* Efin,</span>
<a name="l00813"></a>00813 <span class="comment">                                      const Eigenstates* Eini,</span>
<a name="l00814"></a>00814 <span class="comment">                                      void* transmbme)</span>
<a name="l00815"></a>00815 <span class="comment">{</span>
<a name="l00816"></a>00816 <span class="comment">  int pini,jini,iini, pfin,jfin,ifin;</span>
<a name="l00817"></a>00817 <span class="comment">  int k, kfin, kini;</span>
<a name="l00818"></a>00818 <span class="comment">  int l, nu;</span>
<a name="l00819"></a>00819 <span class="comment">  int p=Op-&gt;pi;</span>
<a name="l00820"></a>00820 <span class="comment">  int size=Op-&gt;size;</span>
<a name="l00821"></a>00821 <span class="comment">  int dim=Op-&gt;dim;</span>
<a name="l00822"></a>00822 <span class="comment">  int rank=Op-&gt;rank;</span>
<a name="l00823"></a>00823 <span class="comment">  int oddini=P-&gt;odd;</span>
<a name="l00824"></a>00824 <span class="comment">  int jmax=P-&gt;jmax;</span>
<a name="l00825"></a>00825 <span class="comment">  complex double (****me)[(rank+1)*size] = mbme;</span>
<a name="l00826"></a>00826 <span class="comment">  complex double (****transme)[size] = transmbme;</span>
<a name="l00827"></a>00827 <span class="comment"></span>
<a name="l00828"></a>00828 <span class="comment">  int afin, aini;</span>
<a name="l00829"></a>00829 <span class="comment">  int aafin, aaini;</span>
<a name="l00830"></a>00830 <span class="comment">  int dimini, dimfin;</span>
<a name="l00831"></a>00831 <span class="comment">  int idxini, idxfin;</span>
<a name="l00832"></a>00832 <span class="comment">  int idxaini, idxafin;</span>
<a name="l00833"></a>00833 <span class="comment">  int Idxaaini, Idxaafin;</span>
<a name="l00834"></a>00834 <span class="comment">  Symmetry Sini, Sfin;</span>
<a name="l00835"></a>00835 <span class="comment"></span>
<a name="l00836"></a>00836 <span class="comment">  for (pini=0; pini&lt;=1; pini++)</span>
<a name="l00837"></a>00837 <span class="comment">    for (jini=oddini; jini&lt;jmax; jini=jini+2) {</span>
<a name="l00838"></a>00838 <span class="comment">      </span>
<a name="l00839"></a>00839 <span class="comment">      idxini = idxpij(jmax,pini,jini);</span>
<a name="l00840"></a>00840 <span class="comment">      dimini=Eini-&gt;n*(jini+1);</span>
<a name="l00841"></a>00841 <span class="comment"></span>
<a name="l00842"></a>00842 <span class="comment">      pfin=(pini+p)%2;</span>
<a name="l00843"></a>00843 <span class="comment">      for (jfin=abs(jini-rank); jfin&lt;=min(jmax-1,jini+rank); jfin=jfin+2) {</span>
<a name="l00844"></a>00844 <span class="comment"></span>
<a name="l00845"></a>00845 <span class="comment">        idxfin = idxpij(jmax,pfin,jfin);</span>
<a name="l00846"></a>00846 <span class="comment">        dimfin=Efin-&gt;n*(jfin+1);</span>
<a name="l00847"></a>00847 <span class="comment">        for (iini=0; iini&lt;Eini-&gt;dim[idxini]; iini++)</span>
<a name="l00848"></a>00848 <span class="comment">          for (ifin=0; ifin&lt;Efin-&gt;dim[idxfin]; ifin++) {</span>
<a name="l00849"></a>00849 <span class="comment"></span>
<a name="l00850"></a>00850 <span class="comment">            for (l=0; l&lt;dim; l++)</span>
<a name="l00851"></a>00851 <span class="comment">              transme[idxfin][idxini][ifin][iini][l] = 0.0;</span>
<a name="l00852"></a>00852 <span class="comment"></span>
<a name="l00853"></a>00853 <span class="comment">            idxaini=-1;</span>
<a name="l00854"></a>00854 <span class="comment">            for (aini=0; aini&lt;nini; aini++)</span>
<a name="l00855"></a>00855 <span class="comment">              for (aaini=0; aaini&lt;Inini[aini].n; aaini++) {</span>
<a name="l00856"></a>00856 <span class="comment">                idxaini++;</span>
<a name="l00857"></a>00857 <span class="comment">                Idxaaini = Inini[aini].idx[aaini];</span>
<a name="l00858"></a>00858 <span class="comment">                Sini = Qini[aini].symmetry(&amp;Qini[aini], Idxaaini);</span>
<a name="l00859"></a>00859 <span class="comment"></span>
<a name="l00860"></a>00860 <span class="comment">                for (kini=-jini; kini&lt;=jini; kini=kini+2) {</span>
<a name="l00861"></a>00861 <span class="comment">                  </span>
<a name="l00862"></a>00862 <span class="comment">                  idxafin=-1;</span>
<a name="l00863"></a>00863 <span class="comment">                  for (afin=0; afin&lt;nfin; afin++)</span>
<a name="l00864"></a>00864 <span class="comment">                    for (aafin=0; aafin&lt;Infin[afin].n; aafin++) {</span>
<a name="l00865"></a>00865 <span class="comment">                      idxafin++;</span>
<a name="l00866"></a>00866 <span class="comment">                      Idxaafin = Infin[afin].idx[aafin];</span>
<a name="l00867"></a>00867 <span class="comment">                      Sfin = Qfin[afin].symmetry(&amp;Qfin[afin], Idxaafin);</span>
<a name="l00868"></a>00868 <span class="comment">                      </span>
<a name="l00869"></a>00869 <span class="comment">                      for (kfin=-jfin; kfin&lt;=jfin; kfin=kfin+2)</span>
<a name="l00870"></a>00870 <span class="comment">                        for (k=max(-jini,kfin-rank); k&lt;=min(jini,kfin+rank); k=k+2) {</span>
<a name="l00871"></a>00871 <span class="comment">                          nu = kfin-k;</span>
<a name="l00872"></a>00872 <span class="comment">                          if (SymmetryAllowed(Sfin, pfin, jfin, kfin) &amp;&amp;</span>
<a name="l00873"></a>00873 <span class="comment">                              SymmetryAllowed(Sini, pini, jini, kini)) {</span>
<a name="l00874"></a>00874 <span class="comment">                            for (l=0; l&lt;dim; l++)</span>
<a name="l00875"></a>00875 <span class="comment">                              transme[idxfin][idxini][ifin][iini][l] +=</span>
<a name="l00876"></a>00876 <span class="comment">                                clebsch(jini, rank, jfin, k, nu, kfin)*</span>
<a name="l00877"></a>00877 <span class="comment">                                me[afin+aini*nfin][Idxaafin+Idxaaini*Infin[afin].N][idxini][idxjmk(jini,k,kini)][(nu+rank)/2+l*(rank+1)]*</span>
<a name="l00878"></a>00878 <span class="comment">                                conj(Efin-&gt;V[idxfin][idxjm(jfin,kfin)+idxafin*(jfin+1)+ifin*dimfin])*</span>
<a name="l00879"></a>00879 <span class="comment">                                Eini-&gt;V[idxini][idxjm(jini,kini)+idxaini*(jini+1)+iini*dimini];</span>
<a name="l00880"></a>00880 <span class="comment">                          }</span>
<a name="l00881"></a>00881 <span class="comment">                        }</span>
<a name="l00882"></a>00882 <span class="comment">                    }</span>
<a name="l00883"></a>00883 <span class="comment">                }                       </span>
<a name="l00884"></a>00884 <span class="comment">              }</span>
<a name="l00885"></a>00885 <span class="comment">          }</span>
<a name="l00886"></a>00886 <span class="comment">      }</span>
<a name="l00887"></a>00887 <span class="comment">    }</span>
<a name="l00888"></a>00888 <span class="comment">}</span>
<a name="l00889"></a>00889 <span class="comment">*/</span>
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 <span class="comment">// much faster, calculate first product of matrix elements with initial vectors</span>
<a name="l00892"></a>00892 <span class="comment">// then product with final vectors in a second step</span>
<a name="l00893"></a>00893 
<a name="l00894"></a><a class="code" href="MultiSlaterDet_8h.html#a72a97049ab2b6317d1ca1d48389d3816">00894</a> <span class="keywordtype">void</span> <a class="code" href="MultiSlaterDet_8c.html#acbbf8d2bbbf2e497389220c221d1934a">calctransitionprojectedMultiMBME</a>(<span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l00895"></a>00895                                       <span class="keyword">const</span> <a class="code" href="structManyBodyOperator.html" title="General ManyBody Operator.">ManyBodyOperator</a>* Op,
<a name="l00896"></a>00896                                       <span class="keyword">const</span> <span class="keywordtype">void</span>* mbme,
<a name="l00897"></a>00897                                       <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* Qfin,
<a name="l00898"></a>00898                                       <span class="keyword">const</span> <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>* Qini,
<a name="l00899"></a>00899                                       <span class="keyword">const</span> <a class="code" href="structIndices.html">Indices</a>* Infin,
<a name="l00900"></a>00900                                       <span class="keyword">const</span> <a class="code" href="structIndices.html">Indices</a>* Inini,
<a name="l00901"></a>00901                                       <span class="keywordtype">int</span> nfin, <span class="keywordtype">int</span> nini,
<a name="l00902"></a>00902                                       <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Efin,
<a name="l00903"></a>00903                                       <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* Eini,
<a name="l00904"></a>00904                                       <span class="keywordtype">void</span>* transmbme)
<a name="l00905"></a>00905 {
<a name="l00906"></a>00906   <span class="keywordtype">int</span> pini,jini,iini, pfin,jfin,ifin;
<a name="l00907"></a>00907   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2orthogonalproj_8c.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, kfin, kini;
<a name="l00908"></a>00908   <span class="keywordtype">int</span> <a class="code" href="HOBasis_8c.html#a89606eca6b563ec68d2da2e84657736f">l</a>, nu;
<a name="l00909"></a>00909   <span class="keywordtype">int</span> p=Op-&gt;<a class="code" href="structManyBodyOperator.html#a78ec7c9f2238907255cf499427676907" title="parity of operator, 0 positve, 1 negative">pi</a>;
<a name="l00910"></a>00910   <span class="keywordtype">int</span> size=Op-&gt;<a class="code" href="structManyBodyOperator.html#a5597272550b373aa2136125a67e5d080" title="might be bigger than dimension">size</a>;
<a name="l00911"></a>00911   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>=Op-&gt;<a class="code" href="structManyBodyOperator.html#a9d2fc8f9d519079b19667ee3c96615db" title="dimension of operator">dim</a>;
<a name="l00912"></a>00912   <span class="keywordtype">int</span> rank=Op-&gt;<a class="code" href="structManyBodyOperator.html#a2839a5170dccc5c19a75a414cccc710f" title="tensor rank of operator, 0 scalar, 2 vector, ...">rank</a>;
<a name="l00913"></a>00913   <span class="keywordtype">int</span> oddini=P-&gt;<a class="code" href="structProjection.html#acac5e7c756632311adca04f228e8886e" title="odd particle number - half integer spin">odd</a>;
<a name="l00914"></a>00914   <span class="keywordtype">int</span> jmax=P-&gt;<a class="code" href="structProjection.html#aaab8cf237ff5e23d0f7abb05117387fe" title="calculate up to (jmax-1)/2">jmax</a>;
<a name="l00915"></a>00915   complex double (****me)[(rank+1)*size] = mbme;
<a name="l00916"></a>00916   complex double (****transme)[size] = transmbme;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   <span class="keywordtype">int</span> afin, aini;
<a name="l00919"></a>00919   <span class="keywordtype">int</span> aafin, aaini;
<a name="l00920"></a>00920   <span class="keywordtype">int</span> dimini, dimfin;
<a name="l00921"></a>00921   <span class="keywordtype">int</span> idxini, idxfin;
<a name="l00922"></a>00922   <span class="keywordtype">int</span> idxaini, idxafin;
<a name="l00923"></a>00923   <span class="keywordtype">int</span> Idxaaini, Idxaafin;
<a name="l00924"></a>00924   <a class="code" href="Symmetry_8h.html#abc0cfc197fb5dfb320dc8f2152faeb73">Symmetry</a> Sini, Sfin;
<a name="l00925"></a>00925 
<a name="l00926"></a>00926   complex <span class="keywordtype">double</span>* meVwork = malloc(Efin-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>*Eini-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>*(jmax+1)*(jmax+1)*size*(rank+1)*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
<a name="l00927"></a>00927 
<a name="l00928"></a>00928   <span class="keywordflow">for</span> (pini=0; pini&lt;=1; pini++)
<a name="l00929"></a>00929     <span class="keywordflow">for</span> (jini=oddini; jini&lt;jmax; jini=jini+2) {
<a name="l00930"></a>00930       
<a name="l00931"></a>00931       idxini = idxpij(jmax,pini,jini);
<a name="l00932"></a>00932       dimini=Eini-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>*(jini+1);
<a name="l00933"></a>00933 
<a name="l00934"></a>00934       pfin=(pini+p)%2;
<a name="l00935"></a>00935       <span class="keywordflow">for</span> (jfin=abs(jini-rank); jfin&lt;=min(jmax-1,jini+rank); jfin=jfin+2) {
<a name="l00936"></a>00936 
<a name="l00937"></a>00937         idxfin = idxpij(jmax,pfin,jfin);
<a name="l00938"></a>00938         dimfin=Efin-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>*(jfin+1);
<a name="l00939"></a>00939 
<a name="l00940"></a>00940         complex double (*meV)[dimini][(jini+1)][size*(rank+1)] = meVwork;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942         <span class="keywordflow">for</span> (iini=0; iini&lt;Eini-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxini]; iini++) {
<a name="l00943"></a>00943           idxafin=-1;
<a name="l00944"></a>00944           <span class="keywordflow">for</span> (afin=0; afin&lt;nfin; afin++)
<a name="l00945"></a>00945             <span class="keywordflow">for</span> (aafin=0; aafin&lt;Infin[afin].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aafin++) {
<a name="l00946"></a>00946               idxafin++;
<a name="l00947"></a>00947               <span class="keywordflow">for</span> (k=-jini; k&lt;=jini; k=k+2)
<a name="l00948"></a>00948                 <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00949"></a>00949                   <span class="keywordflow">for</span> (nu=-rank; nu&lt;=rank; nu=nu+2)
<a name="l00950"></a>00950                     meV[idxafin][iini][idxjm(jini,k)][(nu+rank)/2+l*(rank+1)] = 0.0;
<a name="l00951"></a>00951             }
<a name="l00952"></a>00952         }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         <span class="keywordflow">for</span> (iini=0; iini&lt;Eini-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxini]; iini++) {
<a name="l00955"></a>00955           idxafin=-1;
<a name="l00956"></a>00956           <span class="keywordflow">for</span> (afin=0; afin&lt;nfin; afin++)
<a name="l00957"></a>00957             <span class="keywordflow">for</span> (aafin=0; aafin&lt;Infin[afin].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aafin++) {
<a name="l00958"></a>00958               idxafin++;
<a name="l00959"></a>00959               Idxaafin = Infin[afin].<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[aafin];
<a name="l00960"></a>00960               Sfin = Qfin[afin].<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(&amp;Qfin[afin], Idxaafin);
<a name="l00961"></a>00961 
<a name="l00962"></a>00962               <span class="keywordflow">for</span> (k=-jini; k&lt;=jini; k=k+2) {
<a name="l00963"></a>00963                 idxaini=-1;
<a name="l00964"></a>00964                 <span class="keywordflow">for</span> (aini=0; aini&lt;nini; aini++)
<a name="l00965"></a>00965                   <span class="keywordflow">for</span> (aaini=0; aaini&lt;Inini[aini].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aaini++) {
<a name="l00966"></a>00966                     idxaini++;
<a name="l00967"></a>00967                     Idxaaini = Inini[aini].<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[aaini];
<a name="l00968"></a>00968                     Sini = Qini[aini].<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(&amp;Qini[aini], Idxaaini);
<a name="l00969"></a>00969 
<a name="l00970"></a>00970                     <span class="keywordflow">for</span> (kini=-jini; kini&lt;=jini; kini=kini+2)
<a name="l00971"></a>00971                       <span class="keywordflow">if</span> (<a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sini, pini, jini, kini)) {
<a name="l00972"></a>00972               
<a name="l00973"></a>00973                         <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00974"></a>00974                           <span class="keywordflow">for</span> (nu=-rank; nu&lt;=rank; nu=nu+2)
<a name="l00975"></a>00975                             meV[idxafin][iini][idxjm(jini,k)][(nu+rank)/2+l*(rank+1)] +=
<a name="l00976"></a>00976                               me[afin+aini*nfin][Idxaafin+Idxaaini*Infin[afin].<a class="code" href="structIndices.html#abfe5e6bb66f0da8ad7d27585ea390c01" title="out of N many-body states">N</a>][idxini][idxjmk(jini,k,kini)][(nu+rank)/2+l*(rank+1)]*
<a name="l00977"></a>00977                               Eini-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idxini][idxjm(jini,kini)+idxaini*(jini+1)+iini*dimini];
<a name="l00978"></a>00978                       } 
<a name="l00979"></a>00979                   }     
<a name="l00980"></a>00980               }
<a name="l00981"></a>00981             }
<a name="l00982"></a>00982         }
<a name="l00983"></a>00983 
<a name="l00984"></a>00984         <span class="keywordflow">for</span> (iini=0; iini&lt;Eini-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxini]; iini++)
<a name="l00985"></a>00985           <span class="keywordflow">for</span> (ifin=0; ifin&lt;Efin-&gt;<a class="code" href="structEigenstates.html#a4f66da767b0c0350e503f28d8f9961f0" title="number of eigenstates calculated by SVD">dim</a>[idxfin]; ifin++) {
<a name="l00986"></a>00986 
<a name="l00987"></a>00987             <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l00988"></a>00988               transme[idxfin][idxini][ifin][iini][l] = 0.0;
<a name="l00989"></a>00989 
<a name="l00990"></a>00990             idxafin=-1;
<a name="l00991"></a>00991             <span class="keywordflow">for</span> (afin=0; afin&lt;nfin; afin++)
<a name="l00992"></a>00992               <span class="keywordflow">for</span> (aafin=0; aafin&lt;Infin[afin].<a class="code" href="structIndices.html#a6d98d6fb921dd51862b4164cb09d6515" title="describe n many-body states">n</a>; aafin++) {
<a name="l00993"></a>00993                 idxafin++;
<a name="l00994"></a>00994                 Idxaafin = Infin[afin].<a class="code" href="structIndices.html#ac1c3f9f2bca1f1934a43e9def6599a4f">idx</a>[aafin];
<a name="l00995"></a>00995                 Sfin = Qfin[afin].<a class="code" href="struct__MSD__.html#a34f5b97aa2ded110084030cb5128620f" title="Symmetry.">symmetry</a>(&amp;Qfin[afin], Idxaafin);
<a name="l00996"></a>00996                       
<a name="l00997"></a>00997                 <span class="keywordflow">for</span> (kfin=-jfin; kfin&lt;=jfin; kfin=kfin+2)
<a name="l00998"></a>00998                   <span class="keywordflow">for</span> (k=max(-jini,kfin-rank); k&lt;=min(jini,kfin+rank); k=k+2) {
<a name="l00999"></a>00999                     nu = kfin-k;
<a name="l01000"></a>01000                     <span class="keywordflow">if</span> (<a class="code" href="Symmetry_8c.html#aec41b8bd88dceb2a0c5c3c4c4a8fefdb" title="quantum numbers J^pi,K allowed by symmetry ?">SymmetryAllowed</a>(Sfin, pfin, jfin, kfin)) {
<a name="l01001"></a>01001                       <span class="keywordflow">for</span> (l=0; l&lt;dim; l++)
<a name="l01002"></a>01002                         transme[idxfin][idxini][ifin][iini][l] +=
<a name="l01003"></a>01003                           <a class="code" href="clebsch_8c.html#a7b75250723cf843449ee508426c81537">clebsch</a>(jini, rank, jfin, k, nu, kfin)*
<a name="l01004"></a>01004                           conj(Efin-&gt;<a class="code" href="structEigenstates.html#a6e03cbd0f964bc8d73161266831cc874" title="eigenvectors">V</a>[idxfin][idxjm(jfin,kfin)+idxafin*(jfin+1)+ifin*dimfin])*
<a name="l01005"></a>01005                           meV[idxafin][iini][idxjm(jini,k)][(nu+rank)/2+l*(rank+1)];
<a name="l01006"></a>01006                     }     
<a name="l01007"></a>01007                   }
<a name="l01008"></a>01008               }  
<a name="l01009"></a>01009           }     
<a name="l01010"></a>01010       }
<a name="l01011"></a>01011     }
<a name="l01012"></a>01012 
<a name="l01013"></a>01013   free(meVwork);
<a name="l01014"></a>01014 }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 
<a name="l01017"></a><a class="code" href="MultiSlaterDet_8h.html#acb8c1ee49806f2cf7cee284464ecf981">01017</a> <span class="keywordtype">int</span> <a class="code" href="MultiSlaterDet_8c.html#acb8c1ee49806f2cf7cee284464ecf981">writeMultiEigenstatestoFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* fname,
<a name="l01018"></a>01018                                 <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01019"></a>01019                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* mbfile,
<a name="l01020"></a>01020                                 <span class="keyword">const</span> <a class="code" href="structIndices.html">Indices</a>* In,
<a name="l01021"></a>01021                                 <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E)
<a name="l01022"></a>01022 {
<a name="l01023"></a>01023   FILE* fp;
<a name="l01024"></a>01024   <span class="keywordtype">char</span> filename[255];
<a name="l01025"></a>01025 
<a name="l01026"></a>01026   snprintf(filename, 255, <span class="stringliteral">&quot;%s.estates&quot;</span>, fname);
<a name="l01027"></a>01027 
<a name="l01028"></a>01028   <span class="keywordflow">if</span> (!(fp = fopen(filename, <span class="stringliteral">&quot;w&quot;</span>))) {
<a name="l01029"></a>01029     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for writing\n&quot;</span>, filename);
<a name="l01030"></a>01030     <span class="keywordflow">return</span> -1;
<a name="l01031"></a>01031   }     
<a name="l01032"></a>01032 
<a name="l01033"></a>01033   <a class="code" href="utils_8c.html#ae3c710edac30cf257199e6595212a75a" title="print info about running process">fprintinfo</a>(fp);
<a name="l01034"></a>01034   <a class="code" href="Projection_8c.html#af11f2a70292f93f6b5983cfc4f26d774">fprintProjectinfo</a>(fp, P);
<a name="l01035"></a>01035   fprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01036"></a>01036   fprintf(fp, <span class="stringliteral">&quot;&lt;Projected %s&gt;\n&quot;</span>, <a class="code" href="Projection_8c.html#ac87bb7fb183abeb15fc0454df5babd55">ProjectiontoStr</a>(P));
<a name="l01037"></a>01037 
<a name="l01038"></a>01038   fprintf(fp, <span class="stringliteral">&quot;&lt;MultiSlaterDet %s %s %s&gt;\n&quot;</span>,
<a name="l01039"></a>01039           mbfile, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfile), <a class="code" href="MultiSlaterDet_8c.html#a91d5b4deab687d45ccd81990914b95e4">IndicestoStr</a>(In));
<a name="l01040"></a>01040   fprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01041"></a>01041     
<a name="l01042"></a>01042   <a class="code" href="Projection_8c.html#a6efb4a37227aadf15910f7270a97a486">writeEigenstates</a>(fp, P, E);
<a name="l01043"></a>01043 
<a name="l01044"></a>01044   fprintf(fp, <span class="stringliteral">&quot;&lt;/Projected&gt;\n&quot;</span>);
<a name="l01045"></a>01045   fclose(fp);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   <span class="keywordflow">return</span> 0;
<a name="l01048"></a>01048 }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 
<a name="l01051"></a><a class="code" href="MultiSlaterDet_8h.html#aa0927c7080e17e5af785de468357bd6c">01051</a> <span class="keywordtype">int</span> <a class="code" href="MultiSlaterDet_8c.html#aa0927c7080e17e5af785de468357bd6c">writeMultiMulticonfigfile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* fname,
<a name="l01052"></a>01052                               <span class="keyword">const</span> <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01053"></a>01053                               <span class="keyword">const</span> <span class="keywordtype">char</span>** mbfile,
<a name="l01054"></a>01054                               <span class="keyword">const</span> <a class="code" href="structIndices.html">Indices</a>* In,
<a name="l01055"></a>01055                               <span class="keywordtype">int</span> n,
<a name="l01056"></a>01056                               <span class="keyword">const</span> <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E)
<a name="l01057"></a>01057 {
<a name="l01058"></a>01058   FILE* fp;
<a name="l01059"></a>01059   <span class="keywordtype">char</span> filename[255];
<a name="l01060"></a>01060 
<a name="l01061"></a>01061   snprintf(filename, 255, <span class="stringliteral">&quot;%s.states&quot;</span>, fname);
<a name="l01062"></a>01062 
<a name="l01063"></a>01063   <span class="keywordflow">if</span> (!(fp = fopen(filename, <span class="stringliteral">&quot;w&quot;</span>))) {
<a name="l01064"></a>01064     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for writing\n&quot;</span>, filename);
<a name="l01065"></a>01065     <span class="keywordflow">return</span> -1;
<a name="l01066"></a>01066   }     
<a name="l01067"></a>01067 
<a name="l01068"></a>01068   <a class="code" href="utils_8c.html#ae3c710edac30cf257199e6595212a75a" title="print info about running process">fprintinfo</a>(fp);
<a name="l01069"></a>01069   <a class="code" href="Projection_8c.html#af11f2a70292f93f6b5983cfc4f26d774">fprintProjectinfo</a>(fp, P);
<a name="l01070"></a>01070   fprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01071"></a>01071   fprintf(fp, <span class="stringliteral">&quot;&lt;Multiconfprojected %d %d %s&gt;\n&quot;</span>, n, E-&gt;<a class="code" href="structEigenstates.html#aa5deea949876b2d562c5c5129c119e76">n</a>, <a class="code" href="Projection_8c.html#ac87bb7fb183abeb15fc0454df5babd55">ProjectiontoStr</a>(P));
<a name="l01072"></a>01072 
<a name="l01073"></a>01073   <span class="keywordtype">int</span> i;
<a name="l01074"></a>01074   <span class="keywordflow">for</span> (i=0; i&lt;n; i++)
<a name="l01075"></a>01075     fprintf(fp, <span class="stringliteral">&quot;&lt;MBFile %s %s %s&gt;\n&quot;</span>,
<a name="l01076"></a>01076             mbfile[i], <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(mbfile[i]), <a class="code" href="MultiSlaterDet_8c.html#a91d5b4deab687d45ccd81990914b95e4">IndicestoStr</a>(&amp;In[i]));
<a name="l01077"></a>01077   fprintf(fp, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01078"></a>01078     
<a name="l01079"></a>01079   <a class="code" href="Projection_8c.html#a6efb4a37227aadf15910f7270a97a486">writeEigenstates</a>(fp, P, E);
<a name="l01080"></a>01080 
<a name="l01081"></a>01081   fprintf(fp, <span class="stringliteral">&quot;&lt;/Multiconfprojected&gt;\n&quot;</span>);
<a name="l01082"></a>01082   fclose(fp);
<a name="l01083"></a>01083 
<a name="l01084"></a>01084   <span class="keywordflow">return</span> 0;
<a name="l01085"></a>01085 }
<a name="l01086"></a>01086 
<a name="l01087"></a>01087 
<a name="l01088"></a><a class="code" href="MultiSlaterDet_8h.html#ac81ab06089de20c64b4f14d7309d3b8d">01088</a> <span class="keywordtype">int</span> <a class="code" href="MultiSlaterDet_8c.html#ac81ab06089de20c64b4f14d7309d3b8d">readMultiMulticonfigfile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* fname,
<a name="l01089"></a>01089                              <span class="keywordtype">char</span>*** mbfilep,
<a name="l01090"></a>01090                              <a class="code" href="structProjection.html" title="Projection.">Projection</a>* <a class="code" href="MinimizerDONLP2_8c.html#a937218b25a684555a6d94a5058c7b358">P</a>,
<a name="l01091"></a>01091                              <a class="code" href="struct__MSD__.html">MultiSlaterDet</a>** <a class="code" href="MinimizerDONLP2multivapp_8c.html#a302070733a377867b458d28f3146454f">Qp</a>,
<a name="l01092"></a>01092                              <a class="code" href="structIndices.html">Indices</a>** Inp,
<a name="l01093"></a>01093                              <span class="keywordtype">int</span>* nstates,
<a name="l01094"></a>01094                              <a class="code" href="structEigenstates.html" title="Container for Eigenstates.">Eigenstates</a>* E)
<a name="l01095"></a>01095 {
<a name="l01096"></a>01096   FILE* fp;
<a name="l01097"></a>01097   <span class="keywordtype">char</span> buf[BUFSIZE];
<a name="l01098"></a>01098   <span class="keywordtype">int</span> i, n;
<a name="l01099"></a>01099   <span class="keywordtype">char</span> msldetfname[255], md5msldetfname[33];
<a name="l01100"></a>01100 
<a name="l01101"></a>01101   <span class="keywordflow">if</span> (!(fp = fopen(fname, <span class="stringliteral">&quot;r&quot;</span>))) {
<a name="l01102"></a>01102     fprintf(stderr, <span class="stringliteral">&quot;couldn&#39;t open %s for reading\n&quot;</span>, fname);
<a name="l01103"></a>01103     <span class="keywordflow">return</span> -1;
<a name="l01104"></a>01104   }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106   <span class="comment">// get the Projection parameters</span>
<a name="l01107"></a>01107   <span class="keywordflow">do</span>    
<a name="l01108"></a>01108     fgets(buf, <a class="code" href="MultiSlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l01109"></a>01109   <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;Multiconfprojected &quot;</span>, 19) &amp;&amp; !feof(fp));
<a name="l01110"></a>01110   <span class="keywordflow">if</span> (feof(fp)) {
<a name="l01111"></a>01111     fprintf(stderr, <span class="stringliteral">&quot;didn&#39;t find &lt;Multiconfprojected ...&gt;\n&quot;</span>);
<a name="l01112"></a>01112     <span class="keywordflow">return</span> -1;
<a name="l01113"></a>01113   }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115   <span class="keywordtype">int</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ad5bd801f521717ed9f092360c3ba3b5e">dim</a>;
<a name="l01116"></a>01116   <span class="keywordtype">char</span> <a class="code" href="MinimizerDONLP2multivapp_8c.html#ae51b51057e3a9d5aa3905eed7979dca1">projpar</a>[40];
<a name="l01117"></a>01117   sscanf(buf, <span class="stringliteral">&quot;&lt;Multiconfprojected %d %d %s&gt;&quot;</span>, &amp;n, &amp;dim, projpar);
<a name="l01118"></a>01118   *nstates = n;
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   <span class="comment">// read the Slater determinants</span>
<a name="l01121"></a>01121   *mbfilep = (<span class="keywordtype">char</span>**) malloc(n*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
<a name="l01122"></a>01122   <span class="keywordflow">for</span> (i=0; i&lt;n; i++)
<a name="l01123"></a>01123     (*mbfilep)[i] = (<span class="keywordtype">char</span>*) malloc(255*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01124"></a>01124   *Qp = malloc(n*<span class="keyword">sizeof</span>(<a class="code" href="struct__MSD__.html">MultiSlaterDet</a>));
<a name="l01125"></a>01125   *Inp = malloc(n*<span class="keyword">sizeof</span>(<a class="code" href="structIndices.html">Indices</a>));
<a name="l01126"></a>01126   <span class="keywordtype">char</span>* fileIn = malloc(255*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01127"></a>01127   <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
<a name="l01128"></a>01128     <span class="keywordflow">do</span>  
<a name="l01129"></a>01129       fgets(buf, <a class="code" href="MultiSlaterDet_8c.html#aeca034f67218340ecb2261a22c2f3dcd">BUFSIZE</a>, fp);
<a name="l01130"></a>01130     <span class="keywordflow">while</span> (strncmp(buf, <span class="stringliteral">&quot;&lt;MBFile &quot;</span>, 7) &amp;&amp; !feof(fp));
<a name="l01131"></a>01131     <span class="keywordflow">if</span> (feof(fp)) {
<a name="l01132"></a>01132       fprintf(stderr, <span class="stringliteral">&quot;...   did&#39;t find &lt;SlaterDetFile ...&gt;\n&quot;</span>);
<a name="l01133"></a>01133       fclose(fp);
<a name="l01134"></a>01134       <span class="keywordflow">return</span> -1;
<a name="l01135"></a>01135     }
<a name="l01136"></a>01136     sscanf(buf, <span class="stringliteral">&quot;&lt;MBFile %s %s %s&gt;&quot;</span>, msldetfname, md5msldetfname, fileIn);
<a name="l01137"></a>01137     <a class="code" href="MultiSlaterDet_8c.html#aeb9c0b0c54f48ada63a9c1b8b7683e2e">extractIndicesfromString</a>(&amp;fileIn, &amp;(*Inp)[i]);
<a name="l01138"></a>01138     <span class="keywordflow">if</span> (strncmp(md5msldetfname, <a class="code" href="utils_8c.html#a70474eaf20d7c9cbd95b9d2b6fb6eb55" title="create md5 hash for file fname">md5hash</a>(msldetfname), 32)) {
<a name="l01139"></a>01139       fprintf(stderr, <span class="stringliteral">&quot;...    MultiSlaterDetFile %s changed\n&quot;</span>, msldetfname);
<a name="l01140"></a>01140       <span class="keywordflow">return</span> -1;
<a name="l01141"></a>01141     }
<a name="l01142"></a>01142     strcpy((*mbfilep)[i], msldetfname);
<a name="l01143"></a>01143     <span class="keywordflow">if</span> (<a class="code" href="MultiSlaterDet_8c.html#a1314981c2216f7ca18928d2679178535">readMultiSlaterDetfromFile</a>(&amp;(*Qp)[i], &amp;(*Inp)[i], msldetfname))
<a name="l01144"></a>01144       <span class="keywordflow">return</span> -1;
<a name="l01145"></a>01145   }
<a name="l01146"></a>01146   
<a name="l01147"></a>01147   <span class="comment">// odd or even ?</span>
<a name="l01148"></a>01148   <span class="keywordtype">int</span> odd = Qp[0]-&gt;<a class="code" href="struct__MSD__.html#a999772a06b90565150e39f99d8429589" title="particle number">A</a> % 2;
<a name="l01149"></a>01149 
<a name="l01150"></a>01150   <span class="comment">// initialize Projection</span>
<a name="l01151"></a>01151   <a class="code" href="Projection_8c.html#a8933a4a47f0572f2e2943562cd45aac5">initProjection</a>(P, odd, projpar);
<a name="l01152"></a>01152 
<a name="l01153"></a>01153   <span class="comment">// read the Eigenstates</span>
<a name="l01154"></a>01154   <span class="keywordflow">if</span> (<a class="code" href="Projection_8c.html#a21bd7a5920ce98dea99f5ecbe591b799">readEigenstates</a>(fp, P, E, dim))
<a name="l01155"></a>01155     <span class="keywordflow">return</span> -1;
<a name="l01156"></a>01156 
<a name="l01157"></a>01157   <span class="keywordflow">return</span> 0;
<a name="l01158"></a>01158 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 4 2012 14:05:34 for FMD by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
