C   CONDITIONS OF USE:
C
C1. DONLP2 IS UNDER THE EXCLUSIVE COPYRIGHT OF  P. SPELLUCCI
C   (E-MAIL:SPELLUCCI@MATHEMATIK.TU-DARMSTADT.DE)
C   "DONLP2" IS A RESERVED NAME
C2. DONLP2 AND ITS CONSTITUENT PARTS COME WITH NO WARRANTY, WHETHER EX-
C   PRESSED OR IMPLIED, THAT IT IS FREE OF ERRORS ORE SUITABLE FOR ANY
C   SPECIFIC PURPOSE.
C   IT MUST NOT BE USED TO SOLVE ANY PROBLEM, WHOSE INCORRECT SOLUTION
C   COULD RESULT IN INJURY TO A PERSON , INSTITUTION OR PROPERTY.   
C   IT IS AT THE USERS OWN RISK TO USE DONLP2 OR PARTS OF IT AND THE
C   AUTHOR DISCLAIMS ALL LIABILITY FOR SUCH USE.
C3. DONLP2 IS DISTRIBUTED "AS IS". IN PARTICULAR, NO MAINTENANCE, 
C   SUPPORT
C   OR TROUBLE-SHOOTING OR SUBSEQUENT UPGRADE IS IMPLIED.
C4. THE USE OF DONLP2 MUST BE ACKNOWLEDGED, IN ANY PUBLICATION 
C   WHICH CONTAINS
C   RESULTS OBTAINED WITH IT OR PARTS OF IT. CITATION OF THE 
c   AUTHORS NAME
C   AND NETLIB-SOURCE IS SUITABLE. 
C5. THE FREE USE OF DONLP2 AND PARTS OF IT IS RESTRICTED FOR 
C   RESEARCH PURPOSES.
C   COMMERCIAL USES REQUIRE PERMISSION AND LICENSING FROM P. SPELLUCCI.
C     D O N L P  2
C   VERSION 09/07/99
C   TAUQP DEPENDENT ON SCALRES ONLY 
C   WEIGHTS COMPUTED IN A MODIFIED VERSION IN THE SINGULAR CASE
C   SOME COMPARISONS RELATIVE TO ZERO CHANGED
C   ERROR-RETURN FOR FUNCTION EVALUATION AS ADDED FEATURE
C   TERMINATION OF QP-SOLVER CHANGED (D NOT SET TO ZERO)
C   NEW VERSION OF BFGS: IF NR = 0 TAKE POWELL'S UPDATE 
C   NO SUPPRESSION OF UPDATE BEFOREHAND (WITH EXCEPTION DG=0)
C   PLUS SOME MINOR CORRECTIONS
C
C   FOR CONSISTENCY REASONS VARIABLE NAMES CF AND CGF CHANGED INTO 
C   ICF AND ICGF
C   NEW USER VARIABLES EPSPHI and NUMSM introduced for user control of 
C   TERMINATION DUE TO SMALL PROGRESS IN OBJECTIVE FUNCTION VALUE
C
C   ADDED FEATURE NUMERICAL DIFFERENTIATION OF ORDER 1,2,6 
C   REQUIRES NEW PARAMETERS EPSFCN, TAUBND, DIFFTYPE
C
C   ADDED FEATURE OF EXTERNAL BLOCKWISE EVALUATION OF FUNCTIONS
C   RATHER THAN INDIVIDUAL EVALUATION
C   REQUIRES NEW PARAMETER BLOC
C
C   NEW FEATURE OF USER-SUPPLIED SCALING OF X 
C   
C   CALLING O8ST IMMEDIATELY AFTER SETUP0 (CORRECTION)
C
C   CORRECTION CONCERNING COMPUTATION OF DD 
C   (SECOND ORDER CORRECTION OF X)
C   IN CASE OF BOUND VIOLATION: VIOBND ADDED
C
C   CORRECTION FOR FEASIBLE OPTIMAL POINT IN ITSTEP 2 (O8QPDU)
C   CHANGED TERMINATION CRITERION, ADDED SETTINGS AFTER L2000
C*******************************************************************
      SUBROUTINE DONLP2
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8FINT.INC'
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION YY(NX),O8VECN
      INTEGER I,J,IDUM
      REAL O8CPU
      SAVE
C  DEFAULT SETTINGS OF NEW PARAMETERS
      BLOC=.FALSE.
      ANALYT=.TRUE.
      VALID=.FALSE.
      EPSFCN=1.D-16
      DIFFTYPE=3
      TAUBND=1.D0
      DO I=1,NX
        XSC(I)=ONE
        XTR(I)=ZERO
      ENDDO
      EPSDIF=TM8
      DO I=0,NRESM
C*** PRESENTLY, THE TEST-CASES IN THE TESTENVIRONMENT DO 
C    NOT DIFFERENTIATE 
C    BETWEEN LINEAR AND
C*** NONLINEAR CONSTRAINTS. FOR LATER EXTENSIONS OR USERS 
C*** FUNCTIONS THIS:
        GCONST(I)=.FALSE.
        VAL(I)=.FALSE.
        IF ( I .GT. 0 ) GRESN(I)=ONE
      ENDDO
      DO I=1,NRESM
        CFUERR(I)=.FALSE.
C*** THE ERROR INDICATOR OF THE FUNCTION EVALUATION
      ENDDO
      FFUERR=.FALSE.
      
C
C     SOME STANDARD INITIALIZATION WHICH MAY BE OVERWRITTEN BY
C     SETUP0 OR SETUP
C
      INX=.FALSE.
      SILENT=.FALSE.
C***** THE INTERACTIVE INPUT FEATURE IS NO LONGER SUPPORTED HERE. 
C***** FOR THE SAKE
C***** OF EASY REVISION THE VARIABLE IS SUPPLIED HERE HOWEVER
C***** IF INTAKT IS SET TRUE, OUTPUT TO PROTOCOL FILE IS COPIED TO 
C***** STDOUT IN ADDITION
      INTAKT=.FALSE.
      TE0=.FALSE.
      TE1=.FALSE.
      TE2=.FALSE.
      TE3=.FALSE.
      COLD=.TRUE.
      PROU=10
      MEU=20
C***  SETUP0 MUST INITIALIZE  ANALYT, EPSDIF, DEL0, TAU0 , N , NH , 
C     NG , GUNIT
C     GCONST , EPSFCN , TAUBND , ANALYT , BLOC , DIFFTYPE 
C     AND THE INITIAL VALUE FOR X
C     (MIGHT BE ALSO DONE IN BLOCK DATA OF COURSE)
C     MAY ALSO CHANGE SETTINGS OF ALL VARIABLES INITIALIZED ABOVE
C     OR VIA BLOCKDATA
C***
      CALL SETUP0
C
      CALL O8ST
C
C***
C*** 
C***  THE DEFAULT FOR NUMSM
      NUMSM=MAX(N,10)
      DO I=1,N
        XST(I)=X(I)
        IF ( XSC(I) .EQ. ZERO ) THEN
          WRITE(*,*)  'SCALING VARIABLE ',I,' IS ZERO'
          STOP
        ENDIF 
        X(I)=X(I)/XSC(I)
        YY(I)=XSC(I)  
      ENDDO
      NRESET=N
C     DEFAULT FOR EPSPHI
      EPSPHI=TP3*EPSMAC
C***  SETUP MAY CHANGE STANDARD SETTTINGS OF PARAMETERS 
C     AND ADD SOME COMPUTATIONS
C     IN THE USER ENVIRONMENT
C
      DO I=1,N
C**** UG AND OG HAVE BEEN EVALUTED FOR THE ORIGINAL VARIABLES
C**** HERE WE USE THEM INTERNALLY FOR THE SCALED ONES
        IF ( LLOW(I) ) UG(I)=UG(I)/XSC(I)
        IF ( LUP(I) ) OG(I)=OG(I)/XSC(I)
      ENDDO
      CALL SETUP
      IF ( TAUBND .EQ. ZERO ) STOP 'TAUBND MAY NOT BE ZERO'
      DO I=1,N 
        IF (YY(I) .NE. XSC(I) ) 
     *     STOP 'CHANGE OF XSC IN SETUP NOT ALLOWED'
      ENDDO 
C*** PREEVALUATION OF GRADIENTS OF LINEAR FUNCTIONS
C    DONE ONLY ONCE
C
      DO I=0,NRES
        IF ( GUNIT(1,I) .NE. 1 .AND. GCONST(I) ) THEN
C****** EVALUATE GRADIENT ONCE
          IF ( I .EQ. 0 ) THEN
            VAL(0)=.TRUE.
            CALL ESGRADF(X,GRADF)
          ELSE
            VAL(I)=.TRUE.
            IF ( I .LE. NH ) THEN
              CALL ESGRADH(I,X,YY)
            ELSE
              CALL ESGRADG(I-NH,X,YY)
            ENDIF
            DO J=1,N
              GRES(J,I)=YY(J)
            ENDDO
            GRESN(I)=MAX(ONE,O8VECN(1,N,YY))
          ENDIF
        ENDIF
      ENDDO
      IDUM=0
      RUNTIM=O8CPU(IDUM)
C***** CALL THE OPTIMIZER
      CALL O8OPTI
      RUNTIM=O8CPU(IDUM)-RUNTIM
C*****
C***** DO FINAL SOLUTION CHECK AND OUTPUT
      CALL O8FIN
      RETURN
      END
C************************************************************
      SUBROUTINE O8ST
C************************************************************
C    INITIALIZATION PROGRAM , STANDARD PARAMETER SETTINGS DONE HERE
C************************************************************
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INCLUDE 'O8FINT.INC'
      INTEGER I,J,K,IZ
      DOUBLE PRECISION TOL1 ,XNULL(NX),BD0,
     *                 INFINY,GXI,HXI,TERM
      CHARACTER*8 FIL,XXX,NAME1
      SAVE
      DATA XXX/'XXXXXXXX'/
      EPSMAC = TWO**(-20)
100   CONTINUE
      EPSMAC=EPSMAC/TWO
      TERM=ONE+EPSMAC
      IF ( TERM .NE. ONE ) GOTO 100
      EPSMAC=EPSMAC+EPSMAC
      TOLMAC=EPSMAC
200   CONTINUE
      TOL1=TOLMAC
      TOLMAC=TOLMAC/TWOP4
      IF ( TOLMAC .NE. ZERO ) GOTO 200
      TOLMAC=TOL1

C******** EPSMAC MACHINE PRECISION, TOLMAC SMALLEST MACHINE NUMBER
C******** LARGER THAN ZERO (APPROXIMATELY , BASE 16 FOR EXPONENT 
C******** THEREFORE DIVISION BY 16 ASSUMED)
C
C***** WARNING 
C      ON SOME MACHINES THE COMPUTATION OF TOLMAC MAY RESULT IN AN 
C      ERROR
C      BECAUSE UNDERFLOW IS NOT ACCEPTED AS ZERO AS IS ASSUMED HERE
C
C*****
      IF ( N .GT. NX ) STOP 'DONLP2: N TOO LARGE/RECOMPILE'
      IF ( NH+NG .GT. NRESM )STOP 'DONLP2:NH OR NG TOO LARGE/RECOMPILE'
      IF ( TAU0 .EQ. ZERO ) TAU0=ONE
      IF ( DEL0 .EQ. ZERO ) DEL0=TAU0*P5
C      IF ( DEL0 .GT. TAU0 ) DEL0=TAU0*P5
      IF ( NRESET .GT. N )  NRESET=N
      IF ( NRESET .LE. 4  ) NRESET=4
C****** STANDARD INITIALIZATION
      LASTCH=0
      LASTDW=0
      LASTUP=0
      LEVEL=ONE
      TAU=TM1
      ITERMA=MAXIT
      EPSX=TM5
      SIGSM=SQRT(EPSMAC)
      SMALLD=TM1
C FORMERLY TM2. SMALLD HAS MUCH INFLUENCE ON THE MARATOS-EFFECT
      SMALLW=EXP(TWO*LOG(EPSMAC)/THREE)
      RHO=TM6
      RHO1=TM10
      DEL01=DEL0/TP1
      DELMIN=MIN(DEL01,MAX(TM6*DEL0,SMALLW))
      IF ( .NOT. ANALYT ) DELMIN=MIN(DEL01,MAX(EPSDIF,DELMIN))
      C1D=TM2
      SCFMAX=TP4
      TAUFAC=TP1
      TAUMAX=SCFMAX**2
      UPDMY0=TM1
C     TAKE DEL0 AND TAU0 FROM BLOCK DATA OR SETUP0 IN FUNCTION 
C     DEFINITION
C     MAY BE MODIFIED BY SUBSEQUENT CALL OF SETUP
        J=1
        DO WHILE ( INDEX(NAME(J:40),' ') .EQ. 1 )
          J=J+1
        ENDDO
        IF ( J .GT. 40 ) THEN
          FIL=XXX
        ELSE
          K=INDEX(NAME(J:40),' ')
          K=K+J-1
          IF ( K .GT. J+7 ) K=J+7
          IF ( K .LT. J ) K=J
          IF ( K .GT. 40 ) K=40
          NAME1=NAME(J:K)
          DO I=1,K-J+1
            IZ=ICHAR(NAME1(I:I))
            IF ( IZ .LT. 48 .OR. ( IZ .GT. 57 .AND. IZ .LT. 65 )
     F       .OR. ( IZ .GT. 90 .AND. IZ .LT. 97 ) .OR. IZ .GT. 122 )
     F      NAME1(I:I)='X'
          ENDDO
          IF ( K .LT. J+7 ) THEN
            FIL=NAME1(1:K-J+1)//XXX(1:J+7-K)
          ELSE
            FIL=NAME1(1:8)
          ENDIF
        ENDIF
      IF ( .NOT. SILENT ) OPEN(MEU,FILE=FIL//'.MES',STATUS='UNKNOWN')
      IF ( .NOT. SILENT ) OPEN(PROU,FILE=FIL//'.PRO',STATUS='UNKNOWN')
      INFINY=EPSMAC/TOLMAC
      FX=ZERO
      B2N=ZERO
      B2N0=ZERO
      NRES=NG+NH
      IF ( COLD ) THEN
        DO I=1,NX
          DO J=1,NX
            A(J,I)=ZERO
          ENDDO
          A(I,I)=ONE
          DIAG0(I)=ONE
        ENDDO
      ENDIF
      DO I=1,NRESM
        DIAG(I)=ZERO
        DO J=1,NX
          QR(J,I)=ZERO
          GRES(J,I)=ZERO
        ENDDO
      ENDDO
      DO I=1,NX
        XNULL(I)=ZERO
        UG(I)=-INFINY
        OG(I)=INFINY
        LLOW(I)=.FALSE.
        LUP(I)=.FALSE.
      ENDDO
      DO I=1,NH
        DELFAC(I)=ONE
      ENDDO
      IF ( BLOC ) CALL USER_EVAL(XNULL,0)
      DO I=NH+1,NRES
        DELFAC(I)=ONE
C***** SCAN FOR REAL LOWER OR UPPER BOUNDS
        IF ( GUNIT(1,I) .EQ. 1 ) THEN
          CALL ESG(I-NH,XNULL,GXI)
          IF ( GUNIT(3,I) .GT. 0 ) THEN
            LLOW(GUNIT(2,I))=.TRUE.
            UG(GUNIT(2,I))=-GXI/GUNIT(3,I)
          ELSE
            OG(GUNIT(2,I))=-GXI/GUNIT(3,I)
            LUP(GUNIT(2,I))=.TRUE.
          ENDIF
        ENDIF
      ENDDO
      DO I=NH+1,NRES
C**** MODIFY DEL0, SUCH THAT LOWER AND UPPER BOUND NEVER BECOME 
C     BINDING SIMULTANEOUSLY
        IF ( GUNIT(1,I) .EQ. 1 ) THEN
          J=GUNIT(2,I)
          IF ( OG(J) .LT. INFINY .AND. UG(J) .GT. -INFINY ) THEN
            DEL0=MIN(DEL0,(OG(J)-UG(J))*TM1*ABS(GUNIT(3,I)))
          ENDIF
        ENDIF
      ENDDO
      DO I=NH+1,NRES
C**** DELFAC CORRESPONDS TO AN INDIRECT PRIMAL SCALING
        IF ( GUNIT(1,I) .EQ. 1 ) THEN
          J=GUNIT(2,I)
          IF ( GUNIT(3,I) .GT. 0 ) THEN
            DELFAC(I)=MAX(DELFAC(I),ABS(UG(J))*TM1)
            IF ( OG(J) .LT. INFINY )
     F        DELFAC(I)=MIN(DELFAC(I),(OG(J)-UG(J))/(TP1*DEL0))
          ELSE
            DELFAC(I)=MAX(DELFAC(I),ABS(OG(J))*TM1)
            IF ( UG(J) .GT. -INFINY )
     F        DELFAC(I)=MIN(DELFAC(I),(OG(J)-UG(J))/(TP1*DEL0))
          ENDIF
        ENDIF
      ENDDO
      BD0=INFINY
      DO I=1,N
        IF ( UG(I) .GT. ZERO ) BD0=MIN(BD0,OG(I))
        IF ( OG(I) .LT. ZERO ) BD0=MIN(BD0,-UG(I))
      ENDDO
C**************** CHANGE X IF NECESSARY , SUCH THAT BOUNDS NOT VIOLATED
      CORR=.FALSE.
C** EVALUATE GRADIENTS OF SUPERSIMPLE FUNCTIONS ONLY ONCE
C** A FUNCTION IS SAID TO BE SUPERSIMPLE IFF IT IS OF THE FORM A*X(J)+B
      IF ( GUNIT(1,0) .EQ. 1 ) THEN
        GCONST(0)=.TRUE.
        VAL(0)=.TRUE.
        DO I=1,N
          GRADF(I)=ZERO
        ENDDO
        GRADF(GUNIT(2,0))=GUNIT(3,0)*XSC(GUNIT(2,0))
        GFN=ABS(GUNIT(3,0))
      ELSE
        VAL(0)=.FALSE.
        DO I=1,N
          GRADF(I)=ZERO
        ENDDO
      ENDIF
      DO I=1,NH
        IF ( GUNIT(1,I) .EQ. 1 ) THEN
C*** A FIXED VARIABLE. CORRECTED IF NECESSARY
          VAL(I)=.TRUE.
          GCONST(I)=.TRUE.
          GRES(GUNIT(2,I),I)=GUNIT(3,I)*XSC(GUNIT(2,I))
          GRESN(I)=ABS(GUNIT(3,I))*XSC(GUNIT(2,I))
          IF ( GRESN(I) .EQ. ZERO ) THEN
            IF ( .NOT. SILENT ) 
     F         WRITE(MEU,*) GUNIT(2,I), ' FIXED VARIABLE/ZERO GRADIENT'
            CLOSE(MEU)
            CLOSE(PROU)
            STOP
          ENDIF
          CALL ESH(I,XNULL,HXI)
          TERM=-HXI/GUNIT(3,I)
          IF ( TERM .NE. X(GUNIT(2,I)) ) CORR=.TRUE.
          X(GUNIT(2,I))=TERM
        ENDIF
      ENDDO
      IF ( BLOC ) CALL USER_EVAL(X,0)
      DO I=NH+1,NRES
        IF ( GUNIT(1,I) .EQ. 1 ) THEN
          IF ( GUNIT(3,I) .EQ. 0 ) THEN
            IF ( .NOT. SILENT ) WRITE(MEU,*)
     F        GUNIT(2,I),' BOUNDED VARIABLE, ZERO GRADIENT'
            CLOSE(MEU)
            CLOSE(PROU)
            STOP
          ENDIF
          CALL ESG(I-NH,X,GXI)
          GXI=TWO*DELMIN-GXI
          IF ( GXI .GT. ZERO ) THEN
            CORR=.TRUE.
            X(GUNIT(2,I))=X(GUNIT(2,I))+GXI/GUNIT(3,I)
          ENDIF
          GRES(GUNIT(2,I),I)=GUNIT(3,I)*XSC(GUNIT(2,I))
          GRESN(I)=ABS(GUNIT(3,I))*XSC(GUNIT(2,I))
          VAL(I)=.TRUE.
          GCONST(I)=.TRUE.
        ENDIF
      ENDDO
C***
      IF ( CORR .AND. .NOT. SILENT ) CALL O8MSG(13)
C***
C     REMEMBER TO REEVALUATE THE FUNCTIONS IF CORR=.TRUE. 
C     AND BLOC=.TRUE.
      IF ( BLOC ) CALL USER_EVAL(X,1)
C***
      DO I = 1,NRES
        BIND(I)=0
        BIND0(I)=0
        U(I)=ZERO
        U0(I)=ZERO
        CRES(I) = 0
        CGRES(I) = 0
C INITIAL WEIGHTS OF THE PENALTY-TERM
        IF ( COLD ) W(I)=ONE
        SORT(I)=I
      ENDDO      
      CLOW=ONE
      NY=TWO

C********* SCF = WEIGHT FACTOR FOR OBJECTIVE FUNCTION
C********* SCF0 = DAMPING FACTOR FOR TANGENTIAL DIRECTION
      SCF=ONE
      SCF0=ONE
      SIGLA=TWOP11
      BETA=FOUR
C FORMERLY TWO
      ALPHA=TM1
C DELTA =TM2 FORMERLY
      DELTA1=P9
      DELTA=TM3
      THETA=P9
C THETA=0.99 FORMERLY
      ICF=0
      ICGF=0
      IF ( .NOT. SILENT ) THEN
        WRITE(PROU,*) 'DONLP2, V4, 29/07/02, COPYRIGHT P. SPELLUCCI '
        CALL O8TIDA (MEU)
        WRITE(PROU,*) NAME
        WRITE(MEU,*)  'DONLP2, V4, 29/07/02, COPYRIGHT P. SPELLUCCI '
        CALL O8TIDA (PROU)
        WRITE(MEU,*) NAME
      ENDIF
      RETURN
      END
C************************************************************
      SUBROUTINE O8FIN
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INCLUDE 'O8FINT.INC'
      INTEGER I,J,K,IH1,IH2,IH3,IH5,IH6,IH7,IH8,IH9
      DOUBLE PRECISION UMIN,TERM
      INTEGER NSING,CRTOT,CGRTOT,NUPREG,NBFGS1,NRESTA
      CHARACTER*64 MESSAG(18),LINE
      SAVE
C**** TERMINATION REASON + 11 = MESSAGE NUMBER
      DATA MESSAG/
     F'CONSTRAINT EVALUATION RETURNS ERROR WITH CURRENT POINT',
     F'OBJECTIVE EVALUATION RETURNS ERROR WITH CURRENT POINT',
     F'QPSOLVER: WORKING SET SINGULAR IN DUAL EXTENDED QP ',
     F'QPSOLVER: EXTENDED QP-PROBLEM SEEMINGLY INFEASIBLE ',
     F'QPSOLVER: NO DESCENT DIRECTION FROM QP FOR TAU=TAU_MAX',
     F'QPSOLVER: ON EXIT CORRECTION SMALL, INFEASIBLE POINT',
     F'STEPSIZESELECTION: COMPUTED D NOT A DIRECTION OF DESCENT',
     F'MORE THAN MAXIT ITERATION STEPS',
     F'STEPSIZESELECTION: NO ACCEPTABLE STEPSIZE IN [SIGSM,SIGLA]',
     F'STEPSIZESELECTION: DIRECTIONAL DERIV. VERY SMALL, INFEASIBLE',
     F'KT-CONDITIONS SATISFIED, NO FURTHER CORRECTION COMPUTED',
     F'KT-CONDITIONS SATISFIED, COMPUTED CORRECTION SMALL',
     F'STEPSIZESELECTION: X (ALMOST) FEASIBLE, DIR. DERIV. VERY SMALL',
     F'KT-CONDITIONS (RELAXED) SATISFIED, SINGULAR POINT',
     F'VERY SLOW PRIMAL PROGRESS, SINGULAR OR ILLCONDITONED PROBLEM',
     F'VERY SLOW PROGRESS IN X, SINGULAR PROBLEM',
     F'CORRECTION VERY SMALL, ALMOST FEASIBLE BUT SINGULAR POINT',
     F'NUMSM  SMALL DIFFERENCES IN PENALTY FUNCTION,TERMINATE'/
      IF ( SCF .NE. ZERO ) THEN
        DO I=1,NRES
          U(I)=U(I)/SCF
        ENDDO
      ENDIF
C***  IN SOLCHK THE USER MIGHT ADD SOME ADDITIONAL CHECKS AND/OR OUTPUT
      CALL SOLCHK
C***
      IF ( SILENT .AND. .NOT. INTAKT ) RETURN
C
      IF ( INTAKT .AND. .NOT. SILENT ) WRITE(*,*) NAME
      IF (  .NOT. SILENT ) THEN
        IF ( INTAKT  )
     F     WRITE(*,400) N,NH,NG,EPSX,SIGSM,(XST(I),I=1,N)
        WRITE(PROU,400) N,NH,NG,EPSX,SIGSM,(XST(I),I=1,N)
  400   FORMAT(/'     N=',I10, '    NH=',I10,'    NG=',I10/
     1       /'  EPSX=',D10.4,' SIGSM=',D10.4/
     2       /'STARTVALUE'/(5(D15.8,1X)))
      ENDIF
      IF ( INTAKT .AND. .NOT. SILENT )
     1WRITE(*,500)EPSMAC,TOLMAC,DEL0,DELMIN,TAU0,TAU,SMALLD,SMALLW,
     2               RHO,RHO1
      IF ( .NOT. SILENT )
     1 WRITE(PROU,500)EPSMAC,TOLMAC,DEL0,DELMIN,TAU0,TAU,SMALLD,
     2           SMALLW,RHO,RHO1
  500 FORMAT(/'  EPS=',D10.3,'  TOL=',D10.3,' DEL0=',D10.3,' DELM=',
     1   D10.3,' TAU0=',D10.3/'  TAU=',D10.3,'   SD=',D10.3
     2       ,'   SW=',D10.3,'  RHO=',D10.3,' RHO1=',D10.3)
      IF ( .NOT. SILENT ) THEN
        WRITE(PROU,
     F        FMT='('' SCFM='',D10.3,''  C1D='',D10.3,
     F        '' EPDI='',D10.3,/''  NRE='',I10,'' ANAL='',L10
     F        )') SCFMAX,C1D,EPSDIF,NRESET,ANALYT
        IF ( INTAKT )
     F   WRITE(*,
     F        FMT='('' SCFM='',D10.3,''  C1D='',D10.3,
     F        '' EPDI='',D10.3,/''  NRE='',I10,'' ANAL='',L10
     F        )') SCFMAX,C1D,EPSDIF,NRESET,ANALYT
      ENDIF
      IF ( .NOT. SILENT .AND. .NOT. ANALYT ) THEN
        WRITE(PROU,
     F        FMT='('' VBND='',D10.3,'' EFCN='',D10.3,
     F        '' DIFF='',I1)') TAUBND,EPSFCN,DIFFTYPE
        IF ( INTAKT )
     F         WRITE(*,
     F        FMT='(''TAUBND='',D10.3,'' EPSFCN='',D10.3,
     F        '' DIFFTYPE='',I1)') TAUBND,EPSFCN,DIFFTYPE
      ENDIF
      I=0
      J=0
      UMIN=ZERO
      DO K=1,NRES
        I=I+CRES(K)
        J=J+CGRES(K)
        IF ( K .GT. NH ) UMIN=MIN(UMIN,U(K))
      ENDDO
      CRTOT=I
      CGRTOT=J
      NSING=0
      NRESTA=0
      NUPREG=0
      NBFGS1=0
      DO K=1,ITSTEP
        IF ( ACCINF(K,10) .EQ. ONE ) NSING=NSING+1
        IF ( ACCINF(K,27) .EQ. ONE ) NBFGS1=NBFGS1+1
C*** FOR THE PANTOJA MAYNE UPDATE
        IF ( ACCINF(K,29) .EQ. ZERO .AND. ACCINF(K,27) .EQ. ONE )
     F              NUPREG=NUPREG+1
        IF ( ACCINF(K,27) .EQ. -ONE ) NRESTA=NRESTA+1
      ENDDO
      K=INT(OPTITE)+11
      IF ( K .GE. 1 .AND. K .LE. 18 ) THEN
        LINE=MESSAG(K)
      ELSE
        LINE='VARIABLE OPTITE UNDEFINED ON EXIT'
      ENDIF
      IF ( INTAKT .AND. .NOT. SILENT  )
     F  WRITE(*,510) LINE,ICF,ICGF,CRTOT,CGRTOT,SCF,GFN,B2N,UPSI,UMIN,
     F               RUNTIM
      IF ( .NOT. SILENT )
     F   WRITE(PROU,510) LINE,ICF,
     F                   ICGF,CRTOT,CGRTOT,SCF,GFN,B2N,UPSI,UMIN,
     F                   RUNTIM
  510 FORMAT(/1X,'TERMINATION REASON:',/1X,A62,
     F       /1X,'EVALUATIONS OF F                   ',I10
     F       /1X,'EVALUATIONS OF GRAD F              ',I10/1X,
     F           'EVALUATIONS OF CONSTRAINTS         ',I10/1X,
     F           'EVALUATIONS OF GRADS OF CONSTRAINTS',I10/1X,
     F           'FINAL SCALING OF OBJECTIVE         ',D14.7/1X,
     F           'NORM OF GRAD(F)                    ',D14.7/1X,
     F           'LAGRANGIAN VIOLATION               ',D14.7,/1X,
     F           'FEASIBILITY VIOLATION              ',D14.7,/1X,
     F           'DUAL FEASIBILITY VIOLATION         ',D14.7,/1X,
     F           'OPTIMIZER RUNTIME SEC''S            ',E14.7)
      IF ( INTAKT .AND. .NOT. SILENT ) WRITE(*,550) FX
      IF ( .NOT. SILENT ) WRITE(PROU,550)     FX
  550 FORMAT(//1X,'OPTIMAL VALUE OF F =  ',D21.15)
      IF ( INTAKT .AND. .NOT. SILENT ) WRITE(*,560) (X(I),I=1,N)
      IF ( .NOT. SILENT ) WRITE(PROU,560) (X(I),I=1,N)
  560 FORMAT(/1X,'OPTIMAL SOLUTION  X =  '/(1X,3(D21.15,1X)))
      IF ( NRES .NE. 0 .AND. .NOT. SILENT ) THEN
        WRITE(PROU,520) (I,RES(I),GRESN(I),U(I),I=1,NRES)
        IF ( INTAKT )
     F    WRITE(*,520) (I,RES(I),GRESN(I),U(I),I=1,NRES)
      ENDIF
  520 FORMAT(/2X,'MULTIPLIERS ARE RELATIVE TO SCF=1'
     1    /2X,'NR.    CONSTRAINT      NORMGRAD (OR 1)   MULTIPLIER'/
     2       (1X,I4,1X,3(D15.8,2X)))
      IF ( NRES .NE. 0 .AND. .NOT. SILENT  ) THEN
        WRITE(PROU,600)  (CRES(I),CGRES(I),I=1,NRES)
        IF ( INTAKT )
     F    WRITE(*,600)  (CRES(I),CGRES(I),I=1,NRES)
  600 FORMAT(/1X,'EVALUATIONS OF RESTRICTIONS AND THEIR GRADIENTS'/
     1      (5(:,' (',I6,',',I6,')')))
      ENDIF
      IF ( ITSTEP .GT. 1 .AND. OPTITE .EQ. 0 ) ITSTEP=ITSTEP-1
      IF ( .NOT. SILENT )
     F    WRITE(PROU,
     F    FMT='(''LAST ESTIMATE OF CONDITION OF ACTIVE GRADIENTS'',
     F   E11.4)')       ACCINF(ITSTEP,13)
      TERM=ACCINF(ITSTEP,14)
      I=ITSTEP
      DO WHILE ( I .GT. 1 .AND. TERM .EQ. ZERO )
        I=I-1
        TERM=ACCINF(I,14)
      ENDDO
      IF ( .NOT. SILENT ) THEN
        WRITE(PROU,
     F    FMT='(''LAST ESTIMATE OF CONDITION OF APPROX. HESSIAN '',
     F            E11.4)') TERM
        WRITE(PROU,FMT='(''ITERATIVE STEPS TOTAL          '',I5)')
     F     ITSTEP
        WRITE(PROU,FMT='(''# OF RESTARTS                  '',I5)')
     F     NRESTA
        WRITE(PROU,FMT='(''# OF FULL REGULAR UPDATES      '',I5)')
     F     NUPREG
        WRITE(PROU,FMT='(''# OF UPDATES                   '',I5)')
     F     NBFGS1
        WRITE(PROU,FMT='(''# OF FULL REGULARIZED SQP-STEPS'',I5)')
     F     NSING
C
        IF ( INTAKT ) THEN
      WRITE(*,FMT='(''LAST ESTIMATE OF COND.NR. OF ACTIVE GRADIENTS '',
     F   E11.4)')       ACCINF(ITSTEP,13)
      WRITE(*,FMT='(''LAST ESTIMATE OF COND.NR. OF APPROX.  HESSIAN '',
     F            E11.4)') ACCINF(ITSTEP,1 4)
      WRITE(*,FMT='(''ITERATIVE STEPS TOTAL           '',I5)') ITSTEP
      WRITE(*,FMT='(''# OF RESTARTS                   '',I5)') NRESTA
      WRITE(*,FMT='(''# OF FULL REGULAR UPDATES       '',I5)') NUPREG
      WRITE(*,FMT='(''# OF UPDATES                    '',I5)') NBFGS1
      WRITE(*,FMT='(''# OF REGULARIZED FULL SQP-STEPS '',I5)') NSING
C
        ENDIF
      ENDIF
      IF ( OPTITE .LT. ZERO ) TE1=.TRUE.
      IF ( SILENT ) TE1=.FALSE.
      IF ( TE1 ) THEN
        DO I=1 ,ITSTEP
          IH1=ACCINF(I,1)
          IH2=ACCINF(I,9)
          IH3=ACCINF(I,10)
          IH5=ACCINF(I,18)
          IH6=ACCINF(I,19)
          IH7=ACCINF(I,22)
          IH8=ACCINF(I,26)
          IH9=ACCINF(I,27)
          WRITE(PROU,1000) IH1,(ACCINF(I,J),J=2,8),IH2,IH3,
     F    ACCINF(I,11),(ACCINF(I,J),J=13,14),(ACCINF(I,J),J=16,17),
     F           IH5,IH6,ACCINF(I,20),
     F           ACCINF(I,21),IH7,(ACCINF(I,J),J=23,25),IH8,IH9,
     F           ACCINF(I,28),ACCINF(I,29)
          IF ( ACCINF(I,10) .EQ. 1. ) THEN
            WRITE(PROU,2000) (ACCINF(I,J),J=30,32)
          ENDIF
        ENDDO
      ENDIF
C****
C   ACCINF A C C U M U L A T E D   I N F O R M A T I O N
C   ON ITERATION SEQUENCE
C   1: STEP-NR
C   2: F(X-K) CURRENT VALUE OF OBJECTIVE (ZERO IN FEASIBILITY 
C      IMPROVEMENT  PHASE (-1)  )
C   3: SCF    INTERNAL SCALING OF OBJECTIVE (ZERO IN PHASE -1)
C   4: PSI    THE WEIGHTED PENALTY-TERM
C   5: UPSI   THE UNWEIGHTED PENALTY-TERM (L1-NORM OF CONSTRAINT VECTOR)
C   6: DEL_K_1 BOUND FOR CURRENTLY ACTIVE CONSTRAINTS
C   7: B2N0   L2-NORM OF PROJECTED GRADIENT, BASED ON CONSTRAINTS 
C             IN LEVEL DELMIN
C             AND BELOW, MEASURED IN THE NORM INDUCED BY THE 
C             INVERSE HESSIAN 
C             ESTIMATE
C   8: B2N    L2-NORM OF PROJECTED GRADIENT BASED ON DEL_K_1
C   9: NR     NUMBER OF BINDING CONSTRAINTS
C  10: SING   IF 1, THE BINDING CONSTRAINTS DON'T SATISFY THE 
C             REGULARITY CONDITION
C  11: UMIN   INFINITY NORM OF NEGATIVE PART OF MULTIPLIER
C  12: -------------
C  13: COND_R CONDITION NUMBER OF DIAGONAL PART OF QR-DECOMP. 
C      OF NORMALIZED   GRADIENTS OF BINDING CONSTRAINTS
C  14: COND_H CONDITION NUMBER OF DIAGONAL OF CHOLESKY-FACTOR 
C      OF UPDATED FULL HESSIAN
C  15: SCF0   THE RELATIVE DAMPING OF TANGENTIAL COMPONENT 
C             IF UPSI>TAU0/2
C  16: XNORM  L2-NORM OF X
C  17: DNORM  L2-NORM OF D (CORRECTION FROM QP -SUBPROBLEM, UNSCALED)
C  18: PHASE  -1 : INFEASIBILITY IMPROVEMENT PHASE, 
C             0: INITIAL OPTIMIZATION
C             1: BINDING CONSTRAINTS UNCHANGED , 
C             2: D SMALL, MARATOS CORRECTION
C             IN USE
C  19: C_K    NUMBER OF DECREASES OF PENALTY WEIGHTS
C  20: WMAX   INFINITY NORM OF WEIGHTS
C  21: SIG_K  STEPSIZE FROM UNIDIMENSIONAL MINIMIZATION (BACKTRACKING)
C  22: CFINCR NUMBER OF OBJECTIVE EVALUATIONS FOR STEPSIZE-ALGORITHM
C  23: DIRDER DIRECTIONAL DERIVATIVE OF PENALTY-FUNCTION ALONG D 
C             (SCALED)
C  24: DSCAL  SCALING FACTOR FOR D
C  25: COSPHI COS OF ARC BETWEEN D AND D_PREVIOUS. IF LARGER THETA , 
C             SIG LARGER THAN  ONE (UP TO SIGLA) IS TRIED
C  26: VIOLIS(0) NUMBER OF CONSTRAINTS NOT BINDING AT X BUT HIT 
C             DURING LINE SEARCH
C  27:        TYPE OF UPDATE FOR H: 
C             1 NORMAL P&M-BFGS-UPDATE, 
C             0 UPDATE SUPPRESSED,
C             -1 RESTART WITH SCALED UNIT MATRIX , 
C             2 STANDARD BFGS, 
C             3 BFGS MODIFIED (POWELL)
C             
C  28: NY_K/TK   MODIFICATION FACTOR FOR DAMPING THE PROJECTOR 
C                IN BFGS/PANTOJA-MAYNE-TERM RESPECTIVELY
C  29: 1-MY_K/XSIK MODIFICATION FACTOR FOR DAMPING 
C                THE QUASI-NEWTON-RELATION IN BFGS
C                FOR UNMODIFIED BFGS NY_K SHOULD BE LARGER THAN 
C                UPDMY0 (NEAR ONE)
C                AND 1-MY_K EQUAL ONE./PANTOJA-MAYNE TERM RESPECTIVELY
C  30: QPTERM 0, IF SING=-1, TERMINATION INDICATOR OF 
C                QP-SOLVER OTHERWISE
C             1: SUCCESSFUL, 
C             -1: TAU BECOMES LARGER THAN TAUQP WITHOUT SLACK-
C                 VARIABLES BECOMING SUFFICIENTLY SMALL .
C             -3: WORKING SET OF QP-SOLVER BECOMES LINEARLY DEPENDENT
C             -2: INFEASIBLE QP-PROBLEM (THEORETICALLY IMPOSSIBLE)
C  31: TAUQP: WEIGHT OF SLACK-VARIABLES IN QP-SOLVER
C  32: INFEAS L1-NORM OF SLACK-VARIABLES IN QP-SOLVER
C
 1000 FORMAT(I4,'  FX=',E14.7,' SCF=',E14.7,' PSI=',
     F        E14.7,   ' UPS=',E14.7,/4X,
     F        ' DEL=',E14.7,' B20=',E14.7,' B2N=',E14.7,'  NR=',
     F        I5,9X,/4X    ,'  SI=',I4,10X,
     F        '  U-=',E14.7,
     F        ' C-R=',E14.7,' C-D=',E14.7,/4X,
     F        '  XN=',E14.7,'  DN=',E14.7,' PHA=',I4,10X,
     F        '  CL=',I14,/4X,' SKM=',E14.7,
     F        ' SIG=',E14.7,' CF+=',I5,9X,' DIR=',E14.7,/4X,
     F        ' DSC=',E14.7,' COS=',E14.7,' VIO=',I5,  /4X,
     F        ' UPD=',I5,9X,'  TK=',E14.7,' XSI=',E14.7)
 2000 FORMAT(4X,' QPT=',E14.1,' TQP=',E14.7,' SLA=',E14.7)
      IF ( .NOT. SILENT ) CLOSE(PROU)
      IF ( .NOT. SILENT ) CLOSE(MEU)
      RETURN
      END
C***********************************************************************
      SUBROUTINE O8INFO(ICASE)
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER ICASE,I,J,L,K
      DOUBLE PRECISION Y,PHIH
      CHARACTER*40 HEAD
      SAVE
      IF(.NOT.TE2)      RETURN
      GOTO (1000,2000,3000,4000,5000,6000,7000,8000,9000,10000,
     F      11000,12000,13000,14000,15000,16000,17000,18000,
     F      19000,20000,21000,22000),ICASE
 1000 CONTINUE
      WRITE(PROU,1100) ITSTEP,SCF,PSIST,PSI,UPSI,FXST,FX,
     F             (X(I),I=1,N)
      WRITE(PROU,*) ' VALID PERMUTATION OF X'
      WRITE(PROU,1200) (PERM(I),I=1,N)
 1200 FORMAT((/20(I3,1X)))
        IF ( PHASE .GE. 0 .AND. TE3 ) THEN
          HEAD='QUASI-NEWTON-MATRIX FULL UPDATE'
          CALL O8MDRU(A,NX,NX,N,N,HEAD,PROU,.FALSE.)
        ENDIF
 1100 FORMAT(///80(1H=),/10X,I4,'-TH ITERATION STEP',/
     F       '   SCF=',D12.5,' PSIST=',D12.5,
     F       '   PSI=',D12.5,'  UPSI=',D12.5,
     F      /'  FXST=',D12.5,'    FX=',
     F       D12.5,/'  X=',/6(1X,D12.5))
      IF ( INTAKT ) THEN
        WRITE(*,1100) ITSTEP,SCF,PSIST,PSI,UPSI,FXST,FX,
     F             (X(I),I=1,N)
        WRITE(*,*) ' VALID PERMUTATION OF X'
        WRITE(*,1200) (PERM(I),I=1,N)
      ENDIF
      RETURN
 2000 CONTINUE
      WRITE(PROU,2100) DEL,B2N0,B2N,GFN
      IF(ALIST(0).NE. 0)
     F WRITE(PROU,2200) (ALIST(I),RES(ALIST(I)),GRESN(ALIST(I)),
     F                I=1,ALIST(0))
      IF(ALIST(0) .NE. 0 .AND. .NOT. SINGUL )
     F WRITE(PROU,2400)(DIAG(I),I=1,ALIST(0))
      IF(ALIST(0).NE. 0 .AND. TE3 )  THEN
        DO I=1,ALIST(0)
          L=ALIST(I)
          WRITE(PROU,2300) L, (GRES(J,L),J=1,N)
        ENDDO
      ENDIF
      IF ( INTAKT ) THEN
        WRITE(*,2100) DEL,B2N0,B2N,GFN
        IF(ALIST(0).NE. 0)
     F    WRITE(*,2200) (ALIST(I),RES(ALIST(I)),GRESN(ALIST(I)),
     F                I=1,ALIST(0))
        IF(ALIST(0) .NE. 0 .AND. .NOT. SINGUL )
     F      WRITE(*,2400)(DIAG(I),I=1,ALIST(0))
        IF(ALIST(0).NE. 0 .AND. TE3 )  THEN
          DO I=1,ALIST(0)
            L=ALIST(I)
            WRITE(*,2300) L, (GRES(J,L),J=1,N)
          ENDDO
        ENDIF
      ENDIF
      RETURN
 2100 FORMAT(//'  DEL=',D13.6,'  B2N0=',D13.6,'   B2N=',D13.6,
     F       '   GFN=',D13.6)
 2200 FORMAT(//1X,'VALUES OF RESTRICTIONS',
     F       (/1X,2(:,'(',I4,2X,D12.5,2X,D12.5,')',2X)))
 2300 FORMAT(//1X,'GRADIENT OF RESTRICTION NR.',I4,/
     F       (1X,5(D12.5,2X)))
 2400 FORMAT(//1X,'  DIAG(R)=',/6(1X,D12.5))
 3000 CONTINUE
      IF( .NOT. (NR .EQ. 0 .OR. PHASE .EQ. -1) )
     F  WRITE(PROU,3100)   (ALIST(K),U(ALIST(K)),K=1,NR)
      IF( .NOT. (NR .EQ. 0 .OR. PHASE .EQ. -1)  .AND. INTAKT )
     F  WRITE(*,3100)   (ALIST(K),U(ALIST(K)),K=1,NR)
 3100 FORMAT(/'  MULTIPLIERS: FIRST ESTIMATE'/,'  U =',
     F        /4(1X,I4,1X,D12.5))
      RETURN
 4000 CONTINUE
      IF( .NOT. (NR .EQ. 0 .OR. PHASE .EQ. -1) )
     F  WRITE(PROU,4100)   (ALIST(K),U(ALIST(K)),K=1,NR)
      IF( .NOT. (NR .EQ. 0 .OR. PHASE .EQ. -1)  .AND. INTAKT )
     F  WRITE(*,4100)   (ALIST(K),U(ALIST(K)),K=1,NR)
 4100 FORMAT(/'  MULTIPLIERS: SECOND ESTIMATE'/,
     F  '  U =',/4(1X,I4,1X,D12.5))
      RETURN
 5000 CONTINUE
      IF ( INTAKT )
     F  WRITE(*,*) '  CONDITION NUMBER OF R     ',ACCINF(ITSTEP,13)
      WRITE(PROU,*) '  CONDITION NUMBER OF R     ',ACCINF(ITSTEP,13)
      IF ( PHASE .EQ. -1 ) THEN
        RETURN
      ELSE
        WRITE(PROU,*)
     F    '  CONDITION NUMBER OF A     ',ACCINF(ITSTEP,14)
        IF ( INTAKT ) THEN
          WRITE(*,*)
     F    '  CONDITION NUMBER OF A     ',ACCINF(ITSTEP,14)
        ENDIF
        RETURN
      ENDIF
 6000 CONTINUE
      RETURN
 7000 CONTINUE
      WRITE(PROU,7100) PHASE,SCF0,(D(I),I=1,N)
      IF(PHASE .EQ. 2)    WRITE(PROU,7200)  (DD(I),I=1,N)
      IF ( INTAKT ) THEN
        WRITE(*,7100) PHASE,SCF0,(D(I),I=1,N)
        IF(PHASE .EQ. 2)    WRITE(*,7200)  (DD(I),I=1,N)
      ENDIF
      RETURN
 7100 FORMAT(//1X,' PHASE=',I3,'  SCF0=',D12.5/1X,' D ='/6(1X,D12.5))
 7200 FORMAT(//1X,' DD='/6(1X,D12.5))
 8000 CONTINUE
      Y=TAU0*P5
      PHIH=FX*SCF+PSI
      IF ( INTAKT )WRITE(*,8100)PHIH,DIRDER,PSI,Y,FX,DSCAL,SCF,UPSI
      WRITE(PROU,8100) PHIH,DIRDER,PSI,Y,FX,DSCAL,SCF,UPSI
      RETURN
 8100 FORMAT(//1X,'START UNIMIN',//'    PHI=',D12.5,'   DPHI=',D12.5,
     F '    PSI=',D12.5,' TAU0/2=',D12.5,
     F       /'     FX=',D12.5,'  DSCAL=',
     F       D12.5,'    SCF=',D12.5,'   UPSI=',D12.5)
 9000 CONTINUE
      WRITE(PROU,9100)   SIG,FX1,PSI1,UPSI1
      IF ( INTAKT ) WRITE(*,9100)   SIG,FX1,PSI1,UPSI1
 9100 FORMAT('    SIG=',D12.5,'     FX=',D12.5,
     F       '    PSI=',D12.5,'   UPSI=',D12.5 )
      RETURN
10000 CONTINUE
      WRITE(PROU,10100) SIG,CFINCR,(VIOLIS(I),I=1,VIOLIS(0))
      IF ( VIOLIS(0) .EQ. 0 ) WRITE(PROU,*) 'NONE'
      IF ( INTAKT ) THEN
        WRITE(*,10100) SIG,CFINCR,(VIOLIS(I),I=1,VIOLIS(0))
        IF ( VIOLIS(0) .EQ. 0 ) WRITE(*,*) 'NONE'
      ENDIF
      RETURN
10100 FORMAT(//1X,'END UNIMIN',//1X,'SIG=',D12.5,
     F       '  NUM. F-EVALUATIONS',I2,
     F       /1X,'LIST OF INACTIVE HIT CONSTRAINTS',/(13(I4,2X)))
11000 CONTINUE
      IF ( INTAKT )
     F WRITE(*,*) 'ADDITIONAL INCREASE OF ETA DUE TO LARGE CLOW'
      WRITE(PROU,*) 'ADDITIONAL INCREASE OF ETA DUE TO LARGE CLOW'
      RETURN
12000 CONTINUE
      WRITE(PROU,12100)   SCF,CLOW,ETA
      IF(NRES .NE. 0)    WRITE(PROU,12200)   (W(I),I=1,NRES)
      IF ( INTAKT ) THEN
        WRITE(*,12100)   SCF,CLOW,ETA
        IF(NRES .NE. 0)  WRITE(*,12200) (W(I),I=1,NRES)
      ENDIF
      RETURN
12100 FORMAT(//2X,'CURRENT SCALING,  SCF = ',D12.5,' CLOW = ',I12,
     F   ' ETA = ',D12.5)
12200 FORMAT(//2X,'SCALRES='/6(1X,D12.5))
13000 CONTINUE
      IF ( ACCINF(ITSTEP,27) .EQ. ZERO ) THEN
        IF ( INTAKT ) WRITE(*,*) 'UPDATE SUPPRESSED'
        WRITE(PROU,*) 'UPDATE SUPPRESSED'
      ELSEIF ( ACCINF(ITSTEP,27) .EQ. -ONE ) THEN
        WRITE(PROU,*) 'RESTART WITH SCALED UNIT MATRIX'
        IF ( INTAKT )
     F    WRITE(*,*) 'RESTART WITH SCALED UNIT MATRIX'
      ELSE
        WRITE(PROU,*) 'BFGS-UPDATE'
        WRITE(PROU,FMT='('' TYPE ='',D15.7)') ACCINF(ITSTEP,27)
        WRITE(PROU,FMT='(''  NY  ='',D15.7)') ACCINF(ITSTEP,28)
        WRITE(PROU,FMT='('' THET ='',D15.7)') ACCINF(ITSTEP,29)
        IF ( INTAKT ) THEN
          WRITE(*,*) 'BFGS-UPDATE'
          WRITE(*,FMT='('' TYPE ='',D15.7)') ACCINF(ITSTEP,27)
          WRITE(*,FMT='(''  NY  ='',D15.7)') ACCINF(ITSTEP,28)
          WRITE(*,FMT='('' THET ='',D15.7)') ACCINF(ITSTEP,29)
        ENDIF
      ENDIF
      RETURN
14000 CONTINUE
      IF ( ACCINF(ITSTEP,27) .EQ. ZERO ) THEN
        IF ( INTAKT ) WRITE(*,*) 'UPDATE SUPPRESSED'
        WRITE(PROU,*) 'UPDATE SUPPRESSED'
      ELSEIF ( ACCINF(ITSTEP,27) .EQ. ONE ) THEN
        WRITE(PROU,*) 'BFGS-UPDATE AS IN PANTOJA AND MAYNE'
        WRITE(PROU,FMT='(''  TK  ='',D15.7)') ACCINF(ITSTEP,28)
        WRITE(PROU,FMT='('' XSIK ='',D15.7)') ACCINF(ITSTEP,29)
        IF ( INTAKT ) THEN
          WRITE(*,*) 'BFGS-UPDATE'
          WRITE(*,FMT='(''  TK  ='',D15.7)') ACCINF(ITSTEP,28)
          WRITE(*,FMT='('' XSIK ='',D15.7)') ACCINF(ITSTEP,29)
        ENDIF
      ELSE
        IF ( INTAKT ) WRITE(*,*) 'RESTART WITH SCALED UNIT MATRIX'
        WRITE(PROU,*) 'RESTART WITH SCALED UNIT MATRIX'
      ENDIF
      RETURN
15000 CONTINUE
      IF ( INTAKT ) WRITE(*,15100)
      WRITE(PROU,15100)
15100 FORMAT(///' SINGULAR CASE : FULL REGULARIZED SQP')
      IF ( INTAKT ) WRITE(*,*) '  DEL =',DEL
      WRITE(PROU,*) '  DEL =',DEL
      IF ( INTAKT )
     F  WRITE(*,15200) (ALIST(I),RES(ALIST(I)),GRESN(ALIST(I)),
     F                I=1,ALIST(0))
      WRITE(PROU,15200)  (ALIST(I),RES(ALIST(I)),GRESN(ALIST(I)),
     F                I=1,ALIST(0))
15200 FORMAT(//2X,'VALUES OF RESTRICTIONS',
     F       (/2X,2(:,'(',I4,2X,D12.5,2X,D12.5,')',2X)))
      IF ( INTAKT ) WRITE(*,12200) (W(I),I=1,NRES)
      WRITE(PROU,12200) (W(I),I=1,NRES)
      IF (  TE3 ) THEN
        HEAD='GRADIENTS OF CONSTRAINTS'
        CALL O8MDRU(GRES,NX,NRESM,N,NRES,HEAD,PROU,.FALSE.)
      ENDIF
      RETURN
16000 CONTINUE
      WRITE(PROU,*) 'EXIT FROM FULL SQP'
      WRITE(PROU,16100) (ACCINF(ITSTEP,I),I=30,32)
16100 FORMAT('            TERMINATION REASON ',E8.1,/
     F       '          FINAL VALUE OF TAUQP ',E11.4,/
     F       '      SUM NORM OF SLACK VECTOR ',E11.4)
      WRITE(PROU,7100) PHASE,SCF0,(D(I),I=1,N)
      IF ( NRES .NE. 0 ) WRITE(PROU,3100) (K,U(K),K=1,NRES)
      IF ( INTAKT ) THEN
        WRITE(*,*) 'EXIT FROM FULL SQP'
        WRITE(*,16100) (ACCINF(ITSTEP,I),I=30,32)
        WRITE(*,7100) PHASE,SCF0,(D(I),I=1,N)
        IF ( NRES .NE. 0 ) WRITE(*,3100) (K,U(K),K=1,NRES)
      ENDIF
      RETURN
17000 CONTINUE
      WRITE(PROU,*) 'SMALL DIRECTIONAL DERIVATIVE ',DIRDER,': FINISH'
      IF ( INTAKT )
     F  WRITE(*,*) 'SMALL DIRECTIONAL DERIVATIVE ',DIRDER,': FINISH'
      RETURN
18000 CONTINUE
      IF ( INTAKT )
     F WRITE(*,*) 'SMALL CORRECTION FROM FULL REGULARIZED SQP,FINISH'
      WRITE(PROU,*) 'SMALL CORRECTION FROM FULL REGULARIZED SQP,FINISH'
      RETURN
19000 CONTINUE
      WRITE(PROU,*) 'QP-SOLVER TERMINATED UNSUCCESSFULLY'
      IF ( INTAKT ) WRITE(*,*) 'QP-SOLVER TERMINATED UNSUCCESSFULLY'
      RETURN
20000 CONTINUE
      IF ( INTAKT ) WRITE(*,*) 'RESTART WITH SCALED UNIT MATRIX'
      WRITE(PROU,*) 'RESTART WITH SCALED UNIT MATRIX'
      RETURN
21000 CONTINUE
      RETURN
22000 CONTINUE
      RETURN
      END
C*******************************************************************
      SUBROUTINE O8SCE
C  COMPUTATION OF NEW SCALING FACTORS FOR L1-PENALTY-FUNCTION
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER I
      DOUBLE PRECISION TERM,S1,S2,DIFF0
      LOGICAL WLOW
      SAVE
      WLOW=.FALSE.
      DO I=1,NRES
C***** W1 TENTATIVE NEW WEIGHTS
        TERM=NY*ABS(U(I))+TAU
        IF ( TERM .GT. W(I) ) THEN
          W1(I)=TERM+TAU
        ELSE
          W1(I)=W(I)
          IF ( TERM .LT. W(I)*P5 .AND.
     F         BIND(I) .EQ. 1  ) W1(I)=(TERM+W(I))*P5
        ENDIF
        IF ( W1(I) .LT. W(I)) WLOW=.TRUE.
      ENDDO
C  WLOW EQUALS TRUE IF ONE TENTATIVE WEIGHT AT LEAST HAS BEEN DECREASED
      S1=ZERO
      S2=ZERO
      DO I=1,NRES
        IF ( I .LE. NH ) THEN
          S1=S1+W1(I)*ABS(RESST(I))
          S2=S2+W1(I)*ABS(RES(I))
        ELSE
          S1=S1-MIN(ZERO,RESST(I))*W1(I)
          S2=S2-MIN(ZERO,RES(I))*W1(I)
        ENDIF
      ENDDO
      DIFF0=(FXST-FX)*SCF+(S1-S2)
      IF ( WLOW .AND. DIFF0 .GE. ETA*CLOW 
     F    .AND. ITSTEP-LASTDW .GT. MAX(5,MIN(20,N/10)) ) THEN
C***** ACCEPT NEW (DIMINISHED ) WEIGHTS
        IF ( CLOW .GT. ITSTEP/10 ) THEN
          ETA=ONEP3*ETA
          IF ( .NOT. SILENT ) CALL O8INFO(11)
        ENDIF
        LASTCH=ITSTEP
        LASTDW=ITSTEP
        LEVEL=DIFF0/ITERMA
        PSIST=S1
        PSI=S2
        DO I=1,NRES
          W(I)=W1(I)
        ENDDO
        CLOW=CLOW+ONE
      ELSE
C***** INCREASE INDIVIDUAL WEIGHTS IF NECESSARY. LET WEIGTHS UNCHANGED
C***** OTHERWISE
        S1=ZERO
        S2=ZERO
        DO I=1,NRES
          IF ( W1(I) .GT. W(I) ) THEN
            LASTUP=ITSTEP
            LASTCH=ITSTEP
          ENDIF
          W(I)=MAX(W(I),W1(I))
          IF ( I.LE. NH ) THEN
            S1=S1+W(I)*ABS(RESST(I))
            S2=S2+W(I)*ABS(RES(I))
          ELSE
            S1=S1-W(I)*MIN(ZERO,RESST(I))
            S2=S2-W(I)*MIN(ZERO,RES(I))
          ENDIF
        ENDDO
        PSIST=S1
        PSI=S2
      ENDIF   
      TERM=ZERO
      IF ( NRES .GE. 1 ) TERM=W(1)
      DO I=2,NRES
        TERM=MAX(TERM,W(I))
      ENDDO
      ACCINF(ITSTEP,20)=TERM
C****** MAXIMUM OF WEIGHTS
      ACCINF(ITSTEP,19)=CLOW
      IF ( .NOT. SILENT ) CALL O8INFO(12)
      RETURN
      END
C**********************************************************************
      SUBROUTINE O8BFGS
C COMPUTATION OF THE PANTOJA-MAYNE BFGS-UPDATE OF HESSIAN
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER I,J
      DOUBLE PRECISION DG(NX),ADX(NX),DEN1,DEN2,DEN3,
     *   TH,TK,XSIK,LTDX(NX),GTDX(NRESM),UPDX(NX),UPDZ(NX),
     *   TERM,TERM1,ANORM,ACOND,NDX,NGTDX,DEN21
      DOUBLE PRECISION O8SC1,O8SC2,O8SC3,O8VECN
      EXTERNAL O8SC1,O8SC2,O8SC3,O8VECN
      LOGICAL FAIL
      SAVE
      DO   I=1,N
C****** MULTIPLY DX= (S IN THE USUAL NOTATION) BY CHOLESKY-FACTOR
C       STORED IN THE UPPER HALF OF A
       LTDX(I)=O8SC2(I,N,I,A,NX,DIFX)
       DG(I)=GPHI1(I)-GPHI0(I)
      ENDDO
      IF ( O8VECN(1,N,DG) .EQ. ZERO ) THEN
C****** SUPPRESS UPDATE
        ACCINF(ITSTEP,27)=ZERO
        ACCINF(ITSTEP,28)=ZERO
        ACCINF(ITSTEP,29)=ZERO
        IF ( .NOT. SILENT ) CALL O8MSG(21)
        RETURN
      ENDIF
      DO I=1,N
        ADX(I)=O8SC3(1,I,I,A,NX,LTDX)
      ENDDO
C*** ADX = A * ( X-X0), X-X0=DIFX
      DO I=1,ALIST(0)
        GTDX(I)=O8SC3(1,N,ALIST(I),GRES,NX,DIFX)
        GTDX(I)=GTDX(I)/GRESN(ALIST(I))
      ENDDO
C*** GTDX= GRAD(RES)(TRANSP)*(X-X0)
      NDX=O8VECN(1,N,DIFX)
      TK=MIN(P5,DNORM**2)
      ANORM=ZERO
      TERM1=ABS(A(1,1))
      ANORM=ZERO
      DO I=1,N
        DO J=I,N
          ANORM=ANORM+A(I,J)**2
        ENDDO
        TERM1=MIN(TERM1,ABS(A(I,I)))
      ENDDO
      IF ( TERM1 .NE. ZERO ) THEN
        ACOND=ANORM/TERM1**2
      ELSE
        ACOND=EPSMAC/TOLMAC
      ENDIF
      DEN1=O8VECN(1,N,LTDX)**2
      DEN2=O8SC1(1,N,DG,DIFX)
      IF ( DEN1 .LE. RHO1*ANORM*NDX**2 .OR. ACOND .GE. ONE/RHO1 ) THEN
C*** TAKE A RESTART STEP
        CALL O8INIM
        RETURN
      ENDIF
      IF ( NRES .EQ. 0 ) THEN
C IN THE UNCONSTRAINED CASE WE TAKE THE POWELL UPDATE
        TH=ONE
        IF ( DEN2 .LT. P2*DEN1 ) THEN
          TH=P8*DEN1/(DEN1-DEN2)
          DO I=1,N
            DG(I)=TH*DG(I)+(ONE-TH)*ADX(I)
          ENDDO
          DEN2=O8SC1(1,N,DG,DIFX)
        ENDIF
        TERM=ONE/SQRT(DEN2)
        DO I=1,N
          DG(I)=DG(I)*TERM
          UPDZ(I)=DG(I)
        ENDDO
        TERM=ONE/SQRT(DEN1)
        DO I=1,N
          UPDX(I)=ADX(I)*TERM
        ENDDO
        ACCINF(ITSTEP,28)=DEN2/DEN1
        ACCINF(ITSTEP,29)=TH
        ACCINF(ITSTEP,27)=TWO
        IF ( TH .NE. ONE ) ACCINF(ITSTEP,27)=THREE
      ELSE
        NGTDX=O8VECN(1,ALIST(0),GTDX)
        TERM=ONE/SQRT(DEN1)
        DO I=1,N
          UPDX(I)=ADX(I)*TERM
        ENDDO
        IF ( DEN2 .GE. RHO1*O8SC1(1,N,DG,DG)
     F      .AND. O8VECN(1,N,DG) .GE. SQRT(EPSMAC)*NDX ) THEN
          XSIK=ZERO
          DO I=1,N
            UPDZ(I)=DG(I)
          ENDDO
          DEN21=DEN2
        ELSE
C*** TRY PANTOJA-MAYNE MODIFICATION
          DEN3=TK*NDX**2+NGTDX**2
          IF ( DEN2 .GE. RHO1*O8SC1(1,N,DG,DG) ) THEN
            XSIK=ONE
          ELSE
            XSIK=ONE+(TK*NDX**2+ABS(DEN2) )/DEN3
          ENDIF
          DO I=1,N
            TERM=ZERO
            DO J=1,ALIST(0)
              TERM1=GRES(I,ALIST(J))*GTDX(J)
              TERM1=TERM1/GRESN(ALIST(J))
              TERM=TERM+TERM1
            ENDDO
            UPDZ(I)=DG(I)+XSIK*(TK*DIFX(I)+TERM)
          ENDDO
          DEN21=O8SC1(1,N,UPDZ,DIFX)
        ENDIF
        TERM=ONE/SQRT(DEN21)
        DO I=1,N
          UPDZ(I)=UPDZ(I)*TERM
        ENDDO
        TH=ONE
        IF ( DEN2 .LT. P2*DEN1 ) THEN
          TH=P8*DEN1/(DEN1-DEN2)
          DO I=1,N
            DG(I)=TH*DG(I)+(ONE-TH)*ADX(I)
          ENDDO
          DEN2=O8SC1(1,N,DG,DIFX)
        ENDIF
        TERM=ONE/SQRT(DEN2)
        DO I=1,N
          DG(I)=DG(I)*TERM
        ENDDO
        IF ( O8VECN(1,N,DG) .LE. TM3*O8VECN(1,N,UPDZ) ) THEN
C***** THE POWELL UPDATE PRODUCES A SMALLER GROWTH
          DO I=1,N
            UPDZ(I)=DG(I)
          ENDDO
          ACCINF(ITSTEP,28)=DEN2/DEN1
          ACCINF(ITSTEP,29)=TH
          ACCINF(ITSTEP,27)=TWO
          IF ( TH .NE. ONE ) ACCINF(ITSTEP,27)=THREE
        ELSE
C*** NO UPDATE IF STRONGLY IRREGULAR
          ACCINF(ITSTEP,27)=ONE
          ACCINF(ITSTEP,28)=TK
          ACCINF(ITSTEP,29)=XSIK
        ENDIF
      ENDIF
      CALL O8UPD(A,UPDZ,UPDX,N,FAIL)
C****** CHECK ILLCONDITIONING AFTER UPDATING
      TERM=ABS(A(1,1))
      TERM1=TERM
      I=1
C***IN ORDER TO OVERCOME A CURIOUS ERROR IN HP'S 
C*** F77COMPILER THIS KIND OF LOOP
      DO WHILE ( I .LT. N ) 
        I=I+1
        TERM=MAX(TERM,ABS(A(I,I)))
        TERM1=MIN(TERM1,ABS(A(I,I)))
      ENDDO
      IF ( FAIL  .OR. TERM1**2 .LE. RHO1*TERM**2 ) THEN
C****** RESET
        CALL O8INIM
      ENDIF
      RETURN
      END
C*******************************************************************
      SUBROUTINE O8SHMS
C WRITE SHORT INFORMATION ON STANDARD OUT
      INCLUDE 'O8COMM.INC'
      DOUBLE PRECISION UMIN
      SAVE
      IF ( TE0 .AND. .NOT. SILENT ) THEN
        UMIN=ACCINF(ITSTEP,11)
        WRITE(*,FMT='(I5,'' FX='',D15.7,'' UPSI='',D9.2,
     F  '' B2N='',D9.2,'' UMI='',D9.2,'' NR'',I4,'' SI'',I2)')
     F   ITSTEP,FX,UPSI,B2N,UMIN,NR,INT(ACCINF(ITSTEP,10))
        WRITE(PROU,FMT='(I5,'' FX='',D15.7,'' UPSI='',D9.2,
     F  '' B2N='',D9.2,'' UMI='',D9.2,'' NR'',I4,'' SI'',I2)')
     F   ITSTEP,FX,UPSI,B2N,UMIN,NR,INT(ACCINF(ITSTEP,10))

      ENDIF
      RETURN
      END
C*************************************************************
      SUBROUTINE O8MSG(NUM)
C WRITE MESSAGES ON "SPECIAL EVENTS"
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8QPDU.INC'
      INTEGER MDUALM,I
      PARAMETER (MDUALM=2*NRESM)
      INTEGER IPTR,IQTR,AITR(MDUALM)
      DOUBLE PRECISION SSTR,RIITR
      COMMON/O8QPTR/SSTR,RIITR,IPTR,IQTR,AITR
      INTEGER NUM
      SAVE
      IF ( NUM .LE. 0 .OR. NUM .GT. 25 ) RETURN
      GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,
     F    18,19,20,21,22,23,24,25) NUM
    1 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'RANKDEFICIENCY OF GRAD''S OF ACTIVE CONSTR.!'
      WRITE(MEU,*) 'ON THE BASIS OF DELMIN!'
      RETURN
    2 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'RESCALING OF OBJECTIVE FUNCTION SCF=',SCF
      RETURN
    3 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'RANKDEFICIENCY OF GRAD''S OF ACTIVE CONSTR.!'
      WRITE(MEU,*) ' DEL=',DEL
      RETURN
    4 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'RANKDEFICIENCY OF GRAD''S OF ACTIVE CONSTR.!'
      WRITE(MEU,*) ' DEL=',DEL
      RETURN
    5 CONTINUE
      WRITE(MEU,*) 'QPTERM<0: NO DIR. OF. DESC., TAUQP MAX'
      RETURN
    6 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'SECOND ORDER CORRECTION SUPPRESSED! '
      RETURN
    7 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'RETRY NEXT STEP WITH A=ID '
      RETURN
    8 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'SOME CONSTRAINT HAS GRADIENT EQUAL TO ZERO '
      WRITE(MEU,*) 'RESULTING D MAY BE NO DIRECTION OF DESCENT'
      RETURN
    9 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'TRY REGULARIZED SQP WITH INCREASED WEIGHTS'
      WRITE(MEU,*) 'SINCE DNORM SMALL OR INFEASIBILITY LARGE'
      RETURN
   10 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'QPSOLVER DID NOT COMPLETE, TRY D ANYWAY, MAY FAIL'
      RETURN
   11 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'DIRECT. DERIV. POSITIVE! MAY BE DUE TO INACCURATE'
      WRITE(MEU,*) 'GRADIENTS OR EXTREME ILLCONDITIONING'
      WRITE(MEU,*) 'DIRDER= ',DIRDER
      RETURN
   12 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'CALL OF MATDRU SUPPRESSED, MAT TOO LARGE'
      RETURN
   13 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'STARTVALUE CORRECTED IN ORDER TO FIT BOUNDS'
      RETURN
   14 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'TRY FULL SQP DUE TO SLOW PROGRESS IN X '
      RETURN
   15 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'TRY FULL SQP DUE TO SMALL STEPSIZES WHILE'
      WRITE(MEU,*) 'INFEASIBILITY LARGE'
      RETURN
   16 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'ON EXIT FROM O8QPDU DIR. DERIV. POSITIVE!'
      WRITE(MEU,*) 'TRY INCREASED TAUQP'
      RETURN
   17 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'TRY REGULARIZED SQP WITH INCREASED WEIGHTS'
      WRITE(MEU,*) 'NO DECREASE OF WEIGHTS POSSIBLE'
      WRITE(MEU,*) 'AND INCOMPATIBILITY LARGE'
      RETURN
   18 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'TRY REGULARIZED SQP WITH INCREASED WEIGHTS'
      WRITE(MEU,*) 'SINCE NO DIRECTION OF DESCENT HAS BEEN OBTAINED'
      RETURN
   19 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'DEGENERACY IN DUAL QP'
      WRITE(MEU,*) 'RESTR. ',IPTR,' TO BE ADDED'
      WRITE(MEU,*) 'NEW RII=',RIITR
      WRITE(MEU,*) 'LENGTH OF CURRENT WORKING SET=',IQTR
      WRITE(MEU,*) 'WORKING SET'
      WRITE(MEU,FMT='(15(I4,1X))') (AITR(I),I=1,IQTR)
      WRITE(MEU,*) 'PRIMAL FEASIBILITY VIOLATION IS=',SSTR
      RETURN
   20 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'DUAL QP SEEMINGLY INFEASIBLE '
      WRITE(MEU,*) 'THEORETICALLY IMPOSSIBLE'
      RETURN
   21 CONTINUE
      WRITE(MEU,*) 'STEP=',ITSTEP
      WRITE(MEU,*) 'NO UPDATE SINCE DG=0'
      RETURN
   22 CONTINUE
      WRITE(MEU,*) 'STEP',ITSTEP
      WRITE(MEU,*) 'FUNCTION EVALUATION RETURNS ERR=.TRUE.'
      RETURN
   23 CONTINUE
      WRITE(MEU,*) 'STEP',ITSTEP
      WRITE(MEU,*) 'CONTRAINT EVALUATION RETURNS ERR=.TRUE.'
      RETURN
   24 CONTINUE
      WRITE(MEU,*) 'STEP',ITSTEP
      WRITE(MEU,*) 'CURRENT POINT CANNOT BE CHANGED IN CURRENT'
      WRITE(MEU,*) 'DIRECTION DUE TO ERROR-MESSAGE FROM FUNCTION'
      WRITE(MEU,*) 'EVALUATION'
      RETURN
   25 CONTINUE
      WRITE(MEU,*) 'STEP',ITSTEP
      WRITE(MEU,*) 'REDUCE STEPSIZE DUE TO ERROR-INDICATOR SET'
      WRITE(MEU,*) 'BY USERS FUNCTION EVALUATION'
      RETURN
      END
C********************************************************************
C     EQUALITY CONSTRAINED RECURSIVE QUADRATIC PROGRAMMING WITH
C     MULTIPLE INACTIVATION AND SUPERLINEARLY CONVERGENT PROJECTED
C     BFGS-UPDATE (VERSION 12/93 SPELLUCCI )
C********************************************************************
      SUBROUTINE O8OPTI
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INCLUDE 'O8QPDU.INC'
      INCLUDE 'O8FINT.INC'
C*******  LOCAL VARIABLES
      INTEGER L,L0,I,J,K,CSSSIG,CSIRUP,CSREG,CSCHGX
      INTEGER CSMDPH
      DOUBLE PRECISION DELSIG,DELX,SUM,TERM
      DOUBLE PRECISION UMIN,TERM1,SCFH,UNORM
      DOUBLE PRECISION DEL1
      DOUBLE PRECISION QTX(NX)
      DOUBLE PRECISION YY(NX),YX(NX),TRVEC(NX)
      INTEGER IUMIN,RANK0,NR0,CSDIFX,CLWOLD
      INTEGER DELIST(0:NRESM),NRBAS,BINDBA(NRESM)
      DOUBLE PRECISION EPS,DELOLD,UMINSC,FAC,SLACKN,TAUQP0
      DOUBLE PRECISION O8SC1,O8SC3,O8VECN
      EXTERNAL O8SC1,O8SC3,O8VECN
      LOGICAL NPERM,QPNEW,ETAINI,VIOBND
      SAVE
C INITIALIZATION
C SAVE STARTING POINT FOR LATER PRINTING ONLY
      DO I=1,N
        D(I)=ZERO
        D0(I)=ZERO
      ENDDO
      ITSTEP=0
      ALIST(0)=NH
      DELIST(0)=0
      VIOLIS(0)=0
      UPSI=ZERO
      PSI=ZERO
      PSI0=ZERO
      SIG0=ZERO
      D0NORM=ONE
      UNORM=ONE
C*** IN ORDER TO HAVE COSPHI WELL DEFINED FOR ITSTEP=1
      DNORM=ONE
      DEL=DEL0
C*** COUNT SUCCESSIVE REGULARIZATION STEPS
      CSREG=0
C*** COUNT SUCCESSIVE SMALL CHANGES IN X
      CSCHGX=0
C*** COUNT SMALL DIFFERENCES OF FX
      CSDIFX=0
C*** COUNT IRREGULAR QUASI-NEWTON-UPDATES
      CSIRUP=0
C*** COUNT SUCCESSIVE SMALL STEPSIZES
      CSSSIG=0
C*** COUNT SUCCESSIVE SMALL DIFFERENCES OF PENALTY-FUNCTION
      CSMDPH=0
      MATSC=ONE
C  FORMERLY TAUQP=TP2 IS WORSE
      TAUQP=ONE
      NPERM=.FALSE.
      IDENT=.FALSE.
      ETAINI=.FALSE.
      IF ( N .GT. 100 .OR. NRES .GT. 100 ) TE3=.FALSE.
      DO  I = 1,N
        PERM(I)=I 
        PERM1(I)=I
      ENDDO
      DO I = 1,NH
        BIND0(I)=1
        BIND(I)=1
        ALIST(I)=I
      ENDDO
      IF ( ANALYT ) THEN
        EPS=MIN(EPSX,SQRT(EPSMAC))
      ELSE
        EPS=EPSDIF
        IF ( EPSX .LT. EPSDIF**2 ) EPSX=EPSDIF**2
      ENDIF
      EPS=MAX(EPSMAC*TP3,MIN(TM3,EPS))
C**** CALLING FOR EXTERNAL FUNCTION EVALUATION NECESSARY ONLY IF 
C     CORR=.TRUE.
C
C******* FUNCTION AND GRADIENT VALUES, FROM XTR=X*XSC

      DO I =1 ,NRES
        IF ( I .LE. NH ) THEN
          CFUERR(I)=.FALSE.
          CALL ESH(I,X,RES(I))
          IF ( CFUERR(I) ) THEN
            IF ( .NOT. SILENT ) CALL O8MSG(23)
            OPTITE=-10
            RETURN
          ENDIF
          TERM=ABS(RES(I))
          IF ( .NOT. GCONST(I) ) THEN
C******* WE ASSUME THAT THE GRADIENT CAN BE EVALUATED WHENEVER 
C******* THE FUNCTION CAN 
            CALL ESGRADH(I,X,YY)
            VAL(I)=.TRUE.
            DO  J=1,N
              GRES(J,I)=YY(J)
            ENDDO
          ENDIF
        ELSE
          BIND(I)=0
          CFUERR(I)=.FALSE.
          CALL ESG(I-NH,X,RES(I))
          IF ( CFUERR(I) ) THEN
            IF ( .NOT. SILENT ) CALL O8MSG(23)
            OPTITE=-10
            RETURN
          ENDIF
          TERM=-MIN(ZERO,RES(I))
          IF ( RES(I) .LE. DELMIN ) THEN
            BIND(I)=1
            ALIST(0)=ALIST(0)+1
            ALIST(ALIST(0))=I
            IF ( .NOT. GCONST(I) ) THEN
              VAL(I)=.TRUE.
C****** WE ASSUME THAT THE GRADIENT CAN BE EVALUATED 
C       WHENEVER THE FUNCTION CAN
              CALL ESGRADG(I-NH,X,YY)
              DO J =1,N
                GRES(J,I)=YY(J)
              ENDDO
            ENDIF
          ENDIF
        ENDIF
        UPSI=UPSI+TERM
        PSI=PSI+TERM*W(I)
        IF ( VAL(I) .AND. .NOT. GCONST(I) )
     F    GRESN(I)=MAX(ONE,O8VECN(1,N,YY))
      ENDDO
  100 CONTINUE
C****************************************************************
C     OBTAINING A POINT FEASIBLE WITHIN TAU0 FIRST
C****************************************************************
      IF ( UPSI .GE. TAU0 ) THEN
        SCF=ZERO
        PHASE=-1
      ELSE
        FFUERR=.FALSE.
        CALL ESF(X,FX)
        IF ( FFUERR ) THEN
          IF ( .NOT. SILENT ) CALL O8MSG(22)
          OPTITE=-9
          RETURN
        ENDIF
        IF ( .NOT. VAL(0) ) THEN
C*** WE ASSUME THAT THE GRADIENT EVALUATION CAN BE DONE 
C*** WHENEVER THE FUNCTION HAS BEEN EVALUATED
          CALL ESGRADF(X,GRADF)
          VAL(0)=.TRUE.
        ENDIF
        SCF=ONE
        PHASE=0
        FXST=FX
        PSIST=PSI
        UPSIST=UPSI
        DO J=1,NRES
          RESST(J)=RES(J)
        ENDDO
        ETA=ZERO
      ENDIF
C*******************************************************************
  200 CONTINUE
C*******************************************************************
C     MAIN ITERATION LOOP: GETTING A BETTER X
C*******************************************************************
      IF ( .NOT. IDENT ) THEN
        ITSTEP=ITSTEP+1
        IF ( ITSTEP .GT. ITERMA ) THEN
          OPTITE=-THREE
          ITSTEP=ITERMA
          B2N=ACCINF(ITSTEP,8)
          B2N0=ACCINF(ITSTEP,7)
          RETURN
        ENDIF
        QPNEW=.FALSE.
        QPTERM=0
        DELOLD=DEL
        DEL=ZERO
        B2N0=-ONE
        B2N=-ONE
        SINGUL=.FALSE. 
        NPERM=.FALSE.
        DO I=1,N
          NPERM=NPERM .OR. (PERM(I) .NE. PERM1(I))
          PERM(I)=PERM1(I)
        ENDDO
        DO I=1,NRES
          DIAG(I)=ZERO
        ENDDO
      ENDIF
C*******************************
C     CURRENT VALID ROW PERMUTATION FOR QR-DECOMPOSITION OF
C     MATRIX OF BINDING GRADIENTS IN ORDER TO OBTAIN CONTINUITY
C     OF THE QR-DECOMPOSITION  IS GIVEN BY PERM
C*******************************
      NR=ALIST(0)
      NRBAS=NR
      DO I=1,NRES
        BINDBA(I)=BIND(I)
      ENDDO
      DO J=1,32
        ACCINF(ITSTEP,J)=ZERO
      ENDDO
      IF ( SCF .NE. ZERO ) THEN
        GFN=O8VECN(1,N,GRADF)
      ELSE
        GFN=ZERO
      ENDIF
C***** COMPUTE NEW WEIGHT OF OBJECTIVE FUNCTION IF USEFUL
      IF ( NRES .GT. 0 .AND. PHASE .GE. 0 .AND. .NOT. IDENT 
     F    .AND. ITSTEP .GT. 1 .AND. 
     F    ( (ACCINF(ITSTEP-1,10) .EQ. -1. .AND.  SCF0 .EQ. ONE )
     F    .OR. ACCINF(ITSTEP-1,10) .EQ. 1. )   ) THEN
C***   TRY RESCALING THE OBJECTIVE FUNCTION
        TERM=ZERO
        DO I=1,NRES
          IF ( GUNIT(1,I) .NE. 1 ) TERM=MAX(TERM,GRESN(I))
        ENDDO
        SCFH=TERM/MAX(ONE/SCFMAX,GFN)
        IF ( SCFH .LT. ONE/SCFMAX ) SCFH=ONE/SCFMAX
        IF ( SCFH .GT. SCFMAX ) SCFH=SCFMAX
        IF ( (FXST-FX)*SCFH+SCFH/SCF*(PSIST-PSI) .GE. 
     F     SCFH/SCF*ETA*CLOW .AND. LASTCH .LE. ITSTEP-4 
     F     .AND. (SCFH .LT. TM1*SCF .OR. SCFH .GT. TP1*SCF) )THEN
C*** RESCALE THE OBJECTIVE FUNCTION IF THIS SEEMS PROMISING AND THE
C*** CHANGE IS SIGNIFICANT 
          CLOW=CLOW+1
          TERM=SCFH/SCF
          PSI=PSI*TERM
          PSIST=PSIST*TERM
          DO I=1,NRES
            U(I)=U(I)*TERM
          ENDDO
          UNORM=UNORM*TERM
          SCF=SCFH
          LASTCH=ITSTEP
          TERM=SQRT(TERM)
          DO  I=1,N
            DIAG0(I)=TERM*DIAG0(I)
            DO  J=1,N
              A(J,I)=A(J,I)*TERM
            ENDDO
          ENDDO
          MATSC=MATSC*TERM
          IF ( .NOT. SILENT ) CALL O8MSG(2)
        ENDIF
      ENDIF
      ACCINF(ITSTEP,1)=ITSTEP
      ACCINF(ITSTEP,2)=FX
      ACCINF(ITSTEP,3)=SCF
      ACCINF(ITSTEP,4)=PSI
      ACCINF(ITSTEP,5)=UPSI
      IF ( .NOT. SILENT ) CALL O8INFO(1)
C
C***  BEGIN SOLVER
C*******************************************************************
C     QR-DECOMPOSITION OF MATRIX OF BINDING GRADIENTS
C*******************************************************************
      IF ( NR .GE. 1 ) THEN
        CALL O8DEC(1,NR)
      ELSE
        RANK=0
      ENDIF
      IF ( SCF .NE. ZERO ) THEN
        CALL O8LEFT(A,GRADF,YY,TERM,N)
        DO I=1,N
          QGF(I)=YY(PERM(I))
        ENDDO
      ELSE
        DO I=1,N
          QGF(I)=ZERO
        ENDDO
      ENDIF
      CALL O8HT(1,0,1,RANK,N,QR,BETAQ,QGF,TRVEC)
      DO I=1,N
        QGF(I)=TRVEC(I)
      ENDDO
      IF ( RANK .NE. NR .AND. .NOT. SILENT ) CALL O8MSG(1)
C*******************************************************************
C     COMPUTE DEL AS FUNCTION OF X (FORCING INFEASIBILITY AND
C     THE PROJECTED GRADIENT TO ZERO)
C*******************************************************************
      B2N0=O8VECN(RANK+1,N,QGF)
      SUM=ZERO
      DO I=1,NRES
        IF ( I.LE.NH ) THEN
          SUM=SUM+ABS(RES(I))/GRESN(I)
        ELSE
          SUM=SUM-MIN(ZERO,RES(I))/GRESN(I)
        ENDIF
      ENDDO
      IF ( ITSTEP .GT. 1 .AND. ACCINF(ITSTEP-1,8) .GE. ZERO 
     F     .AND. .NOT. ETAINI 
     F     .AND. ACCINF(ITSTEP-1,18) .GE. 0  ) THEN
        ETAINI=.TRUE.
        ETA=(ACCINF(ITSTEP-1,8)/MAX(ONE,GFN)+SUM
     F       +MIN(ONE,SLACKN)+MIN(ONE,ABS(UMINSC)))/MIN(30*N,ITERMA)
        LEVEL=ETA
      ENDIF
      IF ( ITSTEP .GT. 1 ) THEN 
        DELX=DELMIN
      ELSE
        DELX=DEL01
      ENDIF
      TERM=SCF*(FX0-FX)+PSI0-PSI
      IF ( TERM .GT. ZERO .AND. SCF .NE. ZERO .AND. ITSTEP .GT. 1 )
     F     DELX=MAX(DELX,EXP(P7*P7*LOG(TERM)))
      IF ( SCF .EQ. ZERO ) DELX=MIN(DEL0*TM4,MAX(DELX,UPSI*TM2))
      DELSIG=DELMIN
C**** DEL SHOULD BE LARGE ENOUGH TO INCLUDE CONSTRAINTS HIT IN 
C**** STEP BEFORE . VIOLIS COMES FROM UNIMIN
      DO I=1,VIOLIS(0)                                             
        J=VIOLIS(I)
        DELSIG=MAX(DELSIG,
     F    RES(J)/GRESN(J)/DELFAC(J)*(ONE+TM1))
      ENDDO
      DEL=MIN(DEL0,MAX(MIN(DELSIG,FIVE*DELX),DELX))
      IF ( VIOLIS(0) .EQ. 0 ) DEL=MIN(DEL,DEL01)
C************************************************************
C     IF PHASE=2 DON'T LOOSE A BINDING CONSTRAINT
C     PHASE=2 IMPLIES DELIST(0)=0
C************************************************************
      IF ( PHASE .EQ. 2 .AND. VIOLIS(0) .EQ. 0 ) THEN
        DO I=NH+1,NRES
          IF ( BIND0(I) .EQ. 1 ) 
     F    DEL=MIN(DEL01,MAX(DEL,ABS(RES(I))/GRESN(I)))
        ENDDO
      ENDIF
C*** REDUCE DEL BY A FIXED FACTOR ( TM2) IF USEFUL, 
C    THAT IS IF DELETE-LIST
C*** IN THE PREVIOUS STEP WAS NOT EMPTY
      TERM=DEL
      DO I=1,DELIST(0)
        J=DELIST(I)
        TERM1=RES(J)/GRESN(J)*(ONE-TM2)/DELFAC(J)
        IF ( TERM1 .GE. DEL*TM2 ) TERM=MIN(TERM,TERM1)
      ENDDO
      DEL=TERM
C***  IF DELTA BECOMES TOO LARGE, WE MAY LOOSE COMPLEMENTARY SLACKNESS
      IF ( ITSTEP .GT. 1 .AND. .NOT. IDENT .AND. SCF .NE. ZERO ) THEN
        TERM=ZERO
        DO I=NH+1,NRES
          TERM=TERM+
     F    MAX(ZERO,RES(I)/GRESN(I)-DELMIN)
     F    *MAX(ZERO,U(I)-SMALLW)/GRESN(I)
        ENDDO
        IF ( TERM .GT. ZERO ) THEN
          DO I=NH+1,NRES
            IF ( U(I) .GT. SMALLW .AND. RES(I)/GRESN(I) .GT. DELMIN )
     F      THEN
              DEL=MAX(DELMIN,
     F          MIN(DEL,RES(I)/GRESN(I)*(ONE-TM2)/DELFAC(I)))
            ENDIF
          ENDDO
        ENDIF
      ENDIF
C***  IF THE CURRENT STEP WAS SINGULAR AND NOT SUCCESSFUL, 
C***  TRY A GREATER DEL
C***  THE SAME, IF QPTERM IN THE LAST STEP DID SIGNAL TROUBLE, BUT
C***  STEPSIZE SELECTION WAS NEVERTHELESS SUCCESSFUL
      IF ( ITSTEP .GT. 1  
     F     .AND. ACCINF(ITSTEP-1,30) .LT. 0. 
     F   ) DEL=MIN(TP1*DELOLD,DEL0)
C*************************************************************
C     INCLUDE NEARLY BINDING INEQUALITY CONSTRAINTS
C*************************************************************
      DO I=NH+1,NRES
        TERM=RES(I)/GRESN(I)
        IF ( BIND(I) .EQ. 0 .AND. TERM .LE. DEL*DELFAC(I) ) THEN
C  IT MAY BE USEFUL TO INCLUDE  CONSTRAINTS>0  IF  NEAR ITS BOUNDARY
C  BUT AVOID IT, IF THE CONSTRAINT WAS IN THE OLD DELETE-LIST
            BIND(I)=1
            ALIST(0)=ALIST(0)+1
            ALIST(ALIST(0))=I
            IF ( .NOT. VAL(I) ) THEN
              VAL(I)=.TRUE.
              CALL ESGRADG(I-NH,X,YY)
              DO J=1,N
                GRES(J,I)=YY(J)
              ENDDO
              GRESN(I)=MAX(ONE,O8VECN(1,N,YY))
            ENDIF
        ENDIF
      ENDDO
      RANK0=RANK
      NR0=NR
      NR=ALIST(0) 
      CALL O8DEC(NR0+1,NR)
      IF ( RANK .NE. NR .AND. .NOT. SILENT ) CALL O8MSG(3)
      CALL O8HT(1,0,RANK0+1,RANK,N,QR,BETAQ,QGF,TRVEC)
      DO I=1,N
        QGF(I)=TRVEC(I)
      ENDDO
      DO I=1,N
        YY(I)=-QGF(I)*SCF
      ENDDO
      DO I=1,NRES
        YU(I)=ZERO
      ENDDO
C************************************************************
C     FIRST COMPUTATION OF LAGRANGIAN MULTIPLIERS U
C************************************************************
      CALL O8SOL(1,RANK,YY,YU)
      UMIN=ZERO
      UNORM=ZERO
      DO I=1,NRES
        U(I)=ZERO
      ENDDO
      IUMIN=0
      UMINSC=ZERO
      DO I=1,RANK
        UNORM=MAX(UNORM,ABS(YU(I)))
        K=ALIST(COLNO(I))
        U(K)=-YU(I)
        IF ( K .GT. NH ) THEN
          IF ( -YU(I)/GRESN(K) .LT. UMINSC ) THEN
            IUMIN=K
            UMINSC=-YU(I)/GRESN(K)
          ENDIF
        ENDIF
      ENDDO
      IF ( SCF .NE. ZERO ) THEN
        DO I=1,N
          YX(I)=SCF*GRADF(I)
          DO J=1,NRES
            YX(I)=YX(I)-GRES(I,J)*U(J)
          ENDDO
        ENDDO
        B2N=O8VECN(1,N,YX)/SCF
      ELSE
        B2N=-ONE
      ENDIF
      IF ( .NOT. SILENT ) CALL O8INFO(3)
C********** COMPUTE NEW DELTA
      DEL1=DEL
      IF ( B2N .GE. ZERO  )
     F DEL1=MAX(DEL,
     F   TM1*MIN(DEL0,
     F   EXP(P7*LOG( ABS(B2N)/(GFN+ONE) + MAX(ZERO,-UMINSC) + SUM))  ))
C**** EXCLUDE CONSTRAINTS WHICH WERE CANDIDATES FOR INACTIVATING 
C     IN THE PREVIOUS STEP
C**** IF USEFUL
      DO I=1,DELIST(0)
        J=DELIST(I)
        TERM1=RES(J)/GRESN(J)*(ONE-TM2)/DELFAC(J)
        IF ( TERM1 .GE. DEL1*TM2 ) DEL1=MAX(DELMIN,MIN(DEL1,TERM1))
      ENDDO
      SLACKN=ZERO
      DO I=NH+1,NRES
        SLACKN=SLACKN+
     F  MAX(ZERO,RES(I)/GRESN(I)-DELMIN)*MAX(ZERO,U(I)-SMALLW)/GRESN(I)
      ENDDO
      IF ( UPSI .LE. DELMIN .AND. B2N .LE. EPSX*(GFN+ONE)
     F     .AND. B2N .NE. -ONE
     F     .AND. UMINSC .GE. -SMALLW .AND.
     F     SLACKN .LE. DELMIN*SMALLW*NRES ) THEN
C SUFFICIENT ACCURACY IN KUHN-TUCKER CONDITIONS
        OPTITE=ZERO
        RETURN
      ENDIF
C******** INCLUDE ADDITIONAL CONSTRAINTS IF NECESSARY
      L0=ALIST(0)
      DO I=1,NRES
        TERM=RES(I)/GRESN(I)/DELFAC(I)
        IF ( TERM .GT. DEL .AND. TERM .LE. DEL1
     F      .AND. BIND(I) .EQ. 0) THEN
          BIND(I)=1
          ALIST(0)=ALIST(0)+1
          ALIST(ALIST(0))=I
          IF ( .NOT. VAL(I) ) THEN
            VAL(I)=.TRUE.
            CALL ESGRADG(I-NH,X,YY)
            DO J=1,N
              GRES(J,I)=YY(J)
            ENDDO
            GRESN(I)=MAX(ONE,O8VECN(1,N,YY))
          ENDIF
        ENDIF
      ENDDO
      DEL=DEL1
      ACCINF(ITSTEP,6)=DEL
      ACCINF(ITSTEP,7)=B2N0
      ACCINF(ITSTEP,9)=ALIST(0)
      ACCINF(ITSTEP,10)=-1.
      NR=ALIST(0)
      IF ( L0 .NE. NR ) THEN
        RANK0=RANK
        CALL O8DEC(L0+1,NR)
        CALL O8HT(1,0,RANK0+1,RANK,N,QR,BETAQ,QGF,TRVEC)
        DO I=1,N
          QGF(I)=TRVEC(I)
        ENDDO
      ENDIF
      IF ( .NOT. SILENT ) CALL O8INFO(2)
      IF ( RANK .NE. NR ) THEN
        IF ( .NOT. SILENT ) CALL O8MSG(4)
        GOTO 400
      ENDIF
C************************************************************
C     SECOND SOLUTION FOR MULTIPLIERS, RANK MAY HAVE CHANGED !
C************************************************************
      DO I=1,N
        YY(I)=-QGF(I)*SCF
      ENDDO
      DO I=1,NRES
        YU(I)=ZERO
      ENDDO
      CALL O8SOL(1,RANK,YY,YU)
C*** REMEMBER THE COLUMN INTERCHANGES IN QR! 
C*** YU(I) CORRESPONDS TO U(ALIST(COLNO(I))
      UMIN=ZERO
      UNORM=ZERO
      DO I=1,NRES
        U(I)=ZERO
      ENDDO
      IUMIN=0
      UMINSC=ZERO
      DO I=1,RANK
        UNORM=MAX(UNORM,ABS(YU(I)))
        K=ALIST(COLNO(I))
        U(K)=-YU(I)
        IF ( K .GT. NH ) THEN
          UMIN=MIN(UMIN,-YU(I))
          IF ( -YU(I)/GRESN(K) .LT. UMINSC ) THEN
            IUMIN=K
            UMINSC=-YU(I)/GRESN(K)
          ENDIF
        ENDIF
      ENDDO
      IF ( SCF .NE. ZERO ) THEN
        DO I=1,N
          YX(I)=SCF*GRADF(I)
          DO J=1,NRES
            YX(I)=YX(I)-GRES(I,J)*U(J)
          ENDDO
        ENDDO
        B2N=O8VECN(1,N,YX)/SCF
      ENDIF
      ACCINF(ITSTEP,8)=B2N
      ACCINF(ITSTEP,11)=UMIN
      CALL O8SHMS
      IF ( .NOT. SILENT ) CALL O8INFO(4)
      DELIST(0)=0
      IF ( PHASE .GE. 0 .AND. B2N .NE. -ONE ) THEN
        IF ( ABS(UMINSC) .GE. MAX(SMALLW,ABS(B2N)/(GFN+ONE)*C1D)) THEN
          DO I=NH+1,NR
            K=ALIST(COLNO(I))
            IF ( -YU(I)/GRESN(K) .LE. -SMALLW
     F            ) THEN
              DELIST(0)=DELIST(0)+1
              DELIST(DELIST(0))=K
            ENDIF
          ENDDO
        ENDIF
      ENDIF
C*** THE NEW DELIST DOESN'T INFLUENCE THE CURRENT D BUT ONLY THE 
C*** COMPUTATION
C*** OF THE NEXT DEL
C***************************************************************
      EQRES=.TRUE.
      DO I =1,NRES
        EQRES=EQRES .AND. ( BIND(I) .EQ. BIND0(I) )
      ENDDO
C
C
C*****  COMPUTE CONDITION NUMBER ESTIMATORS OF DIAG-R AND DIAG OF
C*****  CHOLESKY-DECOMPOSITION OF B
      IF ( NR .GT. 1 ) THEN
        TERM=ZERO
        TERM1=ONE
        DO I=1,NR
          TERM=MAX(TERM,ABS(DIAG(I)))
          TERM1=MIN(TERM1,ABS(DIAG(I)))
        ENDDO
        ACCINF(ITSTEP,13)=TERM/TERM1
      ELSEIF ( NR .EQ. 1 ) THEN
        ACCINF(ITSTEP,13)=1.
      ELSE
        ACCINF(ITSTEP,13)=-1.
      ENDIF
      TERM=ABS(A(1,1))
      TERM1=ABS(A(1,1))
      I=2
      DO WHILE ( I .LE. N )
          TERM=MAX(TERM,ABS(A(I,I)))
          TERM1=MIN(TERM1,ABS(A(I,I)))
          I=I+1
      ENDDO
      ACCINF(ITSTEP,14)=(TERM/TERM1)**2
      IF ( .NOT. SILENT ) CALL O8INFO(5)
C*** SINCE A REPRESENTS THE CHOLESKY-FACTOR, THIS SQUARE
      SLACKN=ZERO
      DO I=NH+1,NRES
        SLACKN=SLACKN+
     F  MAX(ZERO,RES(I)/GRESN(I)-DELMIN)*MAX(ZERO,U(I)-SMALLW)/GRESN(I)
      ENDDO
      IF (  UMIN .GE. -SMALLW .AND.
     F      SLACKN .LE. DELMIN*SMALLW*NRES  .AND.
     F      UPSI .LE. NRES*DELMIN .AND. UPSI0 .LE. NRES*DELMIN
     F      .AND. ABS(FX-FX0) .LE. EPS*(ABS(FX)+ONE) .AND.
     F      B2N .NE. -ONE .AND.
     F      B2N .LE. TP2*EPSX*(GFN+ONE)    ) THEN
        CSDIFX=CSDIFX+1
      ELSE
        CSDIFX=0
      ENDIF
      IF ( PHASE .GE. 0 .AND.
     F     (ACCINF(ITSTEP,14) .GT. TP3 .OR. .NOT. ANALYT ) .AND.
     F    CSDIFX .GT. N     ) THEN
          OPTITE=FOUR
C****     TO AVOID POSSIBLE SLOW CONVERGENCE WITH SINGULAR 
C****     PROJECTED HESSIAN OR INACCURATE NUMERICAL GRADIENTS
          RETURN
      ENDIF
C
C
C****** COMPUTE DAMPING FACTOR FOR TANGENTIAL COMPONENT IF UPSI>TAU0/2
      SCF0=ONE
      IF ( PHASE .GE. 0 .AND. UPSI .GT. TAU0*P5 )
     F   SCF0=MAX(ONE/SCFMAX,
     F        (TWO*(TAU0-UPSI)/TAU0)*UPSI*TM1/MAX(ONE,GFN) )/SCF
      ACCINF(ITSTEP,15)=SCF0
C
C
C************************************************************
C   COMPUTE TANGENTIAL COMPONENT
C************************************************************
      DO I=NR+1,N
        QTX(I)=YY(I)*SCF0
      ENDDO
C
C
C**** QTX(NR+1),..,QTX(N) IS S2
C************************************************************
C   COMPUTE RIGHT HAND SIDE AND VERTICAL COMPONENT
C   USE DAMPING FOR INACTIVATION DIRECTION IF VERY LARGE
C   NO INDIRECT INACTIVATION IF INFEASIBILITY LARGE AND
C   WE ARE NOT ALMOST STATIONARY ON THE CURRENT MANIFOLD
C************************************************************
      FAC=ONE
      IF ( -UMIN*C1D .GT. B2N+UPSI .AND. B2N .NE. -ONE ) FAC=C1D
      IF ( UPSI .GT. TAU0*P5 ) FAC=ZERO
      DO I=1,NR
        K=ALIST(COLNO(I))
        TERM=RES(K)
        IF ( K .GT. NH .AND. -YU(I) .LT. ZERO
     F       .AND. TERM .GT. ZERO ) TERM=-TERM
        IF ( K .GT. NH .AND. -YU(I) .LT. ZERO )
     F       TERM=TERM-YU(I)*FAC
        YX(I)=-TERM
      ENDDO
      CALL O8SOLT(1,NR,YX,QTX)
C**** QTX IS TRANSFORMED  DIRECTION OF DESCENT FOR PHI
      CALL O8HT(-1,0,1,NR,N,QR,BETAQ,QTX,YX)
      DO I=1,N
        QTX(PERM(I))=YX(I)
      ENDDO
C**** SOLVE L(TRANSP)*D=QTX, L = A = CHOLESKY-FACTOR OF B
      CALL O8RGHT(A,QTX,D,TERM,N)
C**** END SOLVER
C***** COMPUTE NEW PENALTY WEIGHTS : REGULAR CASE
      CLWOLD=CLOW
      IF ( PHASE .GE. 0  ) CALL O8SCE
      IF ( CLOW .GT. CLWOLD ) THEN
C*** TAU_QP DEPENDS ON THE (NEW) WEIGHTS
        TERM=W(1)
        DO I=1,NRES
          TERM=MAX(TERM,W(I))
        ENDDO
        TAUQP=MAX(ONE,MIN(TAUQP,TERM))
      ENDIF
C
C
C
C**** COMPUTE PARAMETER PHASE AND STOPPING CRITERION
      IF ( UMINSC .LT. -SMALLW ) PHASE=MIN(1,PHASE)
      IF ( .NOT. EQRES ) PHASE=MIN(0,PHASE)
      IF ( EQRES .AND. UPSI .LT. TAU0 ) PHASE=MAX(1,PHASE)
C*** RESCALE AND PROJECT D IF APPROPRIATE
      CALL O8CUTD
C*** COMPUTE THE DIRECTIONAL DERIVATIVE DIRDER
      CALL O8DIRD
C*** TERMINATE IF CORRECTION IS SMALL
      IF ( DNORM .LE. EPSX*(XNORM+EPSX) .AND. UPSI .LE. DELMIN
     F     .AND. B2N .NE. -ONE 
     F     .AND. UMINSC .GE. -SMALLW .AND. B2N .LE. EPSX*(GFN+ONE) )
     F     THEN
        OPTITE=ONE
        RETURN
      ENDIF
  350 CONTINUE
C***** REENTER FROM THE SINGULAR CASE: DIRDER HAS BEEN COMPUTED ALREADY
      ACCINF(ITSTEP,16)=XNORM
      ACCINF(ITSTEP,17)=DNORM
      ACCINF(ITSTEP,18)=PHASE
C***** COMPUTE STEPSIZE
      CFINCR=ICF
C****
C****
C**** IF NO DESCENT DIRECTION IS OBTAINED, CHECK WHETHER RESTARTING 
C**** THE METHOD
C**** MIGHT HELP
      IF ( DIRDER .GE. ZERO  ) THEN
C**** NO DIRECTION OF DESCENT
        IF ( .NOT. SILENT ) CALL O8MSG(11)
        STPTRM=-TWO
        SIG=ZERO
        GOTO 360
      ENDIF
C**** IF DIRECTIONAL DERIVATIVE CORRECT BUT VERY SMALL, TERMINATE
C**** SINCE NO FURTHER PROGRESS MIGHT BE POSSIBLE
      IF (-DIRDER.LE.EPSMAC*TP2*(SCF*ABS(FX)+PSI+ONE))THEN
        IF ( UPSI .GT. DELMIN*NRES ) THEN
          OPTITE = -ONE
          STPTRM = -ONE
        ELSE
          OPTITE = TWO
          STPTRM = ONE
        ENDIF
        SIG = ZERO
        GOTO 360
      ENDIF
C*** PHASE = 2 : WE MAY HOPE TO OBTAIN SUPERLINEAR CONVERGENCE
C*** SWITCH TO MARATOS-CORRECTION IS ON THEN
C*** RETURN TO PHASE=1 IF FIRST ORDER CORRECTION LARGE
      IF ( PHASE .GE. 1
     F .AND. DNORM .LE. SMALLD*(XNORM+SMALLD) .AND. SCF0 .EQ. ONE .AND.
     F     UMINSC .GE. -SMALLW  .AND. .NOT. SINGUL) PHASE=2
      IF ( PHASE .EQ. 2 .AND. DNORM .GT. (XNORM+SMALLD) )
C*** RETURN TO PHASE 1 SINCE CORRECTION LARGE AGAIN
     F     PHASE=1
C
C
      CALL O8SMAX
C*** STMAXL IS THE MAXIMAL STEPSIZE SUCH THAT POINT ON PROJECTED
C*** RAY CHANGES WITH SIGMA, BUT SIGLA AT MOST
      DO I=1,N
        DD(I)=ZERO
        X1(I)=X(I)+D(I)
      ENDDO 
C**** CORRECTION ADDED . ERROR MESSAGE FROM RSI-FRANCE
      VIOBND=.FALSE.
      DO I=1,N
        IF ( (LLOW(I) .AND. X1(I) .LT. UG(I)-TAUBND) .OR.
     *    (LUP(I) .AND. X1(I) .GT. OG(I)+TAUBND) ) VIOBND=.TRUE.
      ENDDO
C**** END CORRECTION
C**** COMPUTE SECOND ORDER CORRECTION OF INFEASIBILITY IF USEFUL
      IF ( PHASE .EQ. 2 .AND. DNORM .GT. XNORM*SQRT(EPSMAC) 
     F  .AND. (.NOT. SINGUL)  .AND. (.NOT. VIOBND) ) THEN
       IF ( BLOC ) CALL USER_EVAL(X1,-1)
C***** ONLY FUNCTION VALUES, FROM XTR=XSC*X1
        DO I=1,ALIST(0)
          YX(I)=ZERO
          IF ( I.LE. NH .AND. .NOT. GCONST(ALIST(I)) ) THEN
            CFUERR(I)=.FALSE.
            CALL ESH(I,X1,YX(I))
            IF ( CFUERR(I) ) GOTO 355
          ELSE
            IF ( .NOT. GCONST(ALIST(I)) ) THEN
              CFUERR(ALIST(I))=.FALSE.
              CALL ESG(ALIST(I)-NH,X1,YX(I))
              IF ( CFUERR(ALIST(I)) ) GOTO 355
            ENDIF
          ENDIF
          YX(I)=-YX(I)
        ENDDO
        DO I=1,ALIST(0)
          YY(I)=YX(COLNO(I))
        ENDDO
        CALL O8SOLT(1,NR,YY,DD)
        DO I=NR+1,N
          DD(I)=ZERO
        ENDDO
        CALL O8HT(-1,0,1,NR,N,QR,BETAQ,DD,YX)
        DO I=1,N
          DD(PERM(I))=YX(I)
        ENDDO
        CALL O8RGHT(A,DD,DD,TERM,N)
        IF ( SQRT(TERM) .GT. P5*DNORM ) THEN
C*** SECOND ORDER CORRECTION ALMOST AS LARGE AS FIRST ORDER ONE: 
C*** NOT USEFUL
          DO I=1,N
            DD(I)=ZERO
          ENDDO
          IF ( .NOT. SILENT ) CALL O8MSG(6)
        ENDIF
      ENDIF
  355 CONTINUE
      IF ( .NOT. SILENT ) CALL O8INFO(7)
C
C
      SIG=MIN(ONE,STMAXL)
      CALL O8UNIM(SIG)
C
C
  360 CONTINUE      
      CFINCR=ICF-CFINCR
      IF ( .NOT. SILENT ) CALL O8INFO(10)
C***** COUNT SUCCESSIVE SMALL STEPS
      TERM=SCF*(FX0-FX)+PSI0-PSI
      IF ( ABS(TERM) .LE. EPSPHI*(SCF*ABS(FX)+PSI) ) THEN
       CSMDPH=CSMDPH+1
      ELSE
       CSMDPH=0
      ENDIF
C**** CSMDPH COUNTS CONTIGUOUS SMALL DIFFERENCES OF PENALTY 
C**** FUNCTION PHI
      IF ( CSMDPH .GT. NUMSM ) THEN
        OPTITE=SEVEN
        RETURN
      ENDIF
      IF ( SIG .LE. FIVE*TM2 ) THEN
        IF ( SIG0 .LE. FIVE*TM2 ) CSSSIG=CSSSIG+1
      ELSE
        CSSSIG=0
      ENDIF
C***
C***  CSSSIG COUNTS THE NUMBER OF SUCCESSIVE SMALL SIG'S
C*** 
      ACCINF(ITSTEP,21)=SIG
      ACCINF(ITSTEP,22)=CFINCR
      ACCINF(ITSTEP,23)=DIRDER
      ACCINF(ITSTEP,24)=DSCAL
      ACCINF(ITSTEP,25)=COSPHI
      ACCINF(ITSTEP,26)=VIOLIS(0)
      IF ( SIG .EQ. ZERO .AND. STPTRM .EQ. ONE .AND.
     F     OPTITE .EQ. TWO ) THEN
C******* NO FURTHER SIGNIFICANT PROGRESS POSSIBLE
         IF ( .NOT. SILENT ) CALL O8INFO(17)
         RETURN
      ENDIF
      IF ( STPTRM .EQ. ONE .AND. SIG .LE. TM4 .AND. 
     F     ACCINF(ITSTEP,13) .GT. TP4 .AND. .NOT. SINGUL
     F    .AND. NRES .GT. 0) THEN
C*** TRY A REGULARIZED STEP, HOPEFULLY THIS WILL GIVE A BETTER D 
C    AND LARGER SIG
           IF ( ACCINF(ITSTEP,14) .GT. TP4 ) CALL O8INIM
           IDENT=.TRUE.
           SINGUL=.TRUE.
           GOTO 400
      ENDIF
      IF ( STPTRM .LT. ZERO ) THEN
C******* STEPSIZE SELECTION FAILED
        IF (  .NOT. IDENT )
     F    THEN
C******* TRY RESTART WITH A = IDENTITY SCALED
          IF ( .NOT. SILENT ) CALL O8MSG(7)
          IDENT=.TRUE.
          DELIST(0)=0
          VIOLIS(0)=0
          CSREG=0
          CSSSIG=0
          CSIRUP=0
          CALL O8INIM
          ALIST(0)=NRBAS
          DO I=1,NRES
            BIND(I)=BINDBA(I)
          ENDDO
          IF ( UPSI .GE. TAU0 ) THEN
            GOTO 100
          ELSE
            GOTO 200
          ENDIF
        ENDIF
        IF ( .NOT. SINGUL .AND. IDENT .AND.
     F     ACCINF(ITSTEP,13) .GT. TP4 .AND. NRES .GT. 0 ) THEN
C**** TRY THE FULL SQP-DIRECTION
C**** THIS MAY BE THE THIRD TRY FOR THIS POINT
          SINGUL=.TRUE.
          IDENT=.TRUE.
          GOTO 400
        ENDIF
        IF ( STPTRM .EQ. -TWO ) THEN
          OPTITE=-FOUR
          RETURN
        ENDIF
        IF ( SIG .EQ. ZERO .AND. OPTITE .EQ. -ONE ) RETURN
C***** UNIDIMENSIONAL SEARCH UNSUCCESSFULLY TERMINATED
        OPTITE=-TWO
        RETURN
      ENDIF
C*****
      IF ( SINGUL .AND. ITSTEP .GT. N .AND. ABS(FX-FX0) .LE.
     F     EPS*(ABS(FX)+ONE) .AND. PHASE .GE. 0
     F     .AND. UPSI .LE. NRES*DELMIN  .AND. UPSI0 .LE. NRES*DELMIN
     F     .AND. SLACKN .LE. DELMIN*SMALLW*NRES
     F     .AND. INFEAS .LE. UPSI 
     F     .AND. .NOT. IDENT ) THEN
C****** SINCE MULTIPLIERS MAY BE INCORRECT FOR INFEAS .NE. ZERO BE 
C****** CAREFUL. IF MULTIPLIERS ARE IMPORTANT CHECK IN SOLCHK
        OPTITE=FOUR
C****** AVOID SLOW PROGRESS IN CASE OF SINGULAR CONSTRAINTS ****
        RETURN
      ENDIF
C****** RELAXED TERMINATION CRITERIA IN THE SINGULAR CASE
      IF ( SINGUL .AND. UPSI .LE. DELMIN*NRES .AND. UPSI0 .LE. 
     F     DELMIN*NRES
     F   .AND.  B2N .NE. -ONE
     F   .AND.  B2N .LE. (GFN+ONE)*EPSX*TP2 .AND. PHASE .GE. 0
     F   .AND. SLACKN .LE. DELMIN*SMALLW*NRES
     F   .AND. INFEAS .LE. UPSI ) THEN
C****** SINCE MULTIPLIERS MAY BE INCORRECT FOR INFEAS .NE. ZERO 
C****** BE CAREFUL. IF MULTIPLIERS ARE IMPORTANT CHECK IN SOLCHK
C****** 
        OPTITE=THREE  
        RETURN
      ENDIF
      K=0
      DO I=1,N
        IF ( ABS(DIFX(I)) .GE. EPSX*(ABS(X(I))+TM2)) K=1
      ENDDO
      IF ( K .EQ. 0  ) THEN
        CSCHGX=CSCHGX+1
      ELSE
        CSCHGX=0
      ENDIF
      IF ( CSCHGX .GT. NRESET .AND. SINGUL ) THEN
C**** VERY SLOW PROGRESS IN X IN THE SINGULAR CASE. TERMINATE
        OPTITE=FIVE
        RETURN
      ENDIF
C*********** NEW VALUE OF X HAS BEEN ACCEPTED
      XNORM=O8VECN(1,N,X)
      IDENT=.FALSE.
      CALL O8EGPH(GPHI0)
      DO I=0,NRES
        IF ( .NOT. GCONST(I) )  VAL(I)=.FALSE.
      ENDDO
C
      IF ( BLOC ) CALL USER_EVAL(X,2)
C     EVALUATE GRADIENTS ONLY, SINCE FUNCTION VALUES ARE ALREADY 
C     VALID FROM UNIDIMENSIONAL MINIMIZATION
C     ARGUMENT IS XTR=XSC*X
      IF ( PHASE .GE. 0 .AND. .NOT. GCONST(0) ) THEN
        VAL(0)=.TRUE.
        CALL ESGRADF(X,GRADF)
      ENDIF
      DO I=1,ALIST(0)
        L=ALIST(I)
        IF ( .NOT. VAL(L) ) THEN
          VAL(L)=.TRUE.
          IF ( L .LE. NH ) THEN
            CALL ESGRADH(L,X,YX)
          ELSE
            CALL ESGRADG(L-NH,X,YX)
          ENDIF
          DO J=1,N
            GRES(J,L)=YX(J)
          ENDDO
          GRESN(L)=MAX(ONE,O8VECN(1,N,YX))
        ENDIF
      ENDDO
      CALL O8EGPH(GPHI1)
      DO I=1,N
        YX(I)=X(I)-X0(I)
        YY(I)=GPHI1(I)-GPHI0(I)
      ENDDO
C**** SINCE A REPRESENTS THE CHOLESKY-FACTOR, THIS SQRT
      TERM=SQRT(O8VECN(1,N,YY)/O8VECN(1,N,YX))
      IF ( TERM .NE. ZERO .AND. PHASE .GE. 0 )
     F      MATSC=MAX(ONE/SCFMAX,MIN(SCFMAX,TERM/2))
C**** CURRENT SCALING OF IDENTITY IN CASE OF RESTART
C
      ALIST(0)=0
      DO I=1,NRES
        U0(I)=U(I)
        BIND0(I)=BIND(I)
        RES0(I)=RES(I)
        IF ( I.LE. NH ) THEN
          BIND(I)=1
        ELSE
          BIND(I)=0
          IF ( RES(I)/GRESN(I) .LE. DELMIN ) BIND(I)=1
          IF ( .NOT. VAL(I) .AND. BIND(I) .EQ. 1 ) THEN
            VAL(I)=.TRUE.
            CALL ESGRADG(I-NH,X,YX)
            DO J=1,N
              GRES(J,I)=YX(J)
            ENDDO
            GRESN(I)=MAX(ONE,O8VECN(1,N,YX))
          ENDIF
        ENDIF
        IF ( BIND(I) .EQ. 1 ) THEN
          ALIST(0)=ALIST(0)+1
          ALIST(ALIST(0))=I
        ENDIF
      ENDDO
C**** DEFINE EVALUATION SEQUENCE FOR CONSTRAINTS: 
C**** NONBINDING INEQUALITIES IN ASCENDING ORDER OF VALUE
C**** BEFORE  THE BINDING ONES (COMMENTED HERE, 
C**** TOO EXPENSIVE FOR NG LARGE)
CSORT      K=0
CSORT      DO I=1,NRES
CSORT        IF ( BIND(I) .EQ. 0 ) THEN
CSORT          K=K+1
CSORT          SORT(K)=I
CSORT          WORK(K)=RES(I)
CSORT        ENDIF
CSORT      ENDDO
CSORT      DO I=1,ALIST(0)
CSORT        K=K+1
CSORT        SORT(K)=ALIST(I)
CSORT        WORK(K)=RES(ALIST(I))
CSORT      ENDDO
CSORT      DO I=1,NRES-ALIST(0)
CSORT        TERM=WORK(I)
CSORT        J=I
CSORT        DO K=I+1,NRES-ALIST(0)
CSORT          IF ( WORK(K) .LT. TERM )  THEN
CSORT            TERM=WORK(K)
CSORT            J=K
CSORT          ENDIF
CSORT        ENDDO
CSORT        K=SORT(I)
CSORT        SORT(I)=SORT(J)
CSORT        SORT(J)=K
CSORT        TERM=WORK(I)
CSORT        WORK(I)=WORK(J)
CSORT        WORK(J)=TERM
CSORT      ENDDO  
C**** BIND NOW CORRESPONDS TO THE STATE OF THE NEW POINT            
C**** BUT THERE MAY BE GRADIENTS EVALUATED AT THE NEW POINT
C**** NOT YET PUT TO BIND
C****
C**** UPDATE THE UNPROJECTED QUASI-NEWTON-MATRIX ANYWAY
C****
      IF ( SCF .NE. ZERO ) THEN
       IF ( CSIRUP .GT. NRESET .OR. CSSSIG .GT. NRESET
     F      .OR. CSREG  .GT. NRESET 
     F     ) THEN
         CSREG=0
         CSSSIG=0
         CSIRUP=0
         CALL O8INIM
       ELSE
         CALL O8BFGS
C*** FOR PROJECTED UPDATE:   IF ( .NOT. SILENT ) CALL O8INFO(13)
C*** FOR PANTOJA&MAYNE UPDATE:
         IF ( .NOT. SILENT ) CALL O8INFO(14)
       ENDIF
      ENDIF
C****
C**** PROCEED
C****
      IF(ACCINF(ITSTEP,27) .EQ. ONE ) THEN
        IF( ITSTEP .GT. 1 .AND.
     F    ACCINF(ITSTEP-1,29).NE.ZERO.AND.ACCINF(ITSTEP,29).NE.ZERO)
     F  THEN
C*** C OUNT S UCCESSIVE IR REGULAR UP DATES
          CSIRUP=CSIRUP+1
        ELSE
          CSIRUP=0
        ENDIF 
      ENDIF
C**** ACCINF(ITSTEP,27) =1     UPDATE  PANTOJA&MAYNE
C****                   =0     NOUPDATE
C****                   =-1    RESTART
C****                   =2     NORMAL BFGS (NR=0)
C****                   =3     POWELL'S MODIFIED BFGS (NR=0)
C**** ACCINF(ITSTEP,28) =      MODIFICATION TERM TK/ DEN2/DEN1  RESP.
C**** ACCINF(ITSTEP,29) =      MODIFICATION FACTOR TH/XSIK RESP.
C**** CSIRUP COUNTS THE NUMBER OF SUCCESSIVE IRREGULAR UPDATING STEPS
      IF ( PHASE .EQ. -1 ) THEN 
        GOTO 100
      ELSE
        GOTO 200
      ENDIF
  400 CONTINUE
      SINGUL=.TRUE.
      PHASE=MIN(PHASE,0)
      ACCINF(ITSTEP,10)=ONE
C************ TRY TO COMPUTE A DESCENT DIRECTION USING
C************ AN EXTENDED QUADRATIC PROGRAM WITH
C************ INDIVIDUAL SLACK VARIABLE FOR ANY CONSTRAINT
C****** COMPUTE DAMPING FACTOR FOR TANGENTIAL COMPONENT IF UPSI>TAU0/2
C****** BY RESCALING F IF POSSIBLE
      SCF0=ONE
      IF ( PHASE .GE. 0 .AND. UPSI .GT. TAU0*P5 ) THEN
        SCFH=MAX(ONE/SCFMAX,
     F      MIN(SCFMAX,
     F          (TWO*(TAU0-UPSI)/TAU0)*UPSI*TAU/MAX(ONE,GFN) ) )
        IF ( (FXST-FX)*SCFH+SCFH/SCF*(PSIST-PSI) .GE. 
     F     SCFH/SCF*ETA*CLOW .AND. LASTCH .LE. ITSTEP-4
     F     .AND. (SCFH .LT. TM1*SCF .OR. SCFH .GT. TP1*SCF) )THEN
C*** RESCALE THE OBJECTIVE FUNCTION IF THIS SEEMS PROMISING AND THE
C*** CHANGE IS SIGNIFICANT 
          CLOW=CLOW+1
          TERM=SCFH/SCF
          SCF0=TERM  
          PSI=PSI*TERM
          PSIST=PSIST*TERM
          DO I=1,NRES
            U(I)=U(I)*TERM
          ENDDO
          UNORM=UNORM*TERM
          SCF=SCFH
          LASTCH=ITSTEP
          ACCINF(ITSTEP,15)=SCF
          TERM=SQRT(TERM)
          DO  I=1,N
            DIAG0(I)=TERM*DIAG0(I)
            DO  J=1,N
              A(J,I)=A(J,I)*TERM
            ENDDO
          ENDDO
          MATSC=MATSC*TERM
          IF ( .NOT. SILENT ) CALL O8MSG(2)
        ENDIF
      ENDIF
C***  SLACK IS UPSI AT MOST
      ACCINF(ITSTEP,32)=UPSI
      IF ( .NOT. SILENT ) CALL O8INFO(15)
C***
C***
      ACCINF(ITSTEP,13)=-ONE
      TERM=ABS(A(1,1))
      TERM1=TERM
      I=2
      DO WHILE ( I .LE. N )
          TERM=MAX(TERM,ABS(A(I,I)))
          TERM1=MIN(TERM1,ABS(A(I,I)))
          I=I+1
      ENDDO
      ACCINF(ITSTEP,14)=(TERM/TERM1)**2
      IF ( .NOT. SILENT ) CALL O8INFO(5)
      CLWOLD=CLOW
C*** SAVE FOR RESTART
      TAUQP0=TAUQP
      DO I=1,NRES
        U(I)=ZERO
      ENDDO
      DO I=1,N
        DD(I)=ZERO
      ENDDO
C
C
      CALL O8QPDU
      IF ( DNORM .EQ. ZERO .AND. QPTERM .EQ. 1
     F    .AND. OPTITE .EQ. THREE  ) RETURN
      IF ( DNORM .LE. EPSX*(MIN(XNORM,ONE)+EPSX) .AND.
     F     QPTERM .LT. 0  )
     F  THEN
C*** MAY BE IT FAILED BECAUSE OF ILLCONDITIONING
        IF ( UPSI .GE. NRES*DELMIN 
     F      .AND. QPNEW ) THEN
C*** RESTARTING THE METHOD HAS BEEN DONE ALREADY: GAME IS OVER
          OPTITE=-ONE
          IF ( .NOT. SILENT ) CALL O8INFO(18)
          RETURN
        ENDIF
        IF ( QPNEW ) THEN
          OPTITE=QPTERM-FIVE
          IF ( .NOT. SILENT ) CALL O8INFO(18)
          RETURN
        ENDIF
C*** TRY A=ID
          QPNEW=.TRUE.
          DO I=1,NRES
            W(I)=ONE
          ENDDO
          LASTCH=ITSTEP
          CALL O8INIM
          IDENT=.TRUE.
C FORMERLY TAUQP=TAUQP0
          TAUQP=ONE
          ALIST(0)=NRBAS
          DO I=1,NRES
            BIND(I)=BINDBA(I)
          ENDDO
          IF ( SCF .EQ. ZERO ) THEN
            GOTO 100
          ELSE
            GOTO 200
          ENDIF
      ENDIF
      ACCINF(ITSTEP,11)=ZERO
      DELIST(0)=0
      UMIN=ZERO
C*** B2N IS DEFINED ALSO INTERNALLY IN O8QPDU
      CALL O8SHMS
      IF ( (QPTERM .GE. 0 .OR. QPTERM .EQ. -3)
     F         .AND. SCF .NE. ZERO ) THEN
        UNORM=ABS(U(1))
        DO I=2,NRES
          UNORM=MAX(UNORM,ABS(U(I)))
        ENDDO
        DO I=1,N
          YX(I)=SCF*GRADF(I)
          DO J=1,NRES
            YX(I)=YX(I)-GRES(I,J)*U(J)
          ENDDO
        ENDDO
        B2N=O8VECN(1,N,YX)/SCF
      ELSE
        B2N=-ONE
C*** SIGNALS "UNDEFINED" HERE
      ENDIF
      IF ( .NOT. SILENT ) CALL O8INFO(2)
      IF ( .NOT. SILENT ) CALL O8INFO(16)
C*** TO AVOID TERMINATION
      IF ( B2N .EQ. -ONE ) B2N=EPSMAC/TOLMAC
      IF ( QPTERM .GE. 0
     F   .AND. DNORM .LE. TM2*EPSX*(EPSX+MIN(ONE,XNORM)))
     F   THEN
           IF ( UPSI .LE. NRES*DELMIN ) THEN
             OPTITE=SIX
           ELSE
             OPTITE=-FIVE
           ENDIF
           RETURN
      ENDIF
C***
C***
C**** CHECK WHETHER QPSOLVER TERMINATED UNSUCCESSFULLY
      IF ( QPTERM .LT. 0 ) THEN
C*** WE HAVE A UNFEASIBLE  SOLUTION FOR QP. TRY IT
C*** BUT DON'T COMPLAIN IF IT FAILS
          IF ( .NOT. SILENT ) CALL O8MSG(10)
      ENDIF
      IF ( CLOW .GT. CLWOLD ) THEN
        TERM=ONE
        DO I=1,NRES
          TERM=MAX(TERM,W(I))
        ENDDO
        TAUQP=MAX(ONE,TERM)
      ENDIF
      IF ( TAUQP .GT. TAUFAC**3*TAUQP0 )TAUQP=TAUFAC**3*TAUQP0
C*** NO CHANGE OF TAUQP OTHERWISE
      B2N0=B2N
      UMIN=ZERO
      UMINSC=ZERO
      IF ( QPTERM .GE. 1 ) THEN
        SLACKN=ZERO
        DO I=NH+1,NRES
          SLACKN=SLACKN+
     F MAX(ZERO,RES(I)/GRESN(I)-DELMIN)*MAX(ZERO,U(I)-SMALLW)/GRESN(I)
        ENDDO
      ELSE
C*** SLACK IS UNDEFINED, SINCE MULTIPLIERS ARE UNDEFINED.
C*** USE THIS VALUE TO PREVENT PREMATURE TERMINATION
        SLACKN=ONE
      ENDIF
      GOTO 350
      END
C****************************************************************
      SUBROUTINE O8INIM
C***  INITIALIZE THE QUASI NEWTON UPDATE WITH A MULTIPLE OF THE 
C     IDENTITY
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER I,J
      SAVE
          DO I=1,N
            DO J=1,N
              A(J,I)=ZERO
            ENDDO
            A(I,I)=MATSC
            DIAG0(I)=MATSC
          ENDDO
          ACCINF(ITSTEP,27)=-ONE
          ACCINF(ITSTEP,14)=ONE
          IF ( .NOT. SILENT ) CALL O8INFO(20)
          RETURN
      END
C****************************************************************
C     COMPUTE THE DIRECTIONAL DERIVATIVE OF THE L1-PENALTY-FUNCTION
C****************************************************************
      SUBROUTINE O8DIRD
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER I
      DOUBLE PRECISION TERM,TERM1,O8SC1,O8SC3
      EXTERNAL O8SC1,O8SC3
      SAVE
C***** COMPUTE DIRECTIONAL DERIVATIVE OF ZANGWILL FUNCTION
  100 CONTINUE
      IF ( SCF .NE. ZERO ) THEN
        DIRDER=O8SC1(1,N,GRADF,D)*SCF
      ELSE
        DIRDER=ZERO
      ENDIF
      DO  I=1,NRES
        TERM=O8SC3(1,N,I,GRES,NX,D)*W(I)
        TERM1=RES(I)
        IF ( I .LE. NH ) THEN
          IF ( TERM1/GRESN(I) . LT. -TP3*EPSMAC ) THEN
            DIRDER=DIRDER-TERM
          ELSE
            IF ( TERM1/GRESN(I) .GT. TP3*EPSMAC ) THEN
              DIRDER=DIRDER+TERM
            ELSE
              DIRDER=DIRDER+ABS(TERM)
            ENDIF
          ENDIF
        ELSE
          IF ( BIND(I) .EQ. 1 ) THEN
            IF ( ABS(TERM1)/GRESN(I) .LE. TP3*EPSMAC ) THEN
              DIRDER=DIRDER-MIN(ZERO,TERM)
            ELSE
              IF ( TERM1/GRESN(I) .LT. -TP3*EPSMAC ) THEN
                IF ( TERM .GT. ZERO ) TERM=MIN(TERM,-RES(I)*W(I))
C*****  ONLY NEGATIVE VALUES OF THE CONSTRAINTS CONTRIBUTE TO THE
C*****  ZANGWILL FUNCTION
                DIRDER=DIRDER-TERM
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDDO
      RETURN
      END
C********************************************************************
      SUBROUTINE O8CUTD
C**** CUT D IF APPROPRIATE AND RESCALE
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER I
      DOUBLE PRECISION TERM,TERM1,O8VECN,O8SC1
      EXTERNAL O8VECN,O8SC1
      SAVE
      XNORM=O8VECN(1,N,X)
      TERM=BETA*(XNORM+ONE)
      DNORM=O8VECN(1,N,D)
      D0NORM=O8VECN(1,N,D0)
      DSCAL=ONE
      IF ( DNORM*D0NORM .NE. ZERO ) THEN
        COSPHI=O8SC1(1,N,D,D0)/(D0NORM*DNORM)
      ELSE
        COSPHI=ZERO
      ENDIF
      IF ( DNORM .GT. TERM ) THEN
C*****  D TOO LONG:  RESCALE
        TERM1=TERM/DNORM
        DNORM=TERM
        DSCAL=TERM1
        DO I= 1,N
          D(I)=D(I)*TERM1
          DD(I)=DD(I)*TERM1**2
        ENDDO
      ENDIF
C*** SINCE WE PROJECT THE RAY WITH RESPECT TO THE BOUNDS, BE SURE
C*** TO COMPUTE THE DIRECTIONAL DERIVATIVE CORRECTLY
C*** THEREFORE CORRECT D AND DD APPROPRIATELY
      DO I=1,N
        IF ( LLOW(I) .AND. X(I)+SIGSM*D(I) .LE. UG(I)
     F     ) THEN
          D(I)=ZERO
          DD(I)=MAX(ZERO,DD(I))
        ENDIF
        IF ( LUP(I) .AND. X(I)+SIGSM*D(I) .GE. OG(I) 
     F     ) THEN
         D(I)=ZERO
         DD(I)=MIN(ZERO,DD(I))
        ENDIF
      ENDDO
      DNORM=O8VECN(1,N,D)
      RETURN
      END
C********************************************************************
      SUBROUTINE O8SMAX
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER I
      LOGICAL EXIS
      SAVE
C****
C***** COMPUTE MAXIMUM STEPSIZE STMAXL SUCH THAT PROJECTION
C***** ON THE BOX OF LOWER AND UPPER BOUNDS CHANGES
C***** FOR SIG IN [0,STMAXL],IF SUCH EXISTS
      EXIS=.TRUE.
      DO I=1,N
        EXIS= EXIS .AND.( ( D(I) .EQ. ZERO )
     F        .OR. ( LUP(I) .AND. D(I) .GT. ZERO )
     F        .OR. ( LLOW(I) .AND. D(I) .LT. ZERO ) )
      ENDDO
      IF ( EXIS ) THEN
        STMAXL=SIGSM
        DO  I=1,N
          IF (LLOW(I) .AND. D(I) .LT. ZERO) THEN
            IF ( -D(I)*SIGLA .GE. X(I)-UG(I) ) THEN
              STMAXL=MAX(STMAXL,(X(I)-UG(I))/(-D(I)))
            ELSE
              STMAXL=SIGLA
            ENDIF
          ENDIF
          IF ( LUP(I) .AND. D(I) .GT. ZERO) THEN
            IF ( D(I)*SIGLA .GE. OG(I)-X(I) ) THEN
              STMAXL=MAX(STMAXL,(OG(I)-X(I))/D(I))
            ELSE
              STMAXL=SIGLA
            ENDIF
          ENDIF
        ENDDO
      ELSE
        STMAXL=SIGLA
      ENDIF
C***** BUT NEVER USE STEPSIZE LARGER THAN SIGLA
      STMAXL=MIN(SIGLA,STMAXL)
      RETURN
      END
C********************************************************************
      SUBROUTINE O8REST
C**** RESTORE THE BEST POINT FOUND SO FAR TO BE THE CURRENT NEW POINT
      INCLUDE 'O8COMM.INC'
      INTEGER J
      SAVE
        PHI1=PHIMIN
        PSI1=PSIMIN
        UPSI1=UPSIM
        SIG=SIGMIN
        FX1=FMINSA
        DO J=1,N
          X1(J)=XMIN(J)
        ENDDO
        DO J=1,NRES
          RES1(J)=RESMIN(J)
        ENDDO
      RETURN
      END
C********************************************************************
      SUBROUTINE O8SAVE
C**** SAVE THE BEST POINT FOUND SO FAR IN ...MIN VARIABLES
      INCLUDE 'O8COMM.INC'
      INTEGER I
      SAVE
        PHIMIN=PHI1
        UPSIM=UPSI1
        PSIMIN=PSI1
        FMINSA = FX1
        SIGMIN = SIG
        DO  I=1,N
          XMIN(I)=X1(I)
        ENDDO
        DO  I=1,NRES
          RESMIN(I)=RES1(I)
        ENDDO
      RETURN
      END
C********************************************************************
      SUBROUTINE O8EVAL(SIGACT,SIGRES,REJECT,ERROR)
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INCLUDE 'O8FINT.INC'
      DOUBLE PRECISION SIGACT,SIGRES
      LOGICAL REJECT,ERROR
C***  LOCAL
      INTEGER I,J
      DOUBLE PRECISION TERM
      SAVE
C**** EVALUATE THE FUNCTIONS AT THE NEW POINT
      SIG=SIGACT
      DO I =1,N
        X1(I)=X(I)+SIG*(D(I)+SIG*DD(I))
C****** PROJECT WITH RESPECT TO THE BOX-CONSTRAINTS
        IF ( LLOW(I) ) X1(I)=MAX(X1(I),UG(I))
        IF ( LUP(I) ) X1(I)=MIN(X1(I),OG(I))
      ENDDO
      REJECT=.FALSE.
      ERROR=.FALSE.
      SIGRES=SIG
      UPSI1=ZERO
      PSI1=ZERO
      IF ( BLOC ) CALL USER_EVAL(X1,-1)
C***** ONLY FUNCTION VALUES, FROM XTR=X1*XSC
      DO J = 1,NRES
        I=SORT(J)
        IF ( I .LE. NH ) THEN
          CFUERR(I)=.FALSE.
          CALL ESH(I,X1,RES1(I))
          IF ( CFUERR(I) ) THEN
            ERROR=.TRUE.
            RETURN
          ENDIF
          TERM=ABS(RES1(I))
        ELSE
          CFUERR(I)=.FALSE.
          CALL ESG(I-NH,X1,RES1(I))
          IF ( CFUERR(I) ) THEN
            ERROR=.TRUE.
            RETURN
          ENDIF
          TERM=-MIN(ZERO,RES1(I))
          IF ( RES1(I) .LT. -DELMIN .AND. BIND(I) .EQ. 0) THEN
            VIOLIS(0)=VIOLIS(0)+1
            VIOLIS(VIOLIS(0))=I
          ENDIF
        ENDIF
C***** VIOLIS IS THE LIST OF INEQUALITY-CONTRAINTS CURRENTLY
C***** NOT BINDING WHICH HAVE BEEN HIT DURING UNIDIMENSIONAL SEARCH
C***** SIGRES IS THE SMALLEST ZERO OF SECANTS THROUGH CONSTRAINTS
C***** WHICH CHANGE SIGN ALONG [X,X+D]
        UPSI1=UPSI1+TERM
        IF ( UPSI1 .GT. TAU0 .AND. PHASE .NE. -1  ) THEN
          REJECT=.TRUE.
          RETURN
        ENDIF
        PSI1=PSI1+TERM*W(I)
        IF ( RES1(I)*RES(I) .LT. ZERO .AND. SIG .LE. ONE
     F       .AND. ( BIND(I) .EQ. 0 .OR.
     F            (BIND(I) .EQ. 1 .AND. (ABS(RES(I))/GRESN(I)
     F             .GE. TP3*EPSMAC .OR. ABS(RES1(I))/GRESN(I)
     F             .GE. TP3*EPSMAC ) ) )
     F     )
     F      SIGRES=MIN(SIGRES,SIG*RES(I)/(RES(I)-RES1(I)))
      ENDDO
      IF ( PHASE .NE. -1 ) THEN
        FFUERR=.FALSE.
        CALL ESF(X1,FX1)
        IF ( FFUERR ) THEN
          ERROR=.TRUE.
          RETURN
        ENDIF
      ELSE
        FX1=ZERO
      ENDIF
      PHI1=SCF*FX1+PSI1
      RETURN
      END
C********************************************************************
C     DETERMINATION OF STEPSIZE BY AN ARMIJO-LIKE TEST FOR
C     DESCENT
C********************************************************************
      SUBROUTINE O8UNIM(SIG1TH)
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION SIG1TH
C**** SIG1TH THE FIRST PROPOSED STEPSIZE FOR SEARCHING ON THE ARC
C**** IF SIG=ONE DID'NT WORK
C
C   N = NUMBER OF VARIABLES
C   X = CURRENT POINT
C   D = DIRECTION OF DESCENT. DD = SECOND ORDER CORRECTION
C   X,D = INPUT
C   X0,D0 ETC. INFORMATION FROM PREVIOUS STEP
C
C   XNORM,DNORM = EUCLIDEAN LENGTH OF X AND D
C   STPTRM = 1 ON SUCCESS , =-1 OR =-2 OTHERWISE
C   SIG = COMPUTED STEPSIZE
C   IT IS ASSUMED THAT ONE IS ASYMPTOTICALLY OPTIMAL
C   SIGSM = SMALLEST ACCEPTABLE STEPSIZE
C   SIGLA = LARGEST ACCEPTABLE STEPSIZE
C   ALPHA = SMALLEST FEASIBLE REDUCTION FACTOR FOR STEPSIZE
C   DELTA = MULTIPLIER FOR DERIVATIVE SHOULD BE SMALLER THAN .25
C   BETA = MAXIMUM FEASIBLE INCREASE OF X-NORM FOR SIG=1
C   THETA = BOUND FOR COS(ANGLE(CURRENT DIRECTION, PREVIOUS DIRECTION))
C           IF OVERRIDDEN, STEPSIZE LARGER THAN ONE IS TRIED
C
C*********************************************************************
C*** LOCAL
      INTEGER I,L,J
      DOUBLE PRECISION TERM,MAXPHI
      DOUBLE PRECISION SIGRES ,DIFF
      DOUBLE PRECISION STEP(NSTEP)
      LOGICAL DESC,DESCRE,SMINFE,LAINFE,REJECT,ERROR
      SAVE
      DATA STEP/P5,TWOM2,38*TM1/
C*** PROJECTION OF D, RESCALING AND COMPUTING DIRDER HAS BEEN DONE 
C*** ALREADY
      L=0
      ERROR=.FALSE.
      PHI=SCF*FX+PSI
      SIG=SIG1TH
      VIOLIS(0)=0
      IF ( .NOT. SILENT ) CALL O8INFO(8)
100   CONTINUE
      L=L+1
      IF ( L .GT. NSTEP ) THEN
        IF ( ERROR .AND. .NOT. SILENT ) CALL O8MSG(24)
        STPTRM=-ONE
        SIG=ZERO
        RETURN
      ENDIF
C*****  COMPUTE A NEW X AND TEST FOR DESCENT
      CALL O8EVAL(SIG,SIGRES,REJECT,ERROR)
      IF ( ERROR ) THEN
        IF ( SIG .GT. ONE ) THEN
          CALL O8REST
          GOTO 200
        ELSE
          IF ( .NOT. SILENT ) CALL O8MSG(25)
          SIG=STEP(L)*SIG
          GOTO 100
        ENDIF
      ENDIF
      IF ( REJECT ) THEN
        IF ( SIG .GT. ONE ) THEN
          CALL O8REST
          GOTO 200
        ELSE
          SIG=STEP(L)*SIG
          GOTO 100
        ENDIF
      ENDIF
C
C
      IF ( .NOT. SILENT ) CALL O8INFO(9)
C*****  NEW FUNCTION VALUE
      IF ( SIG .GT. ONE ) THEN
        IF ( PHI1 .GE. PHIMIN ) THEN
C*****      PHI DOES'NT DECREASE FURTHER
          CALL O8REST
          GOTO 200
        ELSE
          IF ( SIG .LT. STMAXL ) THEN
            CALL O8SAVE
            SIG=MIN(STMAXL,SIG+SIG)
            GOTO 100
          ELSE
            GOTO 200
          ENDIF
        ENDIF
      ENDIF
      IF ( LASTCH .GE. ITSTEP-3 .OR. PHASE .NE. 2 
     F      .OR. SINGUL ) THEN
C***** REQUIRE MONOTONIC BEHAVIOUR
        DIFF=PHI-PHI1
      ELSE
        MAXPHI=PHI
        DO J=1,3
          MAXPHI=
     +    MAX(SCF*ACCINF(ITSTEP-J,2)+ACCINF(ITSTEP-J,4),MAXPHI)
        ENDDO
        DIFF=MAXPHI-PHI1
      ENDIF
      DESC = DIFF .GE. MIN(-SIG*DELTA*DIRDER,LEVEL)
      DESCRE = UPSI - UPSI1 .GE. SIG*DELTA**2*UPSI/TAUQP
      SMINFE = UPSI .LE. TAU0*P5 .AND. UPSI1 .LE. TAU0
      LAINFE = UPSI .GT. TAU0*P5
      IF ( DESC .AND. ( SMINFE .OR. ( LAINFE .AND. DESCRE ) ) ) THEN
C*****  GOLDSTEIN-ARMIJO DESCENT TEST SATISFIED
        IF ( SIG .EQ. ONE .AND. ( (COSPHI .GE. THETA .AND. SIG0
     F        .GE. ONE .AND. (PHASE+1)*(PHASE-2) .NE. 0
     F         .AND. .NOT. SINGUL) .OR. 
     F         DIFF .GE. -SIG*DELTA1*DIRDER )
C*****   1>=DELTA1  >> DELTA > 0
     F         .AND. STMAXL .GT. ONE .AND. UPSI .LT. TAU0*P5 )  THEN
C*****    TRY STEPSIZE LARGER THAN ONE
C*****    SAVE THE CURRENT POINT AS THE BEST ONE
          CALL O8SAVE
          SIG=MIN(STMAXL,SIG+SIG)
          GOTO 100
        ENDIF
        IF ( SIG .LE. ONE .AND. UPSI .GT. TAU0*P5 .AND.
     F         UPSI1 .GT. UPSI ) GOTO 300
        GOTO 200
      ELSE
        GOTO 300
      ENDIF
200   CONTINUE
C******   ACCEPT NEW X, SAVE OLD VALUES
      FX0 = FX
      FX = FX1
      UPSI0=UPSI
      UPSI=UPSI1
      PSI0=PSI
      PSI=PSI1
      STPTRM = ONE
      SIG0 = SIG
      DO I = 1,N
        X0(I)=X(I)
        D0(I)=D(I)
        X(I)=X1(I)
        DIFX(I)=X(I)-X0(I)
      ENDDO
      D0NORM=DNORM
      X0NORM=XNORM
      DO I=1,NRES
        RES(I)=RES1(I)
      ENDDO
      RETURN
C****** CONTINUE REDUCING SIG
300   CONTINUE
      IF ( SIGRES .LT. SIG ) THEN
        SIG=MIN(P5*SIG,MAX(STEP(L)*SIG,SIGRES))
      ELSE
        TERM=(DIFF-DIRDER*SIG)*TWO
        IF ( TERM .GT. EPSMAC*(SCF*ABS(FX)+PSI) ) THEN
          SIG=MIN(P5*SIG,MAX(STEP(L)*SIG,-DIRDER*SIG**2/TERM))
        ELSE
          SIG=STEP(L)*SIG
        ENDIF
      ENDIF
CTEST      DO I=1,N
CTEST        IF ( ABS(X1(I)-X(I)) .GE. SIGSM*(ABS(X(I))+TM2)) THEN
CTEST          GOTO 100
CTEST        ENDIF
CTEST      ENDDO
      IF ( SIG*MAX(ONE,DNORM) .GE. SIGSM  ) GOTO 100
      STPTRM = -ONE
      SIG=ZERO
      RETURN
      END
C*******************************************************************
C     SCALAR PRODUCT OF TWO VECTORS OR PARTS OF VECTORS
C*******************************************************************
      DOUBLEPRECISION FUNCTION O8SC1(I,J,A,B)
C     MULPILY TWO VECTORS
      IMPLICIT NONE
      INCLUDE 'O8CONS.INC'
      INTEGER I,J,K
      DOUBLE PRECISION A(*),B(*)
      DOUBLE PRECISION S
      SAVE
        IF ( I .GT. J ) THEN
          O8SC1=ZERO
          RETURN
        ELSE
          S=ZERO
          DO   K=I,J
            S=S+A(K)*B(K)
          ENDDO
          O8SC1=S
          RETURN
        ENDIF
      END
      DOUBLE PRECISION FUNCTION O8SC2(N,M,J,A,LDA,B)
C     MULTIPLY ROW J OF MATRIX A WITH VECTOR B
      IMPLICIT NONE
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION A,B,S
      INTEGER N,M,I,J,LDA
      DIMENSION A(LDA,*),B(*)
      SAVE
      S=ZERO
      DO  I=N,M
        S=S+A(J,I)*B(I)
      ENDDO
      O8SC2=S
      RETURN
      END
      DOUBLE PRECISION FUNCTION O8SC3(N,M,J,A,LDA,B)
C     MULTIPLY COLUMN J SECTION (N TO M) OF MATRIX A WITH VECTOR B
      IMPLICIT NONE  
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION A,B,S
      INTEGER N,M,I,J,LDA
      DIMENSION A(LDA,*),B(*)
      SAVE
      S=ZERO
      DO  I=N,M
        S=S+A(I,J)*B(I)
      ENDDO
      O8SC3=S
      RETURN
      END
C*****************************************************************
C     SUBPROGRAM FOR STRUCTURED OUTPUT OF A SUBMATRIX A(MA,NA)
C     EXTERNALLY DECLARED A(ME,NE) ON CHANNEL LOGNUM IN FIX OR 
C     FLOAT FORMAT
C     WITH HEADING "HEAD".
C     USES A FIXED FORMAT STRING WITH 70 PRINT COLUMNS
C*****************************************************************
      SUBROUTINE O8MDRU(A,ME,NE,MA,NA,HEAD,LOGNUM,FIX)
      IMPLICIT NONE
      INTEGER ME,NE,MA,NA,LOGNUM,I,J,JO,JU
      DOUBLE PRECISION A(ME,NE)
      LOGICAL FIX
      CHARACTER*40 HEAD
      INTEGER ANZ
      SAVE
      WRITE(LOGNUM,FMT='(/A40)')  HEAD
      ANZ=4
      JO=0
      DO WHILE ( JO .LT. NA )
        JU=JO+1
        JO=MIN(JU+ANZ-1,NA)
        WRITE(LOGNUM,FMT='(/''ROW/COLUMN'',4(6X,I3,6X))')
     *   (J,J=JU,JO)
        DO I=1,MA
          IF ( FIX ) THEN
            WRITE(LOGNUM,FMT='(3X,I4,3X,4(G14.7,1X))')
     *         I,(A(I,J),J=JU,JO)
          ELSE
            WRITE(LOGNUM,FMT='(3X,I4,3X,4(D14.7,1X))')
     *         I,(A(I,J),J=JU,JO)
          ENDIF
        ENDDO
      ENDDO
      RETURN
      END
C**********************************************************************
C********************************************************************
      SUBROUTINE O8EGPH(GPHI)
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION GPHI(NX)
      INTEGER I,J,L
      SAVE
C**** COMPUTE GRADIENT OF LAGRANGIAN
      DO  I=1,N
         GPHI(I)=GRADF(I) * SCF
         DO    J=1,NH
           GPHI(I)=GPHI(I)-U(J)*GRES(I,J)
         ENDDO
         DO    J=NH+1,ALIST(0)
           L=ALIST(J)
           IF( U(L) .GT. ZERO )
C**** INCLUDE CONSTRAINTS, WHOSE MULTIPLIERS ARE OF CORRECT SIGN ONLY
     F     GPHI(I)=GPHI(I)-GRES(I,L)*U(L)
         ENDDO
      ENDDO
      RETURN
      END
C***********************************************************************
C     QR-DECOMPOSITION OF MATRIX OF GRADIENTS OF BINDING CONSTRAINTS
C     THIS SET MAY BE EXPANDED USING MULTIPLE CALLS TO O8DEC.
C     NO EXIT ON SINGULAR R-FACTOR HERE. INFORMATION ON
C     THE DECOMPOSTION IS STORED IN BETAQ AND IN AND BELOW THE 
C     DIAGONAL OF QR. R-FACTOR IS STORED IN DIAG (DIAGONAL ) AND 
C     ABOVE THE DIAGONAL OF QR. CSCAL IS THE COLUMN SCALING OF THE
C     ORIGINAL MATRIX. COLUMN PIVOTING IS DONE HERE  AND IS STORED 
C     IN COLNO
C***********************************************************************
      SUBROUTINE O8DEC(NLOW,NRL)
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER NLOW,NRL,N1,N2
      INTEGER I,J,K,L,I1,I2,IPIV
      DOUBLE PRECISION SUM,TERM,DALPHA,DBETA,QRII,DL,O8SC3
      DOUBLE PRECISION QRI(NX),QRI0(NX),O8VECN,CURLE
      SAVE
      EXTERNAL O8VECN,O8SC3
      IF ( NLOW .GT. NRL ) RETURN
      IF ( NLOW .EQ. 1 ) RANK=0
      DL=ONE/(N+N+N)
      DO  I=NLOW,NRL
        DIAG(I)=ZERO
        BETAQ(I)=ZERO
        COLNO(I)=I
        DO J=1,N
          QRI(J)=GRES(J,ALIST(I))
        ENDDO
        CALL O8LEFT(A,QRI,QRI0,SUM,N)
        IF ( SUM .EQ. ZERO ) THEN
          CSCAL(I)=ONE
          COLLE(I)=ZERO
          DO J=1,N
            QR(J,I)=ZERO
          ENDDO
        ELSE
          DO J=1,N
            QRI(J)=QRI0(PERM(J))
          ENDDO
          TERM=ONE/SQRT(MAX(SUM,RHO**2))
          CSCAL(I)=TERM
          IF ( NLOW .GT. 1 ) THEN
            CALL O8HT(1,0,1,RANK,N,QR,BETAQ,QRI,QRI0)
            DO J=1,N
              QRI(J)=QRI0(J)
            ENDDO
          ENDIF
          DO J=1,N
            QR(J,I)=QRI(J)*TERM
          ENDDO
C*** COLLE : LENGTH OF REMAINING COLUMN  SQUARED
          COLLE(I)=(O8VECN(RANK+1,N,QRI)*TERM)**2
        ENDIF
      ENDDO
      IF ( NLOW .GT. 1 .AND. RANK .LT. NLOW-1 ) THEN
C   SHIFT ZERO BLOCK TO THE RIGHT
         I1=NLOW-1-RANK
         I2=NRL-NLOW+1
         DO I=1,MIN(I1,I2)
           IPIV=RANK+I
           K=NRL-I+1
           TERM=BETAQ(K)
           BETAQ(K)=BETAQ(IPIV)
           BETAQ(IPIV)=TERM
           J=COLNO(K)
           COLNO(K)=COLNO(IPIV)
           COLNO(IPIV)=J
           TERM=COLLE(K)
           COLLE(K)=COLLE(IPIV)
           COLLE(IPIV)=TERM
           DO J=1,N
             TERM=QR(J,K)
             QR(J,K)=QR(J,IPIV)
             QR(J,IPIV)=TERM
           ENDDO
         ENDDO
      ENDIF
      IF ( NLOW .GT. 1 ) THEN
        N1=RANK+1
        N2=N1+NRL-NLOW
      ELSE
        N1=NLOW
        N2=NRL
      ENDIF
      DO  I=N1,N2
C  SEARCH FOR PIVOT COLUMN
        IPIV=I
        CURLE=COLLE(I)
        DO J=I+1,N2
          IF ( COLLE(J) .GT. CURLE ) THEN
            CURLE=COLLE(J)
          ENDIF
        ENDDO
        DO J=N2,I,-1
          IF ( COLLE(J) .GE. CURLE/THREE ) IPIV=J
        ENDDO
C  INTERCHANGE COLUMNS EXPLICITLY, IF NECESSARY
C  MAKE INTERCHANGES CONTINUOUS WITH RESPECT TO X
        IF ( IPIV .NE. I ) THEN
          J=COLNO(I)
          COLNO(I)=COLNO(IPIV)
          COLNO(IPIV)=J
          TERM=COLLE(I)
          COLLE(I)=COLLE(IPIV)
          COLLE(IPIV)=TERM
          DO K=1,N
            TERM=QR(K,I)
            QR(K,I)=QR(K,IPIV)
            QR(K,IPIV)=TERM
          ENDDO
        ENDIF
C
        SUM=ZERO
        DO   J=I,N
          TERM=QR(J,I)
          QRI(J)=TERM
          SUM=TERM*TERM+SUM
        ENDDO
        IF(SUM .LE. RHO**2 ) THEN
C   SET TINY VALUES TO ZERO
          DO J=I,N2
            COLLE(J)=ZERO
            DO K=I,N
              QR(K,J)=ZERO
            ENDDO
          ENDDO
          RANK=I-1
          RETURN
        ENDIF
        QRII=QRI(I)
        DALPHA=-SQRT(SUM)
        IF ( ABS(QRII) .LE. -DALPHA*DL ) THEN
          TERM=ZERO
          DO J=I+1,N
            IF ( ABS(QRI(J)) .GT. TERM ) THEN
              TERM=ABS(QRI(J))
              L=J
            ENDIF
          ENDDO
          K=PERM1(I)
          PERM1(I)=PERM1(L)
          PERM1(L)=K
        ENDIF
        IF(QRII .LT. ZERO)      DALPHA=-DALPHA
        DBETA =ONE/(SUM-QRII*DALPHA)
        DIAG(I)=DALPHA
        BETAQ(I)=DBETA
        QRI(I)=QRII-DALPHA
        QR(I,I)=QRI(I)
        RANK=I
        I1=I+1
        DO  J=I1,N2
          SUM=DBETA*O8SC3(I,N,J,QR,NX,QRI)
          DO   K=I,N
            QR(K,J)=QR(K,J)-SUM*QRI(K)
          ENDDO
          COLLE(J)=COLLE(J)-QR(I,J)**2
        ENDDO
      ENDDO
      RETURN
      END
C******************************************************************
      SUBROUTINE O8HT(ID,INCR,IS1,IS2,M,A,BETA,B,C)
C     APPLICATION OF HOUSEHOLDER TRANSFORMATIONS STORED
C     IN THE LOWER OR STRICT LOWER (IF INCR=0 OR 1 RESP.)
C     TRIANGLE OF A AND IN THE VECTOR BETA ON B GIVING C.
C     ONLY COLUMNS IS1 TO IS2 ARE USED IN FORWARD MANNER
C     IF ID > 0,BACKWARDS OTHERWISE.
C     ROWS IS1 TO M OF C ARE CHANGED ONLY
      IMPLICIT NONE
      DOUBLE PRECISION A,BETA,B,C,SUM,O8SC3
      INTEGER ID,INCR,IS1,IS2,M,I,J,K,IT
      INCLUDE 'O8PARA.INC'
      INCLUDE 'O8CONS.INC'
      DIMENSION A(NX,*),BETA(*),B(*),C(*)
      SAVE
      DO  I=1,M
        C(I)=B(I)
      ENDDO
      IF(IS1 .GT. M)       RETURN
      IF(IS2 .LT. IS1)      RETURN
      DO    I=IS1,IS2
        IT=I
        IF(ID .LT. 0)         IT=IS2-IT+IS1
C       IT=INDEX OF TRANSFORMATION
        J=IT+INCR
        SUM=BETA(IT)*O8SC3(J,M,IT,A,NX,C)
        DO  K=J,M
          C(K)=C(K)-SUM*A(K,IT)
        ENDDO
      ENDDO
      RETURN
      END
C*********************************************************************
C     SOLVE TRIANGULAR SYSTEM R*X=B, R DEFINED BY HOUSEHOLDER-QR-
C     DECOMPOSITION DECOMP (WITH COLUMN SCALING)
C*********************************************************************
      SUBROUTINE O8SOL(NLOW,NUP,B,X)
      IMPLICIT NONE
      INTEGER NLOW,NUP
      INCLUDE 'O8PARA.INC'
      INCLUDE 'O8CONS.INC'
      INCLUDE 'O8RDAT.INC'
      DOUBLE PRECISION B(*),X(*),XL(NX)
      SAVE
C*******
      DOUBLE PRECISION SUM
      INTEGER I,J
      DO I=NUP,NLOW,-1
        SUM=ZERO
        DO J=I+1,NUP
          SUM=SUM+QR(I,J)*XL(J)
        ENDDO
        XL(I)=(B(I)-SUM)/DIAG(I)
      ENDDO
      DO  I=NLOW,NUP
        X(I)=XL(I)*CSCAL(COLNO(I))
      ENDDO
C*** THERE MUST FOLLOW INTERCHANGE OF X AS GIVEN BY COLNO
C    E.G. XX(COLNO(I))=X(I)
C***
      RETURN
      END
C*********************************************************************
C     SOLVE TRIANGULAR SYSTEM R(TRANSPOSE)*X=B, R DEFINED BY 
C     HOUSEHOLDER-QR-DECOMPOSITION DECOMP (WITH COLUMN SCALING)
C*********************************************************************
      SUBROUTINE O8SOLT(NLOW,NUP,B,X)
      IMPLICIT NONE
      INTEGER NLOW,NUP
      INCLUDE 'O8PARA.INC'
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION B(*),X(*)
      INCLUDE 'O8RDAT.INC'
C********
      INTEGER I,J
      DOUBLE PRECISION SUM
      SAVE
      DO I=NLOW,NUP
C*** B HAS BEEN PERMUTED ALREADY !
        X(I)=B(I)*CSCAL(COLNO(I))
      ENDDO
      DO I=NLOW,NUP
        SUM=ZERO
        DO J=NLOW,I-1
          SUM=SUM+QR(J,I)*X(J)
        ENDDO
        X(I)=(X(I)-SUM)/DIAG(I)
      ENDDO
      RETURN
      END
C***************************************************************
C     LENGHT OF VECTOR (A,B). NUMERICALLY STABLE VERSION WITH
C     OVERFLOW / UNDERFLOW SAVEGUARD
C*****************************************************************
      DOUBLE PRECISION FUNCTION  O8DSQ1(A,B)
      IMPLICIT NONE
      DOUBLE PRECISION A,B,A1,B1
      INCLUDE 'O8CONS.INC'
      SAVE
      A1=ABS(A)
      B1=ABS(B)
      IF ( A1 .GT. B1 ) THEN 
        O8DSQ1=A1*SQRT(ONE+(B1/A1)**2)
      ELSE
        IF ( B1 .GT. A1 ) THEN
          O8DSQ1=B1*SQRT(ONE+(A1/B1)**2)
        ELSE
          O8DSQ1=A1*SQRT(TWO)
        ENDIF
      ENDIF
      RETURN
      END
C*******************************************************************
      SUBROUTINE O8UPD(R,Z,Y,N,FAIL)
      IMPLICIT NONE
      INCLUDE 'O8PARA.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER N,I,J,I1
      LOGICAL FAIL
      DOUBLE PRECISION R(NX,*),Z(*),Y(*)
      DOUBLE PRECISION SDIAG(NX),RN1(NX),W(NX)
      DOUBLE PRECISION YL,ZL,WL,WN1,AI,BI,H,O8DSQ1
      INTRINSIC ABS,SQRT
      SAVE
      EXTERNAL O8DSQ1
C     O8UPD  COMPUTES  THE UPPER TRIANGULAR CHOLESKY-FACTOR
C     R1 OF
C               R(TRANSPOSE)*R+Z*Z(TRANSPOSE)-Y*Y(TRANSPOSE)
C     AND RESTORES IT IN R. THE STRICT LOWER TRIANGLE OF R RE-
C     MAINS UNCHANGED.
C     FAIL=TRUE IF THE DECOMPOSITION DOES'NT EXIST, STOP ON DIMENSION
C     ERROR, FAIL=FALSE ON SUCCESS.
      IF ( N .GT. NX ) THEN
        STOP 'O8UPD WRONG CALL'
      ENDIF
      FAIL=.FALSE.
C     SAVE SUBDIAGONAL
      DO    I=1,N-1
      SDIAG(I)=R(I+1,I)
      R(I+1,I)=ZERO
      ENDDO
C     STEP ONE: INCLUDE Z*Z(TRANSPOSE)
      ZL=ZERO
      DO   I=1,N
        ZL = ZL + Z(I)**2
      ENDDO
      IF ( ZL .NE. ZERO ) THEN
C     SOLVE W(TRANSPOSE)*R=Z(TRANSPOSE)
      CALL O8LEFT(R,Z,W,WL,N)
      WL=SQRT(WL+ONE)
C     U(2)*U(3)*...*U(N)*W = ( NORM(W),0,..,0)(TRANSPOSE)
C     U(I) ROTATIONS
      DO   I=N,2,-1
      IF ( W(I) .NE. ZERO ) THEN
        I1=I-1
        AI=W(I1)
        BI=W(I)
        W(I1)=O8DSQ1(AI,BI)
        AI=AI/W(I1)
        BI=-BI/W(I1)
        R(I,I1)=BI*R(I1,I1)
        R(I1,I1)=AI*R(I1,I1)
        DO   J=I,N
          H = AI*R(I1,J) - BI*R(I,J)
          R(I,J) = BI*R(I1,J) + AI*R(I,J)
          R(I1,J) = H
        ENDDO
      ENDIF
      ENDDO
C     R=D*R, D=DIAG(WL,1,...,1), R NOW HESSENBERG
      DO    I=1,N
      R(1,I)=R(1,I)*WL
      ENDDO
C     R=U(N-1)*...*U(1)*R NOW UPPER TRIANGULAR,
C     U(I)  GIVENS-ROTATIONS
      DO    I=1,N-1
        I1=I+1
        AI=R(I,I)
        BI=-R(I1,I)
        H=O8DSQ1(AI,BI)
        IF ( H .NE. ZERO ) THEN
          AI=AI/H
          BI=BI/H
          R(I,I)=H
          R(I1,I)=ZERO
          DO   J=I+1,N
            H = AI*R(I,J) - BI*R(I1,J)
            R(I1,J) = BI*R(I,J) + AI*R(I1,J)
            R(I,J) = H
          ENDDO
        ENDIF
      ENDDO
      ENDIF
C     STEP TWO :  INCLUDE -Y*Y(TRANSPOSE)
      YL=ZERO
      DO   I=1,N
        YL = YL + Y(I)**2
      ENDDO
      IF ( YL .NE. ZERO ) THEN
        CALL O8LEFT(R,Y,W,WL,N)
        IF ( WL .GE. ONE ) THEN
          FAIL=.TRUE.
        ELSE
          WL=SQRT(ABS(ONE-WL))
          WN1=WL
C******************************************************
C      ( R(NEW) ,0 )                (    R  , W )
C      (-----------) = U(1)*...U(N)*(-----------)
C      (Y(TRANSP),1)                ((0,..,0),WL)
C******************************************************
          DO    I=N,1,-1
            AI=WN1
            BI=W(I)
            WN1=O8DSQ1(AI,BI)
            IF ( WN1 .NE. ZERO ) THEN
              AI=AI/WN1
              BI=BI/WN1
              RN1(I)=BI*R(I,I)
              R(I,I)=AI*R(I,I)
              DO    J=I+1,N
                H = AI*R(I,J) - BI*RN1(J)
                RN1(J) = BI*R(I,J) + AI*RN1(J)
                R(I,J) = H
              ENDDO
            ENDIF
          ENDDO
        ENDIF
      ENDIF
C     RESTORE SUBDIAGONAL
      DO   I=1,N-1
        R(I+1,I)=SDIAG(I)
      ENDDO
      RETURN
      END
C***********************************************************************
      SUBROUTINE O8RGHT(A,B,Y,YL,N)
      IMPLICIT NONE
      INCLUDE 'O8PARA.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER N,I,J
      DOUBLE PRECISION A(NX,*),B(*),Y(*),YL,H
      SAVE
C     O8RGHT ASSUMES THAT THE CHOLESKY-FACTOR OF A
C     A=R(TRANSPOSE)*R IS STORED IN THE UPPER HALF OF A.
C     B IS A RIGHT HAND SIDE. O8RGHT SOLVES
C         R*Y = B
C     YL=NORM(Y)**2
      YL=ZERO
      DO   I=N,1,-1
        H=B(I)
        DO    J=I+1,N
          H = H - A(I,J)*Y(J)
        ENDDO
        H=H/A(I,I)
        Y(I)=H
        YL = H**2 + YL
      ENDDO
      RETURN
      END
C**********************************************************************
      SUBROUTINE O8LEFT(A,B,Y,YL,N)
      IMPLICIT NONE
      INCLUDE 'O8PARA.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER N,I,J
      DOUBLE PRECISION A(NX,*),B(*),Y(*),YL,H
      SAVE
C     O8LEFT ASSUMES THAT THE CHOLESKY-FACTOR OF A
C     A=R(TRANSPOSE)*R IS STORED IN THE UPPER HALF OF A.
C     B IS A RIGHT HAND SIDE. O8LEFT SOLVES
C         R(TRANSPOSE)*Y = B
C     YL=NORM(Y)**2
      YL=ZERO
      DO   I=1,N
        H=B(I)
        DO    J=1,I-1
          H = H - A(J,I)*Y(J)
        ENDDO
        H=H/A(I,I)
        Y(I)=H
        YL = H**2 + YL
      ENDDO
      RETURN
      END
C******************************************************************
      DOUBLE PRECISION FUNCTION O8VECN(NL,NM,X)
      IMPLICIT NONE
      INCLUDE 'O8CONS.INC'
C*** EUCLIDEAN NORM OF X , AVOID OVERFLOW
      INTEGER NL,NM,I
      DOUBLE PRECISION X(*)
      DOUBLE PRECISION XM,H
      INTRINSIC MAX,ABS,SQRT
      SAVE
      IF ( NM .LT. NL ) THEN
        O8VECN=ZERO
        RETURN
      ENDIF
      XM=ABS(X(NL))
      DO I=NL+1,NM
        XM=MAX(XM,ABS(X(I)))
      ENDDO
      IF ( XM .EQ. ZERO ) THEN
        O8VECN=ZERO
        RETURN
      ELSE
        H=ZERO
        DO I=NL,NM
          H=H+(X(I)/XM)**2
        ENDDO
        O8VECN=XM*SQRT(H)
        RETURN
      ENDIF
      END
C***************************************************************
C********************************************************************
C     SOLUTION OF EXTENDED QUADRATIC PROGRAM
C     SCF*GRADF(X)*D+(1/2)*D*A*D+SUMME( TAUQP*D(I) +( MY/2)*D(I)**2)
C     MINIMAL SUBJECT TO
C     D(I) .GE. 0, I=1,...,NR
C     (GRES(.,J)*D+RES(J))+VZ*D(J)=0, J=1,...,NH VZ=-SIGN(RES(J))
C     (GRES(.,ALIST(J)))*D+RES(ALIST(J)))+D(J) .GE. 0, J=NH+1,....,NR
C     THE WEIGHT TAUQP IS ADAPTED DURING SOLUTION
C     THE QUASI-NEWTON-MATRIX A IS TAKEN FROM O8COMM.INC
C     A IS REGULARIZED IF NOT SUFFICIENTLY WELL CONDITIONED
C     THE RESULTING D(1+NR),...,D(N+NR) IS A DIRECTION OF DESCENT FOR
C     THE ZANGWILL FUNCTION OF THE CORRESPONDING NONLINEAR
C     OPTIMIZATION PROBLEM
C     F(X)=MIN, RES(J)=0, J=1,..NH, RES(J) .GE. 0 , J=NH+1,NRES
C     AT THE CURRRENT POINT X IF THE WEIGHT TAUQP IS CHOSEN 
C     APPROPRIATELY
C     THE QUADRATIC PROGRAMMING PROBLEM IS SOLVED USING THE METHOD
C     OF GOLDFARB AND IDNANI
C     VARIABLES ARE STORED IN XD (SOLUTION) AND UD (MULTIPLIERS)
C     IN THE FOLLOWING ORDER XD=( D(J), J=1,NR; D=DIRECT. OF DESC.)
C     UD = ( MULTIPLIERS FOR D(I) .GE. 0 , I=1,..,NR ;
C     MULTIPLIERS FOR FOR EQUALITY CONSTRAINTS , 
C     MULTIPLIERS FOR THE GENERAL INEQUALITY CONSTRAINTS )
C**********************************************************************
      SUBROUTINE O8QPDU
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INCLUDE 'O8QPDU.INC'
      INTEGER NDUALM,MDUALM,NDUAL,MI,ME,IQ
      PARAMETER (NDUALM=NX+NRESM,MDUALM=NRESM*2)
      DOUBLE PRECISION NP,RNORM,RLOW,XJ,DDUAL,R,UD
      DOUBLE PRECISION G0(NDUALM),CI0(MDUALM),CII(MDUALM),
     F       CEI(NDUALM),
     F       XD(NDUALM),S(MDUALM),Z(NDUALM),VR(MDUALM)
      DOUBLE PRECISION XDOLD(NDUALM),UDOLD(MDUALM),UD1
      INTEGER AI(MDUALM),IAI(MDUALM),IAEXCL(MDUALM),AIOLD(MDUALM)
      DOUBLE PRECISION Y(NDUALM),MULT(NRESM)
      COMMON /O8DUPA/RNORM,RLOW,NDUAL,MI,ME,IQ
      COMMON /O8QPUP/XJ(NDUALM,NDUALM),DDUAL(NDUALM),R(NDUALM,NDUALM),
     F                NP(NDUALM),UD(MDUALM),UD1(MDUALM)
      DOUBLE PRECISION INFE1,S1,S2,TINY,
     F    MY,ZZ,SS,SU,T,T1,T2,F,PSID,C1,C2,CDIAG,O8SC1,TERM,
     F       SU1,SU2,CONDR,INFINY,TERM1,O8VECN,
     F       DIFF0
      INTEGER I,J,K,IP,L,QPDEL(0:MDUALM),INCR
      LOGICAL WLOW
      INTEGER IPTR,IQTR,AITR(MDUALM)
      DOUBLE PRECISION SSTR,RIITR
      COMMON/O8QPTR/SSTR,RIITR,IPTR,IQTR,AITR
      SAVE 
      NDUAL=N+NR
C*** NUMBER OF EQUALITY CONSTRAINTS IN QP-PROBLEM
      ME=NH
C*** QP INEQUALITY CONSTRAINTS = ACTIVE CONSTRAINTS - 
C*** EQUALITY-CONSTRAINTS + SLACK'S
      MI=2*NR-NH
      INFINY=EPSMAC/TOLMAC
      IF ( ANALYT ) THEN
        TINY=2*NR*EPSMAC*TP3
      ELSE
        TINY=2*NR*MAX(EPSDIF,EPSMAC*TP3)
      ENDIF
      QPTERM=0
      DO I=1,NR
C*** CHECK GRADIENTS OF ACTIVE CONSTRAINTS AGAINST ZERO
        DO J=1,N
          Y(J)=GRES(J,ALIST(I))
        ENDDO
        MULT(I)=ONE
        IF ( O8VECN(1,N,Y) .EQ. ZERO ) THEN
          MULT(I)=ZERO
          IF ( .NOT. SILENT ) CALL O8MSG(8)
        ENDIF
      ENDDO
C*** RESTART POINT IN CASE OF INCREASE OF TAUQP
   10 CONTINUE
C*******  INITIALIZE MATRICES J AND R
      DO I=1,NDUAL
        DDUAL(I)=ZERO
        DO J=1,NDUAL
          R(J,I)=ZERO
          XJ(J,I)=ZERO
        ENDDO
      ENDDO
      RNORM=ONE
      RLOW=ONE
      TERM1=ZERO
      DO I=1,NRES
        U(I)=ZERO
        IF ( W(I) .GT. TERM1 ) TERM1=W(I)
      ENDDO
      ACCINF(ITSTEP,19)=CLOW
      ACCINF(ITSTEP,20)=TERM1
      ACCINF(ITSTEP,31)=TAUQP
      DO I=1,ME+MI
        UD(I)=ZERO
      ENDDO
      C1=ABS(A(1,1))
      DO I=1,N
        C1=MAX(C1,ABS(A(I,I)))
      ENDDO
      C1=C1*TP1
C**** WE REQUIRE MUCH MORE REGULARITY OF A IN THE SINGULAR CASE
      DO I=1,N
        IF ( ABS(A(I,I)) .LT. SQRT(RHO1)*C1 ) A(I,I)=SQRT(RHO1)*C1
      ENDDO
C**** INVERT THE CHOLESKY-FACTOR AND STORE IN XJ ( IDNANIS J-MATRIX)
      CALL O8RINV(NX,N,A,NDUALM,NDUAL,XJ)
      C1=ABS(A(1,1))
      INCR=NR
      C2=ABS(XJ(1+INCR,1+INCR))
      DO I=1,N
        C1=MAX(C1,ABS(A(I,I)))
        C2=MAX(C2,ABS(XJ(I+INCR,I+INCR)))
      ENDDO
      MY=ZERO
      DO I=1,N
        DO J=I,N
           MY=MY+A(I,J)**2
        ENDDO
      ENDDO
      MY=MY/N
      CDIAG=ONE/SQRT(MY)
      DO  I=1,INCR
        XJ(I,I)=CDIAG
      ENDDO
      DO I=1,NDUAL
        IF ( I .GT. INCR )  G0(I)=GRADF(I-INCR)*SCF
        IF ( I .LE. INCR )  G0(I)=TAUQP
      ENDDO
C*** COMPUTE UNCONSTRAINED SOLUTION
C*** THE CHOLESKY-FACTOR OF A IS STORED IN THE UPPER TRIANGLE
      DO I=1,N
        SU=ZERO
        DO J=1,I-1
          SU=SU+A(J,I)*Y(J+INCR)
        ENDDO
        Y(I+INCR)=(G0(I+INCR)-SU)/A(I,I)
      ENDDO
      DO I=N,1,-1
        SU=ZERO
        DO J=I+1,N
          SU=SU+A(I,J)*Y(J+INCR)
        ENDDO
        Y(I+INCR)=(Y(I+INCR)-SU)/A(I,I)
      ENDDO
      DO I=1,INCR
C****** INITIALLY ASSUME THE SLACKS BEING ZERO
        Y(I)=ZERO
      ENDDO
      DO I=1,NDUAL 
        XD(I)=-Y(I)
      ENDDO
C****** UNCONSTRAINED MINIMIZER OF THE QP: SLACKS COME FIRST
      F=P5*O8SC1(1,NDUAL,G0,XD)
C****** DEFINE THE INITIAL WORKING SET: ALL SLACKS ARE AT THEIR 
C****** LOWER BOUNDS 
      IQ=NR
      DO I=1,IQ
        AI(I)=I
        R(I,I)=ONE
        UD(I)=TAUQP
      ENDDO
      RNORM=ONE
      RLOW=ONE
C****** INTRODUCTION OF EQUALITY CONSTRAINTS
      DO I=1,ME
        DO  J =1,IQ
          UD1(J)=UD(J)
        ENDDO
   20   CONTINUE
        UD1(IQ+1)=ZERO
C***** AN EQUALITY CONSTRAINT IS INDICATED BY THE NEGATIVE INDEX
        AI(IQ+1)=-NR-I
        DO  J=1,N
C*** ME=NH AND ALIST(I)=I FOR I=1,..,NH
          CEI(J+INCR)=GRES(J,I)
        ENDDO
        DO J=1,INCR
          CEI(J)=ZERO
        ENDDO
        CEI(I)=ONE
        IF ( RES(I) .GT. ZERO ) CEI(I)=-ONE
        DO  J=1,NDUAL
          NP(J)=CEI(J)
        ENDDO
        CALL O8ZUP(Z)
        IF ( IQ .NE. 0 ) CALL O8RUP(VR)
C*******|Z|=0?
COLD        ZZ=O8SC1(1,NDUAL,Z,Z)
        ZZ=O8VECN(1,NDUAL,Z)
        TERM=O8SC1(1,NDUAL,Z,NP)
COLD        IF  (ZZ .NE. ZERO .AND. TERM .GT. ZERO )         THEN
        IF  (ZZ .GE. TINY*RNORM .AND. TERM .GT. ZERO )         THEN
          T2=(-O8SC1(1,NDUAL,NP,XD)-RES(I))/TERM
        ELSEIF ( (-O8SC1(1,NDUAL,NP,XD)-RES(I)) .GE. ZERO ) THEN
          T2=INFINY
        ELSE
          T2=-INFINY
        ENDIF
C***** IN ADDITION OF AN EQUALITY CONSTRAINT, T2 MAY BE 
C***** POSITIVE OR NEGATIVE
        IF ( IQ .NE. 0 ) CALL O8RUP(VR)
        L=0
        IF ( T2 .GT. ZERO ) THEN
          T1=INFINY
          DO K=1,IQ
            IF(VR(K) .GT. ZERO .AND. AI(K) .GT. 0 )     THEN
              IF(UD1(K)/VR(K) .LT. T1)      THEN
                T1=UD1(K)/VR(K)
              ENDIF
            ENDIF
          ENDDO
          T=MIN(T1,T2)
        ELSE
          T1=INFINY
          DO K=1,IQ
            IF(VR(K) .LT. ZERO .AND. AI(K) .GT. 0 )     THEN
              IF(UD1(K)/ABS(VR(K)) .LT. T1)      THEN
                T1=UD1(K)/ABS(VR(K))
              ENDIF
            ENDIF
          ENDDO
          T1=-T1
          T=MAX(T1,T2)
C**** T NOW NEGATIVE 
        ENDIF
C*** ADD CONSTRAINT , OTHERWISE WE MUST FIRST DELETE SOME
C*** INEQUALITY CONSTRAINT WITH NEGATIVE MULTIPLIER
C*** FIRST DELETE THEN ADD!
        IF ( ABS(T) .GE. INFINY ) GOTO 2000
        IF(ABS(T2) .GE. INFINY )       THEN
C***** PURELY DUAL STEP
          DO      K=1,IQ
            UD1(K)=UD1(K)+T*(-VR(K))
            IF ( UD1(K) .LT. ZERO .AND. AI(K) .GT. 0 ) UD1(K)=ZERO
          ENDDO
          UD1(IQ+1)=UD1(IQ+1)+T
          QPDEL(0)=0
          DO J=1,IQ
            IF ( UD1(J) .LE. TINY .AND. AI(J) .GT. 0 ) THEN
              QPDEL(0)=QPDEL(0)+1
              QPDEL(QPDEL(0))=AI(J)
            ENDIF
          ENDDO
          DO K=1,QPDEL(0)
            L=QPDEL(K)
            IAI(L)=L
            CALL O8DLCD(AI,L)
          ENDDO
          GOTO 20
        ENDIF
        DO K=1,NDUAL
          XD(K)=XD(K)+T*Z(K)
        ENDDO
        DO K=1,IQ
          UD1(K)=UD1(K)+T*(-VR(K))
          IF ( UD1(K) .LT. ZERO .AND. AI(K) .GT. 0 ) UD1(K)=ZERO
        ENDDO
        UD1(IQ+1)=UD1(IQ+1)+T
        F=F+T*O8SC1(1,NDUAL,Z,NP)*(P5*T+UD1(IQ+1))
        IF ( ABS(T2-T1) .LE. TINY ) THEN
          QPDEL(0)=0
          DO J=1,IQ
            IF ( UD1(J) .LE. TINY .AND. AI(J) .GT. 0 ) THEN
              QPDEL(0)=QPDEL(0)+1
              QPDEL(QPDEL(0))=AI(J)
            ENDIF
          ENDDO
          DO K=1,QPDEL(0)
            L=QPDEL(K)
            IAI(L)=L
            CALL O8DLCD(AI,L)
          ENDDO
          AI(IQ+1)=-I-NR
          CALL O8ADCD
        ELSEIF ( T .EQ. T2 ) THEN
          AI(IQ+1)=-I-NR
          CALL O8ADCD
        ELSE
          QPDEL(0)=0
          DO J=1,IQ
            IF ( UD1(J) .LE. TINY .AND. AI(J) .GT. 0 ) THEN
              QPDEL(0)=QPDEL(0)+1
              QPDEL(QPDEL(0))=AI(J)
            ENDIF
          ENDDO
          DO K=1,QPDEL(0)
            L=QPDEL(K)
            IAI(L)=L
            CALL O8DLCD(AI,L)
          ENDDO
          GOTO 20
        ENDIF
        DO J=1,IQ
          UD(J)=UD1(J)
        ENDDO   
      ENDDO
C****** SET IAI=K\AI
      DO I=1,MI
        IAI(I)=I
      ENDDO
C****** STEP 1
   50 CONTINUE
C***  AI = QP - WORKING SET , IAI(I)=0 IF I IN AI
      DO I=1,IQ
        IP=AI(I)
        IF ( IP .GT. 0 ) IAI(IP)=0
      ENDDO
C****** S(XD)=CI(TRANS)*XD+CI0 >= 0 ?
      PSID=ZERO
C*** PSID : THE MEASURE OF INFEASIBILITY
      DO I=1,MI
C*** IAEXCL: IF = 0, EXCLUDE FROM ADDITION IN THIS CYCLE
        IAEXCL(I)=1
        SU=ZERO
C*** NUMBERS OF INEQUALITY CONSTRAINTS:
C*** I=1,...,NR CORRESPONDS TO THE CONSTRAINTS V>=0, U_A>=0
C*** I=NR+1,....,MI TO THE REGULARIZED GENERAL INEQUALITIES
        IF ( I .GT. NR ) THEN
          K=ALIST(I+NH-INCR)
          DO J=1,N
            CII(J+INCR)=GRES(J,K)
          ENDDO
          DO J=1,INCR
            CII(J)=ZERO
          ENDDO
          CII(NH+I-INCR)=ONE
          CI0(I)=RES(K)
        ELSE
          DO J=1,NDUAL
            CII(J)=ZERO
          ENDDO
          CI0(I)=ZERO
          CII(I)=ONE
        ENDIF
        SU=O8SC1(1,NDUAL,CII,XD)+CI0(I)
        S(I)=SU
        PSID=PSID+MIN(ZERO,SU)
      ENDDO
      DO I=1,IQ
        UDOLD(I)=UD(I)
        AIOLD(I)=AI(I)
      ENDDO
      DO  I=1,NDUAL
        XDOLD(I)=XD(I)
      ENDDO
   60 CONTINUE
      SS=ZERO
      IP=0
C*** INTRODUCE MOST VIOLATED INEQUALITY CONSTRAINT
      DO I=1,MI
        IF(S(I) .LT. SS .AND. IAI(I) .NE. 0 .AND. IAEXCL(I) .NE.0)THEN
          SS=S(I)
          IP=I
        ENDIF
      ENDDO
      IF ( IQ .GT. 1 ) THEN
        CONDR=RNORM/RLOW
      ELSE
        CONDR=ONE
      ENDIF
C***
C***
      IF (ABS(PSID) .LE. TINY*(C1*C2+CONDR) .OR. IP .EQ. 0) THEN
C****   SUCCESSFUL TERMINATION OF QP-SOLVER FOR CURRENT TAUQP
        IF ( ABS(PSID) .GT. TINY*(C1*C2+CONDR) .AND. .NOT. SILENT ) 
     F    CALL O8MSG(10)
        QPTERM=1
        ACCINF(ITSTEP,30)=ONE
        ACCINF(ITSTEP,13)=CONDR
        ACCINF(ITSTEP,14)=C1*C2
        DO I=1,N
          D(I)=XD(I+INCR)
        ENDDO
CNEW : DNORM ADDED
        DNORM=O8VECN(1,N,D)
        INFEAS=ZERO
        DO I=1,INCR
          INFEAS=INFEAS+ABS(XD(I))
        ENDDO
C******* L1-NORM OF SLACK VARIABLES
        ACCINF(ITSTEP,31)=TAUQP
        ACCINF(ITSTEP,32)=INFEAS
        WLOW=.FALSE.
        SU1=ZERO
        SU2=ZERO
        DO I=1,IQ
          IF ( AI(I) .LT. 0 ) THEN
            U(-(AI(I)+NR))=UD(I)
          ELSE
           IF ( AI(I) .GT. NR ) U(ALIST(AI(I)+NH-NR))=UD(I)
          ENDIF
        ENDDO
        TERM1=ZERO
        DO J=1,N
          NP(J)=GRADF(J)*SCF
        ENDDO
        DO I=1,NRES
          DO J=1,N
            NP(J)=NP(J)-GRES(J,I)*U(I)
          ENDDO
        ENDDO
        B2N=O8VECN(1,N,NP)
        IF ( SCF .NE. ZERO ) B2N=B2N/SCF
C*** CORRECTION IN THE ORIGINAL VARIABLES
        INFE1=ZERO
        DO I=1,NR
          INFE1=INFE1+ABS(XD(I))*MULT(I)
        ENDDO
COLD        IF ( UPSI .LE. DELMIN*NRES .AND. UPSI0 .LE. DELMIN*NRES
        IF ( UPSI .LE. DELMIN*NRES 
     F   .AND.  B2N .LE. (GFN+ONE)*EPSX*TP2 .AND. PHASE .GE. 0
     F   .AND. INFEAS .LE. DELMIN*NRES
     F      )  THEN
C****** SINCE MULTIPLIERS MAY BE INCORRECT FOR INFEAS .NE. ZERO 
C****** BE CAREFUL. IF MULTIPLIERS ARE IMPORTANT CHECK IN SOLCHK
C****** AND POSSIBLY COMPUTE THEM SEPARATELY GIVEN X AND THE ACTIVE
C****** SET E.G. BY USING NNLS FROM NETLIB
C****** WE CONSIDER THE PROBLEM AS SUCCESSFULLY SOLVED WITH REDUCED 
C****** REQUIREMENTS
          DO I=1,N
            D(I)=ZERO
          ENDDO
          DNORM=ZERO
          QPTERM=ONE
          DIRDER=ZERO
          OPTITE=THREE
          RETURN
        ENDIF
C*** THERE MAY BE AN ADDITIONAL INCREASE OF TAUQP NECESSARY AGAIN
C***
        IF ( INFE1 .GT. (ONE-DELTA1/TAUQP)*UPSI .AND. 
     F       ( O8VECN(1,N,D) .LE. MIN(INFE1,INFE1**2)*TP1
     F        .OR. UPSI .GT. TAU0*P5 ) ) THEN
C*** FURTHER INCREASE TAUQP !
          DO I=1,NRES
            U(I)=ZERO
            SLACK(I)=ZERO
          ENDDO
          IF ( .NOT. SILENT ) CALL O8MSG(17)
          IF ( TAUQP*TAUFAC .GT. TAUMAX ) THEN
            IF ( .NOT. SILENT ) CALL O8MSG(5)
            QPTERM=-1
            ACCINF(ITSTEP,30)=QPTERM
            ACCINF(ITSTEP,31)=TAUQP
            ACCINF(ITSTEP,32)=INFEAS
            DO I=1,N
              D(I)=ZERO
            ENDDO
            DNORM=ZERO
            RETURN
          ELSE
            TAUQP=TAUQP*TAUFAC
            GOTO 10
          ENDIF
        ENDIF
C*** COMPUTE NEW WEIGHTS FOR THE PENALTY-FUNCTION
  500   CONTINUE
        DO I=1,NRES
          SLACK(I)=ZERO
        ENDDO
        DO I=1,NR
          SLACK(ALIST(I))=XD(I)
        ENDDO
        WLOW=.FALSE.
        DO I=1,NRES
          W1(I)=W(I)
          IF ( I .LE. NH ) THEN
            IF ( ABS(SLACK(I)) .GT. ABS(RES(I))+TINY ) THEN
              W1(I)=ABS(U(I))
            ELSE
              W1(I)=NY*ABS(U(I))+TAU
            ENDIF
          ELSE
            IF ( BIND(I)  .EQ. 0 ) THEN
              W1(I)=MAX(W(I)*P8,TAU)
            ELSE
              IF ( RES(I) .GE. ZERO .AND. SLACK(I) .LE. TINY)
     *            W1(I)=MAX(NY*ABS(U(I))+TAU,(ABS(U(I))+W1(I))*P5)
              IF ( RES(I) .GE. ZERO .AND. SLACK(I) .GT. TINY )
     *            W1(I)=ABS(U(I))
              IF (RES(I) .LT. ZERO .AND. SLACK(I) .LE. -RES(I)+TINY)
     *            W1(I)=MAX(NY*ABS(U(I))+TAU,(ABS(U(I))+W1(I))*P5)
              IF (RES(I) .LT. ZERO .AND. SLACK(I) .GT. -RES(I)+TINY)
     *            W1(I)=ABS(U(I))
       
            ENDIF
          ENDIF 
          IF ( W1(I) .LT. W(I) ) WLOW=.TRUE.
        ENDDO
        IF ( WLOW  ) THEN
          S1=ZERO
          S2=ZERO
          DO I=1,NRES
            IF ( I .LE. NH ) THEN
              S1=S1+W1(I)*ABS(RESST(I))
              S2=S2+W1(I)*ABS(RES(I))
            ELSE
              S1=S1-MIN(ZERO,RESST(I))*W1(I)
              S2=S2-MIN(ZERO,RES(I))*W1(I)
            ENDIF
          ENDDO
          DIFF0=(FXST-FX)*SCF+(S1-S2)
          IF (  DIFF0 .GE. ETA*CLOW 
     F    .AND. ITSTEP-LASTDW .GE. MAX(5,MIN(N/10,20))  ) THEN
C***** ACCEPT NEW (DIMINISHED ) WEIGHTS
            LASTDW=ITSTEP
            LASTCH=ITSTEP
            LEVEL=DIFF0/ITERMA
            PSIST=S1
            PSI=S2
            DO I=1,NRES
              IF (W1(I) .NE. W(I)) LASTCH=ITSTEP
              W(I)=W1(I)
            ENDDO
            CLOW=CLOW+ONE
            IF ( CLOW .GT. ITSTEP/10 ) THEN
C*** ADDITIONAL INCREASE OF ETA
              ETA=ETA*ONEP3
              IF ( .NOT. SILENT )  CALL O8INFO(11)
            ENDIF
            IF ( .NOT. SILENT ) CALL O8INFO(12)
            GOTO 1000
          ENDIF
        ENDIF
C***  WE CANNOT ACCEPT NEW WEIGHTS 
C***  RESET WEIGHTS
        DO I=1,NRES
          W1(I)=W(I)
          IF ( I .LE. NH ) THEN
            IF ( SLACK(I) .GT. ABS(RES(I)) ) 
     *        W1(I)=ABS(U(I))
            IF ( SLACK(I) .LE. ABS(RES(I)) ) THEN
              IF ( W(I) .LE. ABS(U(I)) .AND. ABS(U(I)) .LE. 
     *             W(I)+TAU ) THEN
                   W1(I)=W(I)+TWO*TAU
              ELSE
                   W1(I)=MAX(W(I),NY*ABS(U(I))+TAU)
              ENDIF
            ENDIF
          ELSE
            IF ( SLACK(I) .GT. -MIN(-TINY,RES(I))
     *        .AND. BIND(I) .EQ. 1 ) THEN
              W1(I)=ABS(U(I))
            ELSEIF ( BIND(I) .EQ. 1 .AND. SLACK(I) .LE.
     *           -MIN(-TINY,RES(I)) .AND. U(I) .LE. W(I)+TAU 
     *           .AND. W(I) .GE. U(I) )
     *        THEN
              W1(I)=W(I)+TWO*TAU
            ELSEIF ( BIND(I) .EQ. 1 ) THEN
              W1(I)=MAX(W(I),NY*ABS(U(I))+TAU)
            ENDIF
          ENDIF
        ENDDO
        TERM1=ZERO
        DO I=1,NRES
          IF ( W1(I) .GT. W(I) .OR. W1(I) .LT. W(I) )
     *       LASTCH=ITSTEP
          IF ( W1(I) .GT. W(I) ) LASTUP=ITSTEP
          IF ( W1(I) .LT. W(I) ) LASTDW=ITSTEP
          W(I)=W1(I)
          TERM1=MAX(TERM1,W(I))
        ENDDO
        S1=ZERO
        S2=ZERO
        DO I=1,NRES
          IF ( I.LE. NH ) THEN
            S1=S1+W(I)*ABS(RESST(I))
            S2=S2+W(I)*ABS(RES(I))
          ELSE
            S1=S1-W(I)*MIN(ZERO,RESST(I))
            S2=S2-W(I)*MIN(ZERO,RES(I))
          ENDIF
        ENDDO
        PSIST=S1
        PSI=S2
        IF ( .NOT. SILENT ) CALL O8INFO(12)
        ACCINF(ITSTEP,20)=TERM1
        ACCINF(ITSTEP,19)=CLOW
        GOTO 1000
C***
      ENDIF
      IF ( IP .GT. NR ) THEN
        K=ALIST(IP+NH-NR)
        DO J=1,N
          CII(J+INCR)=GRES(J,K)
        ENDDO
        DO J=1,INCR
          CII(J)=ZERO
        ENDDO
        CII(NH+IP-NR)=ONE
        CI0(IP)=RES(K)
      ELSE
        DO J=1,NDUAL
          CII(J)=ZERO
        ENDDO
        CI0(IP)=ZERO
        CII(IP)=ONE
      ENDIF
      DO I=1,NDUAL
        NP(I)=CII(I)
      ENDDO
      DO  I =1,IQ
        UD1(I)=UD(I)
      ENDDO
      UD1(IQ+1)=ZERO
      AI(IQ+1)=IP
  100 CONTINUE
C********   STEP 2A
      CALL O8ZUP(Z)
      IF(IQ .NE. 0)     CALL O8RUP(VR)
      L=0
      T1=INFINY
      DO K=1,IQ
        IF(AI(K) .GT. 0 .AND. VR(K) .GT. ZERO)     THEN
          IF(UD1(K)/VR(K) .LT. T1)      THEN
            T1=UD1(K)/VR(K)
          ENDIF
        ENDIF
      ENDDO
C*******|Z|=0?
COLD      ZZ=O8SC1(1,NDUAL,Z,Z)
      ZZ=O8VECN(1,NDUAL,Z)
      TERM=O8SC1(1,NDUAL,Z,NP)
COLD      IF  (ZZ .NE. ZERO .AND. TERM .GT. ZERO )         THEN
      IF ( ZZ .GE. TINY*RNORM .AND. TERM .GT. ZERO ) THEN
        T2=-S(IP)/TERM
      ELSE
        T2=INFINY
      ENDIF
      T=MIN(T1,T2)
      IF(T .GE. INFINY ) GOTO 2000
C**********
      IF(T2 .GE. INFINY )       THEN
        DO      K=1,IQ
          UD1(K)=UD1(K)+T*(-VR(K))
          IF ( UD1(K) .LT. ZERO .AND. AI(K) .GT. 0 ) UD1(K)=ZERO
        ENDDO
        UD1(IQ+1)=UD1(IQ+1)+T
        QPDEL(0)=0
        DO I=1,IQ
          IF ( UD1(I) .LE. TINY .AND. AI(I) .GT. 0 ) THEN
            QPDEL(0)=QPDEL(0)+1
            QPDEL(QPDEL(0))=AI(I)
          ENDIF
        ENDDO
        DO K=1,QPDEL(0)
          L=QPDEL(K)
          IAI(L)=L
          CALL O8DLCD(AI,L)
        ENDDO
        GOTO 100
      ENDIF
      DO K=1,NDUAL
        XD(K)=XD(K)+T*Z(K)
      ENDDO
      DO K=1,IQ
        UD1(K)=UD1(K)+T*(-VR(K))
        IF ( UD1(K) .LT. ZERO .AND. AI(K) .GT. 0 ) UD1(K)=ZERO
      ENDDO
      UD1(IQ+1)=UD1(IQ+1)+T
      F=F+T*O8SC1(1,NDUAL,Z,NP)*(P5*T+UD1(IQ+1))
      IF (T2 .LE.T1-TINY  )      THEN
C**** DDUAL IS COMPUTED BY O8ZUP
        IF ( O8VECN(IQ+1,NDUAL,DDUAL) .LT. EPSMAC*RNORM )
     F    THEN
C**** DEGENERACY: ADDING THIS CONSTRAINT GIVES A SINGULAR WORKING SET
C**** THEORETICALLY IMPOSSIBLE, BUT DUE TO ROUNDOFF THIS MAY OCCUR
C**** MARK THIS CONSTRAINT AND TRY TO ADD ANOTHER ONE
          IPTR=IP
          IQTR=IQ
          DO I=1,IQ
            AITR(I)=AI(I)
          ENDDO
          SSTR=SS
          RIITR=O8VECN(IQ+1,NDUAL,DDUAL)
          IF ( .NOT. SILENT ) CALL O8MSG(19)
          IAEXCL(IP)=0
          DO  I=1,MI
            IAI(I)=I
          ENDDO
          DO  I=1,IQ
            AI(I)=AIOLD(I)
            IF (AI(I) .GT. 0 ) IAI(AI(I))=0
            UD1(I)=UDOLD(I)
          ENDDO
          DO  I=1,NDUAL
            XD(I)=XDOLD(I)
          ENDDO
          GOTO 60
        ENDIF
C*** ADD CONSTRAINT, L-PAIR
        CALL O8ADCD
        IAI(IP)=0
        DO I=1,IQ
          UD(I)=UD1(I)
        ENDDO
        GOTO 50
      ENDIF
      SU=ZERO
      IF ( IP .GT. NR ) THEN
C*** A GENERAL LINEAR INEQUALITY CONSTRAINT
        K=ALIST(IP+NH-NR)
        DO J=1,N
          CII(J+INCR)=GRES(J,K)
        ENDDO
        DO J=1,INCR
          CII(J)=ZERO
        ENDDO
        CII(NH+IP-NR)=ONE
        CI0(IP)=RES(K)
        S(IP)=O8SC1(1,NDUAL,CII,XD)+CI0(IP)
      ELSE
C*** A SLACK CONSTRAINT
        S(IP)=XD(IP)
      ENDIF
C*** NOW T=T1
      QPDEL(0)=0
      DO I=1,IQ
        IF ( UD1(I) .LE. TINY .AND. AI(I) .GT. 0 ) THEN
          QPDEL(0)=QPDEL(0)+1
          QPDEL(QPDEL(0))=AI(I)
        ENDIF
      ENDDO
      DO K=1,QPDEL(0)
        L=QPDEL(K)
        IAI(L)=L
        CALL O8DLCD(AI,L)
      ENDDO
      IF ( T2 .LE. T1+TINY ) THEN
        IF ( O8VECN(IQ+1,NDUAL,DDUAL) .LT. EPSMAC*RNORM )
     F    THEN
C**** DEGENERACY
          IPTR=IP
          IQTR=IQ
          DO I=1,IQ
            AITR(I)=AI(I)
          ENDDO
          SSTR=SS
          RIITR=O8VECN(IQ+1,NDUAL,DDUAL)
           IF ( .NOT. SILENT ) CALL O8MSG(19)
          IAEXCL(IP)=0
          DO  I=1,MI
            IAI(I)=I
          ENDDO
          DO  I=1,IQ
            AI(I)=AIOLD(I)
            IF ( AI(I) .GT. 0 ) IAI(AI(I))=0
            UD1(I)=UDOLD(I)
          ENDDO
          DO  I=1,NDUAL
            XD(I)=XDOLD(I)
          ENDDO
          GOTO 60
        ENDIF
C*** ADD CONSTRAINT, L-PAIR
        CALL O8ADCD
        IAI(IP)=0
        DO I=1,IQ
          UD(I)=UD1(I)
        ENDDO
        GOTO 50
      ELSE
        GOTO 100
      ENDIF
C**** THIS IS THE EXIT POINT OF O8QPDU
C**** WE EITHER MAY HAVE SUCCESSFUL OR UNSUCCESSFUL TERMINATION HERE
C**** THE LATTER WITH QPTERM=-2 OR -3, IN WHICH CASE IT MAY NEVERTHELESS
C**** BE POSSIBLE TO USE THE COMPUTED D. -2 OR -3 EXIT IS THEORETICALLY
C**** IMPOSSIBLE BUT MAY OCCUR DUE TO ROUNDOFF EFFECTS.
C**** WE CHECK THE DIRECTIONAL DERIVATIVE OF THE PENALTY-FUNCTION NOW
 1000 CONTINUE
C*** CUT AND RESCALE D IF APPROPRIATE
      CALL O8CUTD
C*** COMPUTE THE DIRECTIONAL DERIVATIVE DIRDER
      CALL O8DIRD
      IF ( DIRDER .GE. ZERO  .OR.
     F    ( -DIRDER .LE. EPSMAC*TP2*(SCF*ABS(FX)+PSI+ONE) .AND.
     F      INFEAS .GT. MAX(UPSI,NRES*DELMIN) ) ) THEN
        IF ( .NOT. SILENT ) CALL O8MSG(18)
        IF ( TAUQP .LE. TAUMAX/TAUFAC ) THEN
          TAUQP=TAUQP*TAUFAC
          GOTO 10
        ELSE
          IF ( .NOT. SILENT ) CALL O8MSG(5)
          QPTERM=-1
          ACCINF(ITSTEP,30)=QPTERM
          ACCINF(ITSTEP,31)=TAUQP
          ACCINF(ITSTEP,32)=INFEAS
          DO I=1,N
            D(I)=ZERO
          ENDDO
          DNORM=ZERO
          DIRDER=ZERO
        ENDIF
      ENDIF
      RETURN
 2000 CONTINUE
C*** QP INFEASIBLE ( IN THIS APPLICATION IMPOSSIBLE , THEORETICALLY)
        IF ( .NOT. SILENT ) CALL O8MSG(20)
        QPTERM=-2
        ACCINF(ITSTEP,30)=-TWO
        ACCINF(ITSTEP,13)=CONDR
        ACCINF(ITSTEP,14)=C1*C2
        DO I=1,N
          D(I)=XD(I+INCR)
        ENDDO
        DNORM=O8VECN(1,N,D)
        SU1=ZERO
        DO I=1,INCR
          SU1=SU1+ABS(XD(I))
        ENDDO
C******* L1-NORM OF SLACK VARIABLES
        ACCINF(ITSTEP,32)=SU1
        INFEAS=SU1
        WLOW=.FALSE.
        SU1=ZERO
        SU2=ZERO
        DO I=1,IQ
          IF ( AI(I) .LT. 0 ) THEN
            U(-(AI(I)+NR))=UD(I)
          ELSE
            IF ( AI(I) .GT. NR ) U(ALIST(AI(I)-NR+NH))=UD(I)
          ENDIF
        ENDDO
        TERM1=ZERO
        DO J=1,N
          NP(J)=GRADF(J)*SCF
        ENDDO
        DO I=1,NRES
          DO J=1,N
            NP(J)=NP(J)-GRES(J,I)*U(I)
          ENDDO
          W1(I)=W(I)
          IF ( I .LE. NH ) THEN
            IF ( SLACK(I) .GT. ABS(RES(I)) ) 
     *        W1(I)=ABS(U(I))
            IF ( SLACK(I) .LE. ABS(RES(I)) ) THEN
              IF ( W(I) .LE. ABS(U(I)) .AND. ABS(U(I)) .LE. 
     *             W(I)+TAU ) THEN
                W1(I)=W(I)+TWO*TAU
              ELSE
                W1(I)=MAX(W(I),NY*ABS(U(I))+TAU)
              ENDIF
            ENDIF
            SU1=SU1+ABS(RES(I))*W1(I)
            SU2=SU2+ABS(RESST(I))*W1(I)
          ELSE
            IF ( SLACK(I) .GT. -MIN(-TINY,RES(I))
     *        .AND. BIND(I) .EQ. 1 ) THEN
              W1(I)=ABS(U(I))
            ELSEIF ( BIND(I) .EQ. 1 .AND. SLACK(I) .LE.
     *           -MIN(-TINY,RES(I)) .AND. U(I) .LE. W(I)+TAU 
     *           .AND. W(I) .GE. U(I) )
     *        THEN
              W1(I)=W(I)+TWO*TAU
            ELSEIF ( BIND(I) .EQ. 1 ) THEN
              W1(I)=MAX(W(I),NY*ABS(U(I))+TAU)
            ENDIF
            SU1=SU1-W1(I)*MIN(ZERO,RES(I))
            SU2=SU2-W1(I)*MIN(ZERO,RESST(I))
          ENDIF
          IF ( W(I) .NE. W1(I) ) LASTCH=ITSTEP
          W(I)=W1(I)
          TERM1=MAX(TERM1,W(I))
        ENDDO
        PSIST=SU2
        PSI=SU1
        B2N=SQRT(O8SC1(1,N,NP,NP))
        IF ( SCF .NE. ZERO ) THEN
            B2N=B2N/SCF
        ELSE
            B2N = -ONE
        ENDIF
        IF ( WLOW ) THEN
           CLOW=CLOW+ONE
           LASTCH=ITSTEP
           LASTDW=ITSTEP
        ENDIF
        IF ( .NOT. SILENT ) CALL O8INFO(12)
        ACCINF(ITSTEP,19)=CLOW
        ACCINF(ITSTEP,20)=TERM1
        ACCINF(ITSTEP,31)=TAUQP
        GOTO 1000
      END
C*****************************************************
      SUBROUTINE O8ZUP(Z)
C********** COMPUTE UPDATED PROJECTED GRADIENT (PRIMAL)
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER NDUALM,MDUALM,NDUAL,MI,ME,IQ
      PARAMETER (NDUALM=NX+NRESM,MDUALM=NRESM*2)
      DOUBLE PRECISION NP,RNORM,RLOW,XJ,DDUAL,R,UD,UD1
      COMMON /O8DUPA/RNORM,RLOW,NDUAL,MI,ME,IQ
      COMMON /O8QPUP/XJ(NDUALM,NDUALM),DDUAL(NDUALM),R(NDUALM,NDUALM),
     F                NP(NDUALM),UD(MDUALM),UD1(MDUALM)
      DOUBLE PRECISION Z(NDUALM)
      INTEGER I,J
      DOUBLE PRECISION SU
      SAVE 
C******      D = J(TRANS) *NP
      DO I=1,NDUAL
        SU=ZERO
        DO      J=1,NDUAL
          SU=SU+XJ(J,I)*NP(J)
        ENDDO
        DDUAL(I)=SU
      ENDDO
C****** COMPUTATION OF Z
      DO      I=1,NDUAL
        Z(I)=ZERO
        DO      J=IQ+1,NDUAL
          Z(I)=Z(I)+XJ(I,J)*DDUAL(J)
        ENDDO
      ENDDO
      RETURN
      END
C*******************************************************************
      SUBROUTINE O8RUP(RV)
C******* COMPUTE CORRECTION OF DUAL MULTIPLIERS
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER NDUALM,MDUALM,NDUAL,MI,ME,IQ
      DOUBLE PRECISION NP,RNORM,RLOW,XJ,DDUAL,R,UD,UD1
      PARAMETER (NDUALM=NX+NRESM,MDUALM=NRESM*2)
      COMMON /O8DUPA/RNORM,RLOW,NDUAL,MI,ME,IQ
      COMMON /O8QPUP/XJ(NDUALM,NDUALM),DDUAL(NDUALM),R(NDUALM,NDUALM),
     F                NP(NDUALM),UD(MDUALM),UD1(MDUALM)
      DOUBLE PRECISION RV(MDUALM),S
      INTEGER I,J
      SAVE 
      DO      I=IQ,1,-1
        S=ZERO
        DO        J=I+1,IQ
          S=S+R(I,J)*RV(J)
        ENDDO
        RV(I)=(DDUAL(I)-S)/R(I,I)
      ENDDO
      RETURN
      END
C*********************************************************************
      SUBROUTINE O8DLCD(AI,L)
C************** DELETE CONSTRAINT NR. L
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION NP,RNORM,RLOW,XJ,DDUAL,R,UD,UD1
      INTEGER NDUALM,MDUALM,NDUAL,MI,ME,IQ
      PARAMETER (NDUALM=NX+NRESM,MDUALM=NRESM*2)
      COMMON /O8DUPA/RNORM,RLOW,NDUAL,MI,ME,IQ
      COMMON /O8QPUP/XJ(NDUALM,NDUALM),DDUAL(NDUALM),R(NDUALM,NDUALM),
     F                NP(NDUALM),UD(MDUALM),UD1(MDUALM)
      INTEGER AI(MDUALM),QQ,L,I,J,K
      DOUBLE PRECISION T1,T2,CC,SS,H,C1,S1,XNY,O8DSQ1
      SAVE 
      DO I=1,IQ
        IF(AI(I) .EQ. L)      THEN
          QQ=I
          GOTO 10
         ENDIF
      ENDDO
   10 CONTINUE
      DO I=QQ,IQ-1
        AI(I)=AI(I+1)
        UD1(I)=UD1(I+1)
        DO J=1,NDUAL
          R(J,I)=R(J,I+1)
        ENDDO
      ENDDO
   20 CONTINUE
      AI(IQ)=AI(IQ+1)
      UD1(IQ)=UD1(IQ+1)
      AI(IQ+1)=0
      UD1(IQ+1)=ZERO
      DO  J=1,IQ
        R(J,IQ)=ZERO
      ENDDO
      IQ=IQ-1
      IF(IQ .EQ. 0)     GOTO 100
      DO J=QQ,IQ
        CC=R(J,J)
        SS=R(J+1,J)
        H=O8DSQ1(CC,SS)
        IF(H .EQ. ZERO)            GOTO 90
        C1=CC/H
        S1=SS/H
        R(J+1,J)=ZERO
        IF ( C1 .LT. ZERO ) THEN
          R(J,J)=-H
          C1=-C1
          S1=-S1
        ELSE
          R(J,J)=H
        ENDIF
        XNY=S1/(ONE+C1)
        DO K=J+1,IQ
          T1=R(J,K)
          T2=R(J+1,K)
          R(J,K)=T1*C1+T2*S1
          R(J+1,K)=XNY*(T1+R(J,K))-T2
        ENDDO
        DO K=1,NDUAL
          T1=XJ(K,J)
          T2=XJ(K,J+1)
          XJ(K,J)=T1*C1+T2*S1
          XJ(K,J+1)=XNY*(XJ(K,J)+T1)-T2
        ENDDO
   90 CONTINUE
      ENDDO
  100 CONTINUE
      RNORM=ONE
      RLOW=ONE
C*** IN ORDER TO AVOID A COMPILER ERROR OF HP IN +OP3 MODE
      IF ( IQ .GE. 1 ) THEN
        RNORM=ABS(R(1,1))
        RLOW=ABS(R(1,1))
        I=1
        DO WHILE ( I .LT. IQ )
          I=I+1
          RNORM=MAX(RNORM,ABS(R(I,I)))
          RLOW=MIN(RLOW,ABS(R(I,I)))
        ENDDO
      ENDIF
      RETURN
      END
C***********************************************************************
      SUBROUTINE O8ADCD
C********** ADD CONSTRAINT WHOSE GRADIENT IS GIVEN BY NP
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION NP,RNORM,RLOW,XJ,DDUAL,R,UD,UD1
      INTEGER NDUALM,MDUALM,NDUAL,MI,ME,IQ
      PARAMETER (NDUALM=NX+NRESM,MDUALM=NRESM*2)
      COMMON /O8DUPA/RNORM,RLOW,NDUAL,MI,ME,IQ
      COMMON /O8QPUP/XJ(NDUALM,NDUALM),DDUAL(NDUALM),R(NDUALM,NDUALM),
     F                NP(NDUALM),UD(MDUALM),UD1(MDUALM)
      INTEGER I,J,K
      DOUBLE PRECISION CC,SS,H,S1,C1,T1,T2,O8DSQ1,XNY
      SAVE
      DO J=NDUAL,IQ+2,-1
        CC=DDUAL(J-1)
        SS=DDUAL(J)
        H=O8DSQ1(CC,SS)
        IF(H .EQ. ZERO)           GOTO 20
        DDUAL(J)=ZERO
        S1=SS/H
        C1=CC/H
        IF ( C1 .LT. ZERO ) THEN
          C1=-C1
          S1=-S1
          DDUAL(J-1)=-H
        ELSE
          DDUAL(J-1)=H
        ENDIF
        XNY=S1/(ONE+C1)
        DO K=1,NDUAL
          T1=XJ(K,J-1)
          T2=XJ(K,J)
          XJ(K,J-1)=T1*C1+T2*S1
          XJ(K,J)=XNY*(T1+XJ(K,J-1))-T2
        ENDDO
   20 CONTINUE
      ENDDO
      IQ=IQ+1
      DO I=1,IQ
        R(I,IQ)=DDUAL(I)
      ENDDO
      RNORM=ONE
      RLOW=ONE
C*** IN ORDER TO AVOID A COMPILER ERROR OF HP IN +OP3 MODE
      IF ( IQ .GE. 1 ) THEN
        RNORM=ABS(R(1,1))
        RLOW=ABS(R(1,1))
        I=1
        DO WHILE ( I .LT. IQ )
          I=I+1
          RNORM=MAX(RNORM,ABS(R(I,I)))
          RLOW=MIN(RLOW,ABS(R(I,I)))
        ENDDO
      ENDIF
      RETURN
      END
C****************************************************************
      SUBROUTINE O8RINV(NDIM,N,A,NDUALM,NDUAL,X)
C******* COMPUTES THE INVERSE OF THE UPPER TRIANGULAR MATRIX PART
C******* OF A AND STORES IT IN THE UPPER TRIANGLE OF THE
C******* RIGHT LOWER MINOR OF X
C******* DECLARATION DIMENSION OF A IS NDIM, OF  X IS NDUALM
C******* ACTUAL DIMENSION OF A IS N AND OF X NDUAL
      IMPLICIT NONE
      INCLUDE 'O8CONS.INC'
      INTEGER NDIM,NDUALM,N,NDUAL,L,J,K,INCR
      DOUBLE PRECISION A(NDIM,*),X(NDUALM,NDUALM),SU
      SAVE
      INCR=NDUAL-N
C***  INCR=NR
      DO J=N,1,-1
C*** WE ASSUME A BEING SUFFICIENTLY REGULAR HERE. 
C*** GIVEN IN THIS APPLICATION
C*** SEE TOP OF O8QPDU
        X(J+INCR,J+INCR)=ONE/A(J,J)
        DO K=J-1,1,-1
          SU=ZERO
          DO L=K+1,J
            SU=SU+A(K,L)*X(L+INCR,J+INCR)
          ENDDO
          X(K+INCR,J+INCR)=-SU/A(K,K)
        ENDDO
      ENDDO
      RETURN
      END
C**************************************************
C SUITE OF FUNCTION INTERFACES, FOR PERFORMING SCALING AND
C EXTERNAL EVALUATIONS
C IF BLOC=.TRUE. THEN IT IS ASUMED THAT PRIOR TO CALLS TO ES<xyz>
C VALID FUNCTION INFORMATION IS COMPUTED (VIA A CALL OF USER_EVAL)
C AND STORED IN FU AND FUGRAD , SETTING VALID=.TRUE. AFTERWARDS
C**************************************************
C     OBJECTIVE FUNCTION
      SUBROUTINE ESF(X,FX)
      INCLUDE 'O8FUCO.INC'
      INCLUDE 'O8FINT.INC'
      DOUBLE PRECISION X(*),FX
      INTEGER I
      SAVE
      IF ( BLOC ) THEN
        IF ( VALID ) THEN
          FX=FU(0)
          ICF=ICF+1
        ELSE
          STOP 'DONLP2: BLOC-CALL, FUNCTION INFO INVALID'
        ENDIF
      ELSE
        DO I=1,N
          XTR(I)=X(I)*XSC(I)
        ENDDO
        CALL EF(XTR,FX)
      ENDIF
      RETURN
      END
C     GRADIENT OF OBJECTIVE FUNCTION
      SUBROUTINE ESGRADF(X,GRADF)
      INCLUDE 'O8FUCO.INC'
      INCLUDE 'O8FINT.INC'
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION X(*),GRADF(*)
C     USER DECLARATIONS, IF ANY ,FOLLOW
      INTEGER J
      DOUBLE PRECISION D1,D2,D3,SD1,SD2,SD3,FHELP,FHELP1,FHELP2,
     *   FHELP3,FHELP4,FHELP5,FHELP6,XINCR,XHELP,FLOC
      SAVE
      IF ( GUNIT(1,0) .EQ. 1 ) THEN
        DO J=1,N
          GRADF(J)=ZERO
        ENDDO
        GRADF(GUNIT(2,0))=GUNIT(3,0)*XSC(GUNIT(2,0))
        RETURN
      ENDIF
      IF ( BLOC ) THEN
        IF ( VALID ) THEN
          ICGF=ICGF+1
          DO           J=1,N
	    GRADF(J)=XSC(J)*FUGRAD(J,0)
          ENDDO
          RETURN
        ELSE
          STOP 'DONLP2: BLOC CALL WITH FUNCTION INFO INVALID'
        ENDIF
      ELSE
        DO J=1,N
          XTR(J)=XSC(J)*X(J)
        ENDDO
        IF ( ANALYT ) THEN
           CALL EGRADF(XTR,GRADF)
        ELSE
        IF ( DIFFTYPE .EQ. 1 ) THEN
          DELDIF=MIN(TM1*SQRT(EPSFCN),TM2)
          CALL EF(XTR,FLOC)
          DO J=1,N
            XHELP=XTR(J)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND)
            IF ( XHELP .GE. ZERO ) THEN
              XTR(J)=XHELP+XINCR
            ELSE
              XTR(J)=XHELP-XINCR
            ENDIF
            CALL EF(XTR,FHELP)
            GRADF(J)=(FHELP-FLOC)/(XTR(J)-XHELP)
            XTR(J)=XHELP
          ENDDO
        ELSEIF ( DIFFTYPE .EQ. 2 ) THEN 
          DELDIF=MIN(TM1*EPSFCN**(ONE/THREE),TM2)
          DO J=1,N
            XHELP=XTR(J)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND)
            XTR(J)=XHELP+XINCR
            CALL EF(XTR,FHELP1)
            XTR(J)=XHELP-XINCR
            CALL EF(XTR,FHELP2)
            GRADF(J)=(FHELP1-FHELP2)/(XINCR+XINCR)
            XTR(J)=XHELP
          ENDDO
        ELSE
          DELDIF=MIN(TM1*EPSFCN**(ONE/SEVEN),TM2)
          DO J=1,N
            XHELP=XTR(J)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND/FOUR)
            XTR(J)=XHELP-XINCR
            CALL EF(XTR,FHELP1)
            XTR(J)=XHELP+XINCR
            CALL EF(XTR,FHELP2)
            XINCR=XINCR+XINCR
            D1=XINCR
            XTR(J)=XHELP-XINCR
            CALL EF(XTR,FHELP3)
            XTR(J)=XHELP+XINCR
            CALL EF(XTR,FHELP4)
            XINCR=XINCR+XINCR
            D2=XINCR
            XTR(J)=XHELP-XINCR
            CALL EF(XTR,FHELP5)
            XTR(J)=XHELP+XINCR
            CALL EF(XTR,FHELP6)
            XTR(J)=XHELP
            D3=XINCR+XINCR
            SD1=(FHELP2-FHELP1)/D1
            SD2=(FHELP4-FHELP3)/D2
            SD3=(FHELP6-FHELP5)/D3
            SD3=SD2-SD3
            SD2=SD1-SD2
            SD3=SD2-SD3
            GRADF(J)=SD1+P4*SD2+SD3/C45
          ENDDO
        ENDIF
        ENDIF
        DO J=1,N
          GRADF(J)=XSC(J)*GRADF(J)
        ENDDO
      ENDIF
      RETURN
      END
C  COMPUTE THE I-TH EQUALITY CONSTAINT, VALUE IS HXI
      SUBROUTINE ESH(I,X,HXI)
      INCLUDE 'O8FUCO.INC'
      INCLUDE 'O8FINT.INC'
      DOUBLE PRECISION X(*),HXI
      INTEGER I
      INTEGER J
      SAVE
      IF ( BLOC ) THEN
        IF ( VALID ) THEN
          IF ( GUNIT(1,I) .NE. 1 ) CRES(I)=CRES(I)+1
          HXI=FU(I)
          RETURN
        ELSE
          STOP 'DONLP2: BLOC-CALL WITH FUNCTONINFORMATION INVALID'
        ENDIF
      ELSE
        DO J=1,N
          XTR(J)=X(J)*XSC(J)
        ENDDO
        CALL EH(I,XTR,HXI)
        RETURN
      ENDIF
      END
C  COMPUTE THE GRADIENT OF THE I-TH EQUALITY CONSTRAINT
      SUBROUTINE ESGRADH(I,X,GRADHI)
      INCLUDE 'O8FUCO.INC'
      INCLUDE 'O8FINT.INC'
      INCLUDE 'O8CONS.INC'
      DOUBLE PRECISION X(*),GRADHI(*)
      INTEGER I,J
      DOUBLE PRECISION D1,D2,D3,SD1,SD2,SD3,FHELP,FHELP1,FHELP2,
     *   FHELP3,FHELP4,FHELP5,FHELP6,XINCR,XHELP,HIXLOC
      SAVE
      IF ( GUNIT(1,I) .EQ. 1 ) THEN
        DO J=1,N
          GRADHI(J)=ZERO
        ENDDO
        GRADHI(GUNIT(2,I))=GUNIT(3,I)*XSC(GUNIT(2,I))
        RETURN
      ENDIF
      IF ( BLOC ) THEN
        IF ( VALID ) THEN
          CGRES(I)=CGRES(I)+1
          DO J=1,N
            GRADHI(J)=XSC(J)*FUGRAD(J,I)
          ENDDO
          RETURN
        ELSE
          STOP 'DONLP2: BLOC CALL WITH FUNCTION INFO INVALID'
        ENDIF
      ELSE
        DO J=1,N
          XTR(J)=XSC(J)*X(J)
        ENDDO
        IF ( ANALYT ) THEN
          CALL EGRADH(I,XTR,GRADHI)
        ELSE
        IF ( DIFFTYPE .EQ. 1 ) THEN
          DELDIF=MIN(TM1*SQRT(EPSFCN),TM2)
          CALL EH(I,XTR,HIXLOC)
          DO J=1,N
            XHELP=XTR(J)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND)
            IF ( XHELP .GE. ZERO ) THEN
              XTR(J)=XHELP+XINCR
            ELSE
              XTR(J)=XHELP-XINCR
            ENDIF
            CALL EH(I,XTR,FHELP)
            GRADHI(J)=(FHELP-HIXLOC)/(XTR(J)-XHELP)
            XTR(J)=XHELP
          ENDDO
        ELSEIF ( DIFFTYPE .EQ. 2 ) THEN 
          DELDIF=MIN(TM1*EPSFCN**(ONE/THREE),TM2)
          DO J=1,N
            XHELP=XTR(J)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND)
            XTR(J)=XHELP+XINCR
            CALL EH(I,XTR,FHELP1)
            XTR(J)=XHELP-XINCR
            CALL EH(I,XTR,FHELP2)
            GRADHI(J)=(FHELP1-FHELP2)/(XINCR+XINCR)
            XTR(J)=XHELP
          ENDDO
        ELSE
          DELDIF=MIN(TM1*EPSFCN**(ONE/SEVEN),TM2)
          DO J=1,N
            XHELP=XTR(J)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND/FOUR)
            XTR(J)=XHELP-XINCR
            CALL EH(I,XTR,FHELP1)
            XTR(J)=XHELP+XINCR
            CALL EH(I,XTR,FHELP2)
            XINCR=XINCR+XINCR
            D1=XINCR
            XTR(J)=XHELP-XINCR
            CALL EH(I,XTR,FHELP3)
            XTR(J)=XHELP+XINCR
            CALL EH(I,XTR,FHELP4)
            XINCR=XINCR+XINCR
            D2=XINCR
            XTR(J)=XHELP-XINCR
            CALL EH(I,XTR,FHELP5)
            XTR(J)=XHELP+XINCR
            CALL EH(I,XTR,FHELP6)
            XTR(J)=XHELP
            D3=XINCR+XINCR
            SD1=(FHELP2-FHELP1)/D1
            SD2=(FHELP4-FHELP3)/D2
            SD3=(FHELP6-FHELP5)/D3
            SD3=SD2-SD3
            SD2=SD1-SD2
            SD3=SD2-SD3
            GRADHI(J)=SD1+P4*SD2+SD3/C45
          ENDDO
        ENDIF

        ENDIF
        DO J=1,N
          GRADHI(J)=XSC(J)*GRADHI(J)
        ENDDO
        RETURN
      ENDIF
      END
C COMPUTE THE I-TH INEQUALITY CONSTAINT, BOUNDS INCLUDED
      SUBROUTINE ESG(I,X,GXI)
      INCLUDE 'O8FUCO.INC'
      INCLUDE 'O8FINT.INC'
      DOUBLE PRECISION X(*),GXI
      INTEGER I
      INTEGER J
      SAVE
      IF ( BLOC ) THEN
        IF ( VALID ) THEN
          IF ( GUNIT(1,I+NH) .NE. 1 ) CRES(I+NH)=CRES(I+NH)+1
          GXI=FU(I+NH)
        ELSE
          STOP 'DONLP2: BLOC CALL WITH FUNCTION INFO INVALID'
        ENDIF
      ELSE
        DO J=1,N
          XTR(J)=X(J)*XSC(J)
        ENDDO
        CALL EG(I,XTR,GXI)
      ENDIF
      RETURN
      END
C EVALUATION OF GRADIENT OF I-TH INEQUALITY
C NOT NECESSARY FOR BOUNDS, BUT CONSTANT GRADIENTS MUST BE SET
C HERE E.G. USING DCOPY FROM A DATA-FIELD
      SUBROUTINE ESGRADG(I,X,GRADGI)
      INCLUDE 'O8FUCO.INC'
      INCLUDE 'O8CONS.INC'
      INCLUDE 'O8FINT.INC'
      DOUBLE PRECISION X(*) ,GRADGI(*)
      INTEGER I,J
      DOUBLE PRECISION D1,D2,D3,SD1,SD2,SD3,FHELP,FHELP1,FHELP2,
     *   FHELP3,FHELP4,FHELP5,FHELP6,XINCR,XHELP,GIXLOC
      SAVE
      IF ( GUNIT(1,I+NH) .EQ. 1 ) THEN
        DO  J=1,N
	  GRADGI(J)=ZERO
        ENDDO
        GRADGI(GUNIT(2,I+NH))=GUNIT(3,I+NH)*XSC(GUNIT(2,I+NH))
        RETURN
      ENDIF
      IF ( BLOC ) THEN
        IF ( VALID ) THEN
          IF ( GUNIT(1,I+NH) .NE. 1 ) CGRES(I+NH)=CGRES(I+NH)+1
          DO J=1,N
            GRADGI(J)=XSC(J)*FUGRAD(J,I+NH)
          ENDDO
          RETURN
        ELSE
          STOP 'DONLP2: BLOC CALL WITH FUNCTION INFO INVALID'
        ENDIF
      ELSE
        DO J=1,N
          XTR(J)=X(J)*XSC(J)
        ENDDO
        IF ( ANALYT ) THEN
          CALL EGRADG(I,XTR,GRADGI)
        ELSE
        IF ( DIFFTYPE .EQ. 1 ) THEN
          DELDIF=MIN(TM1*SQRT(EPSFCN),TM2)
          CALL EG(I,XTR,GIXLOC)
          DO J=1,N
            XHELP=XTR(J)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND)
            IF ( XHELP .GE. ZERO ) THEN
              XTR(J)=XHELP+XINCR
            ELSE
              XTR(J)=XHELP-XINCR
            ENDIF
            CALL EG(I,XTR,FHELP)
            GRADGI(J)=(FHELP-GIXLOC)/(XTR(J)-XHELP)
            XTR(J)=XHELP
          ENDDO
        ELSEIF ( DIFFTYPE .EQ. 2 ) THEN 
          DELDIF=MIN(TM1*EPSFCN**(ONE/THREE),TM2)
          DO J=1,N
            XHELP=XTR(J)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND)
            XTR(J)=XHELP+XINCR
            CALL EG(I,XTR,FHELP1)
            XTR(J)=XHELP-XINCR
            CALL EG(I,XTR,FHELP2)
            GRADGI(J)=(FHELP1-FHELP2)/(XINCR+XINCR)
            XTR(J)=XHELP
          ENDDO
        ELSE
          DELDIF=MIN(TM1*EPSFCN**(ONE/SEVEN),TM2)
          DO J=1,N
            XHELP=XTR(J)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND/FOUR)
            XTR(J)=XHELP-XINCR
            CALL EG(I,XTR,FHELP1)
            XTR(J)=XHELP+XINCR
            CALL EG(I,XTR,FHELP2)
            XINCR=XINCR+XINCR
            D1=XINCR
            XTR(J)=XHELP-XINCR
            CALL EG(I,XTR,FHELP3)
            XTR(J)=XHELP+XINCR
            CALL EG(I,XTR,FHELP4)
            XINCR=XINCR+XINCR
            D2=XINCR
            XTR(J)=XHELP-XINCR
            CALL EG(I,XTR,FHELP5)
            XTR(J)=XHELP+XINCR
            CALL EG(I,XTR,FHELP6)
            XTR(J)=XHELP
            D3=XINCR+XINCR
            SD1=(FHELP2-FHELP1)/D1
            SD2=(FHELP4-FHELP3)/D2
            SD3=(FHELP6-FHELP5)/D3
            SD3=SD2-SD3
            SD2=SD1-SD2
            SD3=SD2-SD3
            GRADGI(J)=SD1+P4*SD2+SD3/C45
          ENDDO
        ENDIF

        ENDIF
        DO J=1,N
          GRADGI(J)=XSC(J)*GRADGI(J)
        ENDDO
      ENDIF
      RETURN
      END
      SUBROUTINE EVAL_EXTERN(MODE)
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8FINT.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER MODE,I,J
      DOUBLE PRECISION GR(NX)
      SAVE
C***** THIS IS A MODEL OF EVAL_EXTERN, SIMPLY CALLING THE 
C***** STANDARD EVALUATION FUNCTIONS OF THE OPTIMIZATION PACKAGE
        IF ( MODE .EQ. 0 ) THEN
          DO I=1,NRES
            IF ( GUNIT(1,I) .EQ. 1 ) THEN
              IF ( I .LE. NH ) CALL EH(I,XTR,FU(I))
              IF ( I .GT. NH ) CALL EG(I-NH,XTR,FU(I))
            ENDIF
          ENDDO
          RETURN
        ENDIF
        CALL EF(XTR,FU(0))
        IF ( GUNIT(1,0) .NE. 1 .AND. MODE .EQ. 2 ) THEN
          IF ( ANALYT ) THEN
            CALL EGRADF(XTR,GR)
            DO I=1,N
              FUGRAD(I,0)=GR(I)
            ENDDO
          ENDIF
        ENDIF
        DO J=1,NH 
          CALL EH(J,XTR,FU(J))
          IF ( GUNIT(1,J) .NE. 1 .AND. MODE .EQ. 2 ) THEN
            IF ( ANALYT ) THEN
              CALL EGRADH(J,XTR,GR)
              DO I=1,N
                FUGRAD(I,J)=GR(I)
              ENDDO
            ENDIF
          ENDIF
        ENDDO
        DO J=1,NG
          CALL EG(J,XTR,FU(NH+J))
          IF ( GUNIT(1,J+NH) .NE. 1 .AND. MODE .EQ. 2 ) THEN
            IF ( ANALYT ) THEN
              CALL EGRADG(J,XTR,GR)
              DO I=1,N
                FUGRAD(I,J+NH)=GR(I)
              ENDDO
            ENDIF
          ENDIF
        ENDDO
        VALID=.TRUE.
        RETURN
      END

      SUBROUTINE USER_EVAL(XVAR,MODE)
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8FINT.INC'
      INCLUDE 'O8CONS.INC'
      INTEGER MODE
      DOUBLE PRECISION XVAR(*)
C
C**************************************
C     CALLED ONLY IF BLOC=.TRUE.
C     INTERFACE TO A USERS EVALUATION CODE OF FUNCTIONS
C     WHICH DEFINE THE OPTIMIZATION PROBLEM
C     MODE=-1 : EVALUATE FUNCTION VALUES AT XVAR ONLY, STORE THEM IN FU
C
C     MODE=0  : EVALUATE INEQUALITY CONSTRAINTS AND 
C               EQUALITY CONSTRAINTS WITH GUNIT(1,.)=1 ONLY AT XVAR 
C     MODE=1  : EVALUATE FUNCTION AND GRADIENT VALUES AT XVAR AND STORE THEM IN 
C               FU AND FUGRAD
C
C     MODE=2  : EVALUATE GRADIENTS ONLY AT XVAR AND STORE THEM IN FUGRAD
C
C     THE USERS EVALUATION ROUTINE 
C
C               EVAL_EXTERN(MODE)
C
C     IS CALLED WITH THREE SETINGS OF ITS MODE ONLY: 
C     MODE=0: EVALUATE CONSTRAINTS WHICH DEPEND LINEARLY 
C     ON ONE VARIABLE ONLY (GUNIT(1,I)=1).
C     MODE=1: SET FUNCTION VALUE
C     FU USING XTR, MODE=2 SET FUNCTION VALUES FU AND GRADIENTS FUGRAD USING
C     XTR
C     SINCE DONLP2 USES INTERNALLY A SCALED VALUE OF X, THE EXTERNAL VALUE XTR
C     IS OBTAINED BY MULTIPLYING WITH XSC. IN EVALUATING THE GRADIENTS, 
C     THE USER MUST NOT TAKE CARE OF THIS SCALING. SCALING OF THE GRADIENTS
C     IS DONE BY DONLP2 INTERNALLY. 
C     
C     IF THE USER HAS SET ANALYT=TRUE, HE IS RESPONSIBLE FOR COMPUTING
C     THE GRADIENTS HIMSELF CORRECTLY
C     OTHERWISE, IF ANALYT=.FALSE., THEN THIS ROUTINE DOES NUMERICAL 
C     DIFFERENTIATION ACCORDING TO THE METHOD DEFINED BY DIFFTYPE:
C
C     DIFFTYPE=1   ORDINARY FORWARD DIFFERENCE QUOTIENT, USING
C                  MIN(0.1*SQRT(EPSFCN),1.D-2) AS STEPSIZE
C                  EPSFCN IS THE ASSUMED PRECISION OF FUNCTION VALUES
C                  AND MUST BE SET BY THE USER IN SETUP0
C     DIFFTYPE=2   CENTRAL DIFFERENCE QUOTIENT WITH STEPSIZE
C                  MIN(0.1*EPSFCN**(1/3),1.D-2) AS STEPSIZE
C     DIFFTYPE=3   6-TH ORDER RICHARDSON EXTRAPOLATION METHOD USING
C                  6 FUNCTION VALUES FOR EACH COMPONENT OF GRAD,
C                  WITH STEPSIZE MIN(0.1*EPSFCN**(1/7),0.01)
C                  
C     THIS IS DONE BY SEVERAL CALLS OF EVAL_EXTERN
C     XTR IS THE CURRENT DESIGN TO BE USED BY THE EXTERNAL ROUTINE
C
C     VALUES MUST BE RETURNED IN THE ARRAYS FU (AND FUGRAD). 
C      THE ORDER OF INFORMATION IS AS FOLLOWS:
C
C      FU(0)  OBJECTIVE FUNCTION VALUE 
C      FUGRAD(I,0) : OBJECTIVE FUNCTION GRADIENT, I=1,...,N THE COMPONENTS
C
C      FU(1),...,FU(NH)  EQUALITY CONSTRAINTS (IF ANY)
C      FUGRAD(I,1),.., FUGRAD(I,NH) GRADIENTS OF EQUALITY CONSTRAINTS
C
C      FU(NH+1),...,FU(NG+NH) INEQUALITY CONSTRAINTS 
C      FUGRAD(I,NH+1),...,FUGRAD(I,NH+NG) THE GRADIENTS OF THE INEQUALITY
C                   CONSTRAINTS, WTIH COMPONENT I=1,..,N
C      IF THERE ARE BOUND CONSTRAINTS OR FIXED VARIABLES AS DESCRIBED
C      BY THE ARRAY GUNIT IN SETUP0, THESE MUST BE EVALUATED HERE TOO.
C      THEIR GRADIENTS HOWEVER NEED NOT TO BE COMPUTED. 
C      
C      THE METHOD USES THE PARAMETERS 
C        
C           EPSFCN = RELATIVE ACCURACY OF FUNCTION VALUES
C           TAUBND = AMOUNT BY WHICH BOUND CONSTRAINTS MAY BE VIOLATED
C                    DURING FINITE DIFFERENCING
C           DIFFTYPE (SEE ABOVE)
C           ANALYT (SEE ABOVE) 
C
C      THESE MUST BE SET PRIOR IN SETUP0 
C****************************************************************
      DOUBLE PRECISION FUSAVE(0:NRESM),XHELP,XINCR,SD1,SD2,SD3,
     *  D1,D2,D3
      INTEGER I,J
      LOGICAL CHANGED
      IF ( MODE .LT. -1 .OR. MODE .GT. 2 ) 
     *   STOP 'DONLP2: CALL OF USER_EVAL WITH UNDEFINED MODE'
      IF ( MODE .EQ. 0 ) THEN
        DO I=1,N
          XTR(I)=XSC(I)*XVAR(I)
        ENDDO
        CALL EVAL_EXTERN(0)
        VALID=.TRUE.
      ENDIF
      IF ( MODE .EQ. -1 ) THEN
        CHANGED=.FALSE.
        DO I=1,N
          IF ( XTR(I) .NE. XSC(I)*XVAR(I) ) CHANGED=.TRUE.
        ENDDO
        IF ( CHANGED .OR. .NOT. VALID ) THEN
          DO I=1,N
            XTR(I)=XSC(I)*XVAR(I)
          ENDDO
          CALL EVAL_EXTERN(1)
          VALID=.TRUE.
        ENDIF
        RETURN
      ENDIF
      IF ( MODE .GE. 1 ) THEN
C******* EVALUATE FUNCTIONS AND ITS GRADIENTS
        DO I=1,N
          XTR(I)=XSC(I)*XVAR(I)
        ENDDO
C******* EVEN IF XTR DID NOT CHANGE WE MUST EVALUATE EXTERNALLY, SINCE NOW
C******* GRADIENTS ARE REQUIRED
        IF ( ANALYT ) THEN 
          CALL EVAL_EXTERN(2)
          VALID=.TRUE.
          RETURN
        ELSE
          IF ( MODE .EQ. 1 ) CALL EVAL_EXTERN(1)
        ENDIF
C**** CONTINUE WITH COMPUTING THE GRADIENTS : MODE=1 OR MODE=2 REQUIRE GRADIENTS
        IF ( DIFFTYPE .EQ. 1 ) THEN
          DELDIF=MIN(TM1*SQRT(EPSFCN),TM2)
          IF ( MODE .EQ. 2 ) CALL EVAL_EXTERN(1)
          DO J=0,NRES
            FUSAVE(J)=FU(J)
          ENDDO
          DO I=1,N
            XHELP=XTR(I)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND)
            IF ( XHELP .GE. ZERO ) THEN
              XTR(I)=XHELP+XINCR
            ELSE
              XTR(I)=XHELP-XINCR
            ENDIF
            CALL EVAL_EXTERN(1)
            DO J=0,NRES
              FUGRAD(I,J)=(FU(J)-FUSAVE(J))/(XTR(I)-XHELP)
            ENDDO
            XTR(I)=XHELP
          ENDDO
          DO J=0,NRES
            FU(J)=FUSAVE(J)
          ENDDO
          VALID=.TRUE.
          RETURN
        ELSEIF ( DIFFTYPE .EQ. 2 ) THEN 
          DELDIF=MIN(TM1*EPSFCN**(ONE/THREE),TM2)
          DO J=0,NRES
            FUSAVE(J)=FU(J)
          ENDDO
          DO I=1,N
            XHELP=XTR(I)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND)
            XTR(I)=XHELP+XINCR
            CALL EVAL_EXTERN(1)
            DO J=0,NRES
              FUD(J,1)=FU(J)
            ENDDO
            XTR(I)=XHELP-XINCR
            CALL EVAL_EXTERN(1)
            DO J=0,NRES
              FUD(J,2)=FU(J)
            ENDDO
            DO J=0,NRES
              FUGRAD(I,J)=(FUD(J,1)-FUD(J,2))/(XINCR+XINCR)
            ENDDO
            XTR(I)=XHELP
          ENDDO
          DO J=0,NRES
            FU(J)=FUSAVE(J)
          ENDDO
          VALID=.TRUE.
          RETURN
        ELSE
          DELDIF=MIN(TM1*EPSFCN**(ONE/SEVEN),TM2)
          DO J=0,NRES
            FUSAVE(J)=FU(J)
          ENDDO
          DO I=1,N
            XHELP=XTR(I)
            XINCR=MIN(TM2,DELDIF*ABS(XHELP)+DELDIF,TAUBND/FOUR)
            XTR(I)=XHELP-XINCR
            CALL EVAL_EXTERN(1)
            DO J=0,NRES
              FUD(J,1)=FU(J)
            ENDDO
            XTR(I)=XHELP+XINCR
            CALL EVAL_EXTERN(1)
            DO J=0,NRES
              FUD(J,2)=FU(J)
            ENDDO
            XINCR=XINCR+XINCR
            D1=XINCR
            XTR(I)=XHELP-XINCR
            CALL EVAL_EXTERN(1)
            DO J=0,NRES
              FUD(J,3)=FU(J)
            ENDDO
            XTR(I)=XHELP+XINCR
            CALL EVAL_EXTERN(1)
            DO J=0,NRES
              FUD(J,4)=FU(J)
            ENDDO
            XINCR=XINCR+XINCR
            D2=XINCR
            XTR(I)=XHELP-XINCR
            CALL EVAL_EXTERN(1)
            DO J=0,NRES
              FUD(J,5)=FU(J)
            ENDDO
            XTR(I)=XHELP+XINCR
            CALL EVAL_EXTERN(1)
            DO J=0,NRES
              FUD(J,6)=FU(J)
            ENDDO
            XTR(I)=XHELP
            D3=XINCR+XINCR
            DO J=0,NRES
              SD1=(FUD(J,2)-FUD(J,1))/D1
              SD2=(FUD(J,4)-FUD(J,3))/D2
              SD3=(FUD(J,6)-FUD(J,5))/D3
              SD3=SD2-SD3
              SD2=SD1-SD2
              SD3=SD2-SD3
              FUGRAD(I,J)=SD1+P4*SD2+SD3/C45
            ENDDO
          ENDDO
          DO J=0,NRES
            FU(J)=FUSAVE(J)
          ENDDO
          VALID=.TRUE.
          RETURN
        ENDIF
      ENDIF
      END
      SUBROUTINE SOLCHK
      INCLUDE 'O8COMM.INC'
      INCLUDE 'O8CONS.INC'
C***** THE USER MAY ADD ADDITIONAL COMPUTATIONS USING THE COMPUTED
C      SOLUTION HERE
      RETURN
      END
C*********************************************************************
C  THIS IS THE SYSTEM-DEPENDENT PART OF DONLP2. ON A SYSTEM WITH GNU FORTRAN 
C  WORKS WITHOUT ANY CHANGES .
C  
      REAL FUNCTION O8CPU(IDUM)
C     IMPLICIT NONE
C**** COMPUTES ELAPSED USER TIME (CPU-TIME) OF THE CURRENT RUN
C     IN SECONDS
C     MAY BE REPLACED BY AN OTHER SYSTEM DEPENDENT ROUTINE
C     INTEGER IDUM
C     REAL PROCSEC
C     CALL SECOND(PROCSEC)
C     O8CPU=PROCSEC
      RETURN
      END
C***************************************************************************************
      SUBROUTINE O8TIDA(CHAN)
C     IMPLICIT NONE
C     INTEGER CHAN
C     CHARACTER*30 TIMDAT

C     TIMDAT=CTIME(TIME8())
C**** WRITE TIME AND DATE TO SEQUENTIAL ACCESS CHANNEL CHAN
C     WRITE(CHAN,FMT='((A))') TIMDAT

      RETURN
      END
C
C
C   END OF SYSTEM-DEPENDENT PART OF DONLP2
C************************************************************
