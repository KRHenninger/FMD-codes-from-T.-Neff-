/**

  \file coulomb.c

  calculates 1/sqrt(z) erf(sqrt(z)) for complex z
  using a pade approximation


  (c) 2003 Thomas Neff

*/

#include <complex.h>
#include <math.h>

#include "cmath.h"

static double a[6] = { 0.12228728955784313,
		       0.019692861923536982,
		       0.005868041572999935,
		       0.0004050529188359762,
		       0.000042130942417361236,
		       6.711788678011616e-7 };

static double b[7] = { 0.10837312686605202,
		       0.053580106371306946,
		       0.012218473847361057,
		       0.0016581412280317082,
		       0.00013971095749328453,
		       7.460683385931586e-6,
		       2.3222884805384286e-8 };

static double da[11] = { -0.0044179889587729285,
			 -0.0017164520709623717,
			 -0.0004028246620787466,
			 -0.0000719775849354321,
			 -0.000010460742805648802,
			 -1.0709884497710917e-6,
			 -9.575436033318034e-8,
			 -4.363215873727756e-9,
			 -2.48774071679726e-10,
			 -1.956804045001316e-12,
			 -1.5586709530754622e-14 };


complex double zcoulomb(complex double z)
{
  return (a[0]+z*(a[1]+z*(a[2]+z*(a[3]+z*(a[4]+z*a[5])))))/
    (b[0]+z*(b[1]+z*(b[2]+z*(b[3]+z*(b[4]+z*(b[5]+z*b[6]))))));
}


complex double dzcoulomb(complex double z)
{
  return (da[0]+z*(da[1]+z*(da[2]+z*(da[3]+z*(da[4]+z*(da[5]+z*(da[6]+z*(da[7]+z*(da[8]+z*(da[9]+z*da[10]))))))))))/
    csqr(b[0]+z*(b[1]+z*(b[2]+z*(b[3]+z*(b[4]+z*(b[5]+z*b[6]))))));
}

